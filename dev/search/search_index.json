{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pytanis \u00b6 Utilities for the program organization of conferences using Pretalx! This is alpha version! It might break sometimes! Trivia : The name Pytanis is a reference to Prytanis using the typical py prefix of Python tools. Prytanis was the name given to the leading members of the government of a city (polis) in ancient Greece. Offices that used this title usually had responsibility for presiding over councils of some kind, which met in the Prytaneion . Features \u00b6 simple configuration management with a config folder in your home directory, just like many other tools do easily access Google Sheets , potentially filled by some Google Forms , and download it as DataFrame easy to use Pretalx client that return proper Python objects thanks to the power of pydantic simple HelpDesk client for batch mails, e.g. to your reviewers tools to assign proposals to reviewers based on constraints like preferences tools to support the final selection process of proposals tools to support the creation of the final program schedule awesome documentation with best practices for the program committee of any community conference License \u00b6 Pytanis is distributed under the terms of the MIT license. Navigation \u00b6 Documentation for specific MAJOR.MINOR versions can be chosen by using the dropdown on the top of every page. The dev version reflects changes that have not yet been released. Also, desktop readers can use special keyboard shortcuts: Keys Action , (comma) p Navigate to the \"previous\" page . (period) n Navigate to the \"next\" page / s Display the search modal","title":"About"},{"location":"#pytanis","text":"Utilities for the program organization of conferences using Pretalx! This is alpha version! It might break sometimes! Trivia : The name Pytanis is a reference to Prytanis using the typical py prefix of Python tools. Prytanis was the name given to the leading members of the government of a city (polis) in ancient Greece. Offices that used this title usually had responsibility for presiding over councils of some kind, which met in the Prytaneion .","title":"Pytanis"},{"location":"#features","text":"simple configuration management with a config folder in your home directory, just like many other tools do easily access Google Sheets , potentially filled by some Google Forms , and download it as DataFrame easy to use Pretalx client that return proper Python objects thanks to the power of pydantic simple HelpDesk client for batch mails, e.g. to your reviewers tools to assign proposals to reviewers based on constraints like preferences tools to support the final selection process of proposals tools to support the creation of the final program schedule awesome documentation with best practices for the program committee of any community conference","title":"Features"},{"location":"#license","text":"Pytanis is distributed under the terms of the MIT license.","title":"License"},{"location":"#navigation","text":"Documentation for specific MAJOR.MINOR versions can be chosen by using the dropdown on the top of every page. The dev version reflects changes that have not yet been released. Also, desktop readers can use special keyboard shortcuts: Keys Action , (comma) p Navigate to the \"previous\" page . (period) n Navigate to the \"next\" page / s Display the search modal","title":"Navigation"},{"location":"authors/","text":"Contributors \u00b6 Florian Wilhelm Florian.Wilhelm@gmail.com","title":"Authors"},{"location":"authors/#contributors","text":"Florian Wilhelm Florian.Wilhelm@gmail.com","title":"Contributors"},{"location":"changelog/","text":"Changelog \u00b6 Version 0.2 (2023-01-XX) \u00b6 have a progress bar for long-running commands when possible use gspread to handle the low-level GoogleAPI use gspread-dataframe to handle converting a worksheet into a dataframe timeout of 60s for PretalxAPI as it is really slow which caused a lot of timeout errors rename *API to *Client as it's rather a client for an API moved some functionality from review to pretalx.utils GSheetClient allows uploading dataframes to Google Sheets Version 0.1.1 (2023-01-16) \u00b6 fix typo sent -> send in MailClient Version 0.1 (2023-01-15) \u00b6 First alpha version to can be used Google client to retrieve Google Sheets implemented Pretalx client implement A very basic HelpDesk client (minimal functionality) implemented Basic e-mail client implemented to send mails via HelpDesk Central configuration management for secrets and credentials implemented","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#version-02-2023-01-xx","text":"have a progress bar for long-running commands when possible use gspread to handle the low-level GoogleAPI use gspread-dataframe to handle converting a worksheet into a dataframe timeout of 60s for PretalxAPI as it is really slow which caused a lot of timeout errors rename *API to *Client as it's rather a client for an API moved some functionality from review to pretalx.utils GSheetClient allows uploading dataframes to Google Sheets","title":"Version 0.2 (2023-01-XX)"},{"location":"changelog/#version-011-2023-01-16","text":"fix typo sent -> send in MailClient","title":"Version 0.1.1 (2023-01-16)"},{"location":"changelog/#version-01-2023-01-15","text":"First alpha version to can be used Google client to retrieve Google Sheets implemented Pretalx client implement A very basic HelpDesk client (minimal functionality) implemented Basic e-mail client implemented to send mails via HelpDesk Central configuration management for secrets and credentials implemented","title":"Version 0.1 (2023-01-15)"},{"location":"contributing/","text":"Contributing \u00b6 Welcome to the contributor guide of Pytanis. This document focuses on getting any potential contributor familiarized with the development processes, but other kinds of contributions are also appreciated. If you are new to using git or have never collaborated in a project previously, please have a look at contribution-guide.org . Other resources are also listed in the excellent guide created by Freecodecamp 1 . Please notice, all users and contributors are expected to be open, considerate, reasonable, and respectful . When in doubt, Python Software Foundation's Code of Conduct is a good reference in terms of behavior guidelines. Issue Reports \u00b6 If you experience bugs or general issues with Pytanis, please have a look on the issue tracker . If you don't see anything useful there, please feel free to fire an issue report. Tip Please don't forget to include the closed issues in your search. Sometimes a solution was already reported, and the problem is considered solved . New issue reports should include information about your programming environment (e.g., operating system, Python version) and steps to reproduce the problem. Please try also to simplify the reproduction steps to a very minimal example that still illustrates the problem you are facing. By removing other factors, you help us to identify the root cause of the issue. Documentation improvements \u00b6 You can help to the documentation of Pytanis by making them more readable and coherent, or by adding missing information and correcting mistakes. The documentation uses mkdocs as its main documentation compiler. This means that the docs are kept in the same repository as the project code, and that any documentation update is done in the same way was a code contribution. Tip Please notice that the GitHub web interface provides a quick way of propose changes in Pytanis 's files. While this mechanism can be tricky for normal code contributions, it works perfectly fine for contributing to the docs, and can be quite handy. If you are interested in trying this method out, please navigate to the docs folder in the source repository , find which file you would like to propose changes and click in the little pencil icon at the top, to open GitHub's code editor . Once you finish editing the file, please write a message in the form at the bottom of the page describing which changes have you made and what are the motivations behind them and submit your proposal. When working on documentation changes in your local machine, you can build and serve them using hatch with hatch run docs:build and hatch run docs:serve , respectively. Code Contributions \u00b6 Submit an issue \u00b6 Before you work on any non-trivial code contribution it's best to first create a report in the issue tracker to start a discussion on the subject. This often provides additional considerations and avoids unnecessary work. Clone the repository \u00b6 Create a user account on GitHub if you do not already have one. Fork the project repository : click on the Fork button near the top of the page. This creates a copy of the code under your account on GitHub. Clone this copy to your local disk: git clone git@github.com:YourLogin/pytanis.git cd pytanis Make sure hatch is installed using pipx : pipx install hatch [only once] install pre-commit hooks in the default environment with: hatch run pre-commit install Implement your changes \u00b6 Create a branch to hold your changes: git checkout -b my-feature and start making changes. Never work on the main branch! Start your work on this branch. Don't forget to add docstrings in Google style to new functions, modules and classes, especially if they are part of public APIs. Add yourself to the list of contributors in AUTHORS.md . When you\u2019re done editing, do: git add <MODIFIED FILES> git commit to record your changes in git . Please make sure to see the validation messages from pre-commit and fix any eventual issues. This should automatically use flake8 / black to check/fix the code style in a way that is compatible with the project. Info Don't forget to add unit tests and documentation in case your contribution adds a feature and is not just a bugfix. Moreover, writing an descriptive commit message is highly recommended. In case of doubt, you can check the commit history with: git log --graph --decorate --pretty=oneline --abbrev-commit --all to look for recurring communication patterns. Please check that your changes don't break any unit tests with hatch run test:cov or hatch run test:no-cov to run the unitest with or without coverage reports, respectively. Submit your contribution \u00b6 If everything works fine, push your local branch to the remote server with: git push -u origin my-feature Go to the web page of your fork and click \"Create pull request\" to send your changes for review. Find more detailed information in creating a PR . You might also want to open the PR as a draft first and mark it as ready for review after the feedbacks from the continuous integration (CI) system or any required fixes. Even though, these resources focus on open source projects and communities, the general ideas behind collaborating with other developers to collectively create software are general and can be applied to all sorts of environments, including private companies and proprietary code bases. \u21a9","title":"Contributing"},{"location":"contributing/#contributing","text":"Welcome to the contributor guide of Pytanis. This document focuses on getting any potential contributor familiarized with the development processes, but other kinds of contributions are also appreciated. If you are new to using git or have never collaborated in a project previously, please have a look at contribution-guide.org . Other resources are also listed in the excellent guide created by Freecodecamp 1 . Please notice, all users and contributors are expected to be open, considerate, reasonable, and respectful . When in doubt, Python Software Foundation's Code of Conduct is a good reference in terms of behavior guidelines.","title":"Contributing"},{"location":"contributing/#issue-reports","text":"If you experience bugs or general issues with Pytanis, please have a look on the issue tracker . If you don't see anything useful there, please feel free to fire an issue report. Tip Please don't forget to include the closed issues in your search. Sometimes a solution was already reported, and the problem is considered solved . New issue reports should include information about your programming environment (e.g., operating system, Python version) and steps to reproduce the problem. Please try also to simplify the reproduction steps to a very minimal example that still illustrates the problem you are facing. By removing other factors, you help us to identify the root cause of the issue.","title":"Issue Reports"},{"location":"contributing/#documentation-improvements","text":"You can help to the documentation of Pytanis by making them more readable and coherent, or by adding missing information and correcting mistakes. The documentation uses mkdocs as its main documentation compiler. This means that the docs are kept in the same repository as the project code, and that any documentation update is done in the same way was a code contribution. Tip Please notice that the GitHub web interface provides a quick way of propose changes in Pytanis 's files. While this mechanism can be tricky for normal code contributions, it works perfectly fine for contributing to the docs, and can be quite handy. If you are interested in trying this method out, please navigate to the docs folder in the source repository , find which file you would like to propose changes and click in the little pencil icon at the top, to open GitHub's code editor . Once you finish editing the file, please write a message in the form at the bottom of the page describing which changes have you made and what are the motivations behind them and submit your proposal. When working on documentation changes in your local machine, you can build and serve them using hatch with hatch run docs:build and hatch run docs:serve , respectively.","title":"Documentation improvements"},{"location":"contributing/#code-contributions","text":"","title":"Code Contributions"},{"location":"contributing/#submit-an-issue","text":"Before you work on any non-trivial code contribution it's best to first create a report in the issue tracker to start a discussion on the subject. This often provides additional considerations and avoids unnecessary work.","title":"Submit an issue"},{"location":"contributing/#clone-the-repository","text":"Create a user account on GitHub if you do not already have one. Fork the project repository : click on the Fork button near the top of the page. This creates a copy of the code under your account on GitHub. Clone this copy to your local disk: git clone git@github.com:YourLogin/pytanis.git cd pytanis Make sure hatch is installed using pipx : pipx install hatch [only once] install pre-commit hooks in the default environment with: hatch run pre-commit install","title":"Clone the repository"},{"location":"contributing/#implement-your-changes","text":"Create a branch to hold your changes: git checkout -b my-feature and start making changes. Never work on the main branch! Start your work on this branch. Don't forget to add docstrings in Google style to new functions, modules and classes, especially if they are part of public APIs. Add yourself to the list of contributors in AUTHORS.md . When you\u2019re done editing, do: git add <MODIFIED FILES> git commit to record your changes in git . Please make sure to see the validation messages from pre-commit and fix any eventual issues. This should automatically use flake8 / black to check/fix the code style in a way that is compatible with the project. Info Don't forget to add unit tests and documentation in case your contribution adds a feature and is not just a bugfix. Moreover, writing an descriptive commit message is highly recommended. In case of doubt, you can check the commit history with: git log --graph --decorate --pretty=oneline --abbrev-commit --all to look for recurring communication patterns. Please check that your changes don't break any unit tests with hatch run test:cov or hatch run test:no-cov to run the unitest with or without coverage reports, respectively.","title":"Implement your changes"},{"location":"contributing/#submit-your-contribution","text":"If everything works fine, push your local branch to the remote server with: git push -u origin my-feature Go to the web page of your fork and click \"Create pull request\" to send your changes for review. Find more detailed information in creating a PR . You might also want to open the PR as a draft first and mark it as ready for review after the feedbacks from the continuous integration (CI) system or any required fixes. Even though, these resources focus on open source projects and communities, the general ideas behind collaborating with other developers to collectively create software are general and can be applied to all sorts of environments, including private companies and proprietary code bases. \u21a9","title":"Submit your contribution"},{"location":"license/","text":"The MIT License (MIT) Copyright \u00a9 2022 Florian Wilhelm Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"reference/SUMMARY/","text":"pytanis config google helpdesk client mail types pretalx client types utils review utils","title":"SUMMARY"},{"location":"reference/pytanis/","text":"pytanis \u00b6 __all__ = [ '__version__' , 'GSheetClient' , 'PretalxClient' , 'HelpDeskClient' ] module-attribute \u00b6 __version__ = version ( 'pytanis' ) module-attribute \u00b6 GSheetClient ( config : Optional [ Config ] = None , read_only : bool = True ) \u00b6 Google API to easily handle GSheets and other files on GDrive By default, only the least permissive scope GSHEET_RO in case of read_only = True is used. Source code in pytanis/google.py def __init__ ( self , config : Optional [ Config ] = None , read_only : bool = True ): self . _read_only = read_only if read_only : self . _scopes = [ Scope . GSHEET_RO ] else : self . _scopes = [ Scope . GSHEET_RW ] if config is None : config = get_cfg () self . _config = config self . gc = gspread_client ( self . _scopes , config ) # gspread client for more functionality gc = gspread_client ( self . _scopes , config ) instance-attribute \u00b6 clear_gsheet ( spreadsheet_id : str , worksheet_name : str ) \u00b6 Clear the worksheet including values, formatting, filtering, etc. Source code in pytanis/google.py def clear_gsheet ( self , spreadsheet_id : str , worksheet_name : str ): \"\"\"Clear the worksheet including values, formatting, filtering, etc.\"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name ) default_fmt = get_default_format ( worksheet . spreadsheet ) range = worksheet_range ( worksheet ) try : worksheet . clear () worksheet . clear_basic_filter () format_cell_range ( worksheet , range , default_fmt ) rules = get_conditional_format_rules ( worksheet ) rules . clear () rules . save () set_data_validation_for_cell_range ( worksheet , range , None ) except APIError as error : self . _exception_feedback ( error ) gsheet ( spreadsheet_id : str , worksheet_name : Optional [ str ] = None ) -> Union [ Worksheet , Spreadsheet ] \u00b6 Retrieve a Google sheet by its id and the name Open a Google sheet in your browser and check the URL to retrieve the id, e.g.: https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit ... If the spreadsheet as several worksheets (check the lower bar) then worksheet_name can be used to specify a specific one. Source code in pytanis/google.py def gsheet ( self , spreadsheet_id : str , worksheet_name : Optional [ str ] = None ) -> Union [ Worksheet , Spreadsheet ]: \"\"\"Retrieve a Google sheet by its id and the name Open a Google sheet in your browser and check the URL to retrieve the id, e.g.: https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit... If the spreadsheet as several worksheets (check the lower bar) then `worksheet_name` can be used to specify a specific one. \"\"\" spreadsheet = self . gc . open_by_key ( spreadsheet_id ) if worksheet_name is None : return spreadsheet else : worksheet = spreadsheet . worksheet ( worksheet_name ) return worksheet gsheet_as_df ( spreadsheet_id : str , worksheet_name : str , kwargs : Union [ str , bool , int ]) -> pd . DataFrame \u00b6 Returns a worksheet as dataframe Source code in pytanis/google.py def gsheet_as_df ( self , spreadsheet_id : str , worksheet_name : str , ** kwargs : Union [ str , bool , int ]) -> pd . DataFrame : \"\"\"Returns a worksheet as dataframe\"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name ) df = get_as_dataframe ( worksheet , ** kwargs ) # remove Nan rows & columns as they are exported by default df . dropna ( how = 'all' , inplace = True , axis = 0 ) df . dropna ( how = 'all' , inplace = True , axis = 1 ) return df recreate_token () \u00b6 Recreate the current token using the scopes given at initialization Source code in pytanis/google.py def recreate_token ( self ): \"\"\"Recreate the current token using the scopes given at initialization\"\"\" self . _config . Google . token_json . unlink ( missing_ok = True ) self . gc = gspread_client ( self . _scopes , self . _config ) save_df_as_gsheet ( df : pd . DataFrame , spreadsheet_id : str , worksheet_name : str , kwargs : Union [ str , bool , int ]) \u00b6 Save the given dataframe as worksheet in a spreadsheet Make sure that the scope passed gives you write permissions Parameters: Name Type Description Default df pd . DataFrame dataframe to save required spreadsheet_id str id of the Google spreadsheet required worksheet_name str name of the worksheet within the spreadsheet required **kwargs Union [ str , bool , int ] extra keyword arguments passed to set_with_dataframe {} Source code in pytanis/google.py def save_df_as_gsheet ( self , df : pd . DataFrame , spreadsheet_id : str , worksheet_name : str , ** kwargs : Union [ str , bool , int ] ): \"\"\"Save the given dataframe as worksheet in a spreadsheet Make sure that the scope passed gives you write permissions Args: df: dataframe to save spreadsheet_id: id of the Google spreadsheet worksheet_name: name of the worksheet within the spreadsheet **kwargs: extra keyword arguments passed to `set_with_dataframe` \"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name ) # make sure it's really only the dataframe, not some residue self . clear_gsheet ( spreadsheet_id , worksheet_name ) try : set_with_dataframe ( worksheet , df , ** kwargs ) except APIError as error : self . _exception_feedback ( error ) HelpDeskClient ( config : Optional [ Config ] = None ) \u00b6 Source code in pytanis/helpdesk/client.py def __init__ ( self , config : Optional [ Config ] = None ): if config is None : config = get_cfg () self . _config = config # Important: Always use a custom User-Agent, never a generic one. # Generic User-Agents are filtered by helpdesk to reduce spam. self . _headers = { \"User-Agent\" : \"Pytanis\" } self . _get_throttled = self . _get self . _post_throttled = self . _post self . set_throttling ( 2 , 1 ) # we are nice by default create_ticket ( ticket : NewTicket ) \u00b6 Source code in pytanis/helpdesk/client.py def create_ticket ( self , ticket : NewTicket ): return self . post ( \"tickets\" , data = ticket . dict ()) get ( endpoint : str , params : Optional [ Dict [ str , str ]] = None ) -> JSON \u00b6 Retrieve data via throttled GET request and return the JSON Source code in pytanis/helpdesk/client.py def get ( self , endpoint : str , params : Optional [ Dict [ str , str ]] = None ) -> JSON : \"\"\"Retrieve data via throttled GET request and return the JSON\"\"\" resp = self . _get_throttled ( endpoint , params ) resp . raise_for_status () return resp . json () list_agents () -> List [ Agent ] \u00b6 Source code in pytanis/helpdesk/client.py def list_agents ( self ) -> List [ Agent ]: agents = self . get ( \"agents\" ) assert isinstance ( agents , List ) return [ Agent . parse_obj ( dct ) for dct in agents ] list_teams () -> List [ Team ] \u00b6 Source code in pytanis/helpdesk/client.py def list_teams ( self ) -> List [ Team ]: teams = self . get ( \"teams\" ) assert isinstance ( teams , List ) return [ Team . parse_obj ( dct ) for dct in teams ] post ( endpoint : str , data : Dict [ str , Any ], params : Optional [ Dict [ str , str ]] = None ) -> JSON \u00b6 Source code in pytanis/helpdesk/client.py def post ( self , endpoint : str , data : Dict [ str , Any ], params : Optional [ Dict [ str , str ]] = None ) -> JSON : resp = self . _post_throttled ( endpoint , data , params ) resp . raise_for_status () return resp . json () set_throttling ( calls : int , seconds : int ) \u00b6 Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/helpdesk/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . debug ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get ) self . _post_throttled = throttle ( calls , seconds )( self . _post ) PretalxClient ( config : Optional [ Config ] = None , blocking : bool = False ) \u00b6 Client for the Pretalx API Source code in pytanis/pretalx/client.py def __init__ ( self , config : Optional [ Config ] = None , blocking : bool = False ): if config is None : config = get_cfg () self . _config = config self . _get_throttled = self . _get self . blocking = blocking self . set_throttling ( 1 , 2 ) # we are nice by default blocking = blocking instance-attribute \u00b6 answer ( event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Answer \u00b6 Returns a specific answer Source code in pytanis/pretalx/client.py def answer ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Answer : \"\"\"Returns a specific answer\"\"\" return self . _endpoint_id ( Answer , event_slug , \"answers\" , id , params = params ) answers ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Answer ]] \u00b6 Lists all answers and their details Source code in pytanis/pretalx/client.py def answers ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Answer ]]: \"\"\"Lists all answers and their details\"\"\" return self . _endpoint_lst ( Answer , event_slug , \"answers\" , params = params ) event ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Event \u00b6 Returns detailed information about a specific event Source code in pytanis/pretalx/client.py def event ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Event : \"\"\"Returns detailed information about a specific event\"\"\" endpoint = f \"/api/events/ { event_slug } /\" result = self . _get_one ( endpoint , params ) _logger . debug ( \"result\" , resp = result ) return Event . parse_obj ( result ) events ( * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Event ]] \u00b6 Lists all events and their details Source code in pytanis/pretalx/client.py def events ( self , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Event ]]: \"\"\"Lists all events and their details\"\"\" count , results = self . _get_many ( \"/api/events/\" , params ) events = iter ( _logger . debug ( \"result\" , resp = r ) or Event . parse_obj ( r ) for r in results ) return count , events me () -> Me \u00b6 Returns what Pretalx knows about myself Source code in pytanis/pretalx/client.py def me ( self ) -> Me : \"\"\"Returns what Pretalx knows about myself\"\"\" result = self . _get_one ( \"/api/me\" ) return Me . parse_obj ( result ) question ( event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Question \u00b6 Returns a specific question Source code in pytanis/pretalx/client.py def question ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Question : \"\"\"Returns a specific question\"\"\" return self . _endpoint_id ( Question , event_slug , \"questions\" , id , params = params ) questions ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Question ]] \u00b6 Lists all questions and their details Source code in pytanis/pretalx/client.py def questions ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Question ]]: \"\"\"Lists all questions and their details\"\"\" return self . _endpoint_lst ( Question , event_slug , \"questions\" , params = params ) review ( event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Review \u00b6 Returns a specific review Source code in pytanis/pretalx/client.py def review ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Review : \"\"\"Returns a specific review\"\"\" return self . _endpoint_id ( Review , event_slug , \"reviews\" , id , params = params ) reviews ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Review ]] \u00b6 Lists all reviews and their details Source code in pytanis/pretalx/client.py def reviews ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Review ]]: \"\"\"Lists all reviews and their details\"\"\" return self . _endpoint_lst ( Review , event_slug , \"reviews\" , params = params ) room ( event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Room \u00b6 Returns a specific room Source code in pytanis/pretalx/client.py def room ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Room : \"\"\"Returns a specific room\"\"\" return self . _endpoint_id ( Room , event_slug , \"rooms\" , id , params = params ) rooms ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Room ]] \u00b6 Lists all rooms and their details Source code in pytanis/pretalx/client.py def rooms ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Room ]]: \"\"\"Lists all rooms and their details\"\"\" return self . _endpoint_lst ( Room , event_slug , \"rooms\" , params = params ) set_throttling ( calls : int , seconds : int ) \u00b6 Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/pretalx/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . debug ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get ) speaker ( event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Speaker \u00b6 Returns a specific speaker Source code in pytanis/pretalx/client.py def speaker ( self , event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Speaker : \"\"\"Returns a specific speaker\"\"\" return self . _endpoint_id ( Speaker , event_slug , \"speakers\" , code , params = params ) speakers ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Speaker ]] \u00b6 Lists all speakers and their details Source code in pytanis/pretalx/client.py def speakers ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Speaker ]]: \"\"\"Lists all speakers and their details\"\"\" return self . _endpoint_lst ( Speaker , event_slug , \"speakers\" , params = params ) submission ( event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Submission \u00b6 Returns a specific submission Source code in pytanis/pretalx/client.py def submission ( self , event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Submission : \"\"\"Returns a specific submission\"\"\" return self . _endpoint_id ( Submission , event_slug , \"submissions\" , code , params = params ) submissions ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Submission ]] \u00b6 Lists all submissions and their details Source code in pytanis/pretalx/client.py def submissions ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Submission ]]: \"\"\"Lists all submissions and their details\"\"\" return self . _endpoint_lst ( Submission , event_slug , \"submissions\" , params = params ) tag ( event_slug : str , tag : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tag \u00b6 Returns a specific tag Source code in pytanis/pretalx/client.py def tag ( self , event_slug : str , tag : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tag : \"\"\"Returns a specific tag\"\"\" return self . _endpoint_id ( Tag , event_slug , \"tags\" , tag , params = params ) tags ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Tag ]] \u00b6 Lists all tags and their details Source code in pytanis/pretalx/client.py def tags ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Tag ]]: \"\"\"Lists all tags and their details\"\"\" return self . _endpoint_lst ( Tag , event_slug , \"tags\" , params = params ) talk ( event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Talk \u00b6 Returns a specific talk Source code in pytanis/pretalx/client.py def talk ( self , event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Talk : \"\"\"Returns a specific talk\"\"\" return self . _endpoint_id ( Talk , event_slug , \"talks\" , code , params = params ) talks ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Talk ]] \u00b6 Lists all talks and their details Source code in pytanis/pretalx/client.py def talks ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Talk ]]: \"\"\"Lists all talks and their details\"\"\" return self . _endpoint_lst ( Talk , event_slug , \"talks\" , params = params )","title":"pytanis"},{"location":"reference/pytanis/#pytanis","text":"","title":"pytanis"},{"location":"reference/pytanis/#pytanis.__all__","text":"","title":"__all__"},{"location":"reference/pytanis/#pytanis.__version__","text":"","title":"__version__"},{"location":"reference/pytanis/#pytanis.GSheetClient","text":"Google API to easily handle GSheets and other files on GDrive By default, only the least permissive scope GSHEET_RO in case of read_only = True is used. Source code in pytanis/google.py def __init__ ( self , config : Optional [ Config ] = None , read_only : bool = True ): self . _read_only = read_only if read_only : self . _scopes = [ Scope . GSHEET_RO ] else : self . _scopes = [ Scope . GSHEET_RW ] if config is None : config = get_cfg () self . _config = config self . gc = gspread_client ( self . _scopes , config ) # gspread client for more functionality","title":"GSheetClient"},{"location":"reference/pytanis/#pytanis.google.GSheetClient.gc","text":"","title":"gc"},{"location":"reference/pytanis/#pytanis.google.GSheetClient.clear_gsheet","text":"Clear the worksheet including values, formatting, filtering, etc. Source code in pytanis/google.py def clear_gsheet ( self , spreadsheet_id : str , worksheet_name : str ): \"\"\"Clear the worksheet including values, formatting, filtering, etc.\"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name ) default_fmt = get_default_format ( worksheet . spreadsheet ) range = worksheet_range ( worksheet ) try : worksheet . clear () worksheet . clear_basic_filter () format_cell_range ( worksheet , range , default_fmt ) rules = get_conditional_format_rules ( worksheet ) rules . clear () rules . save () set_data_validation_for_cell_range ( worksheet , range , None ) except APIError as error : self . _exception_feedback ( error )","title":"clear_gsheet()"},{"location":"reference/pytanis/#pytanis.google.GSheetClient.gsheet","text":"Retrieve a Google sheet by its id and the name Open a Google sheet in your browser and check the URL to retrieve the id, e.g.: https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit ... If the spreadsheet as several worksheets (check the lower bar) then worksheet_name can be used to specify a specific one. Source code in pytanis/google.py def gsheet ( self , spreadsheet_id : str , worksheet_name : Optional [ str ] = None ) -> Union [ Worksheet , Spreadsheet ]: \"\"\"Retrieve a Google sheet by its id and the name Open a Google sheet in your browser and check the URL to retrieve the id, e.g.: https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit... If the spreadsheet as several worksheets (check the lower bar) then `worksheet_name` can be used to specify a specific one. \"\"\" spreadsheet = self . gc . open_by_key ( spreadsheet_id ) if worksheet_name is None : return spreadsheet else : worksheet = spreadsheet . worksheet ( worksheet_name ) return worksheet","title":"gsheet()"},{"location":"reference/pytanis/#pytanis.google.GSheetClient.gsheet_as_df","text":"Returns a worksheet as dataframe Source code in pytanis/google.py def gsheet_as_df ( self , spreadsheet_id : str , worksheet_name : str , ** kwargs : Union [ str , bool , int ]) -> pd . DataFrame : \"\"\"Returns a worksheet as dataframe\"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name ) df = get_as_dataframe ( worksheet , ** kwargs ) # remove Nan rows & columns as they are exported by default df . dropna ( how = 'all' , inplace = True , axis = 0 ) df . dropna ( how = 'all' , inplace = True , axis = 1 ) return df","title":"gsheet_as_df()"},{"location":"reference/pytanis/#pytanis.google.GSheetClient.recreate_token","text":"Recreate the current token using the scopes given at initialization Source code in pytanis/google.py def recreate_token ( self ): \"\"\"Recreate the current token using the scopes given at initialization\"\"\" self . _config . Google . token_json . unlink ( missing_ok = True ) self . gc = gspread_client ( self . _scopes , self . _config )","title":"recreate_token()"},{"location":"reference/pytanis/#pytanis.google.GSheetClient.save_df_as_gsheet","text":"Save the given dataframe as worksheet in a spreadsheet Make sure that the scope passed gives you write permissions Parameters: Name Type Description Default df pd . DataFrame dataframe to save required spreadsheet_id str id of the Google spreadsheet required worksheet_name str name of the worksheet within the spreadsheet required **kwargs Union [ str , bool , int ] extra keyword arguments passed to set_with_dataframe {} Source code in pytanis/google.py def save_df_as_gsheet ( self , df : pd . DataFrame , spreadsheet_id : str , worksheet_name : str , ** kwargs : Union [ str , bool , int ] ): \"\"\"Save the given dataframe as worksheet in a spreadsheet Make sure that the scope passed gives you write permissions Args: df: dataframe to save spreadsheet_id: id of the Google spreadsheet worksheet_name: name of the worksheet within the spreadsheet **kwargs: extra keyword arguments passed to `set_with_dataframe` \"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name ) # make sure it's really only the dataframe, not some residue self . clear_gsheet ( spreadsheet_id , worksheet_name ) try : set_with_dataframe ( worksheet , df , ** kwargs ) except APIError as error : self . _exception_feedback ( error )","title":"save_df_as_gsheet()"},{"location":"reference/pytanis/#pytanis.HelpDeskClient","text":"Source code in pytanis/helpdesk/client.py def __init__ ( self , config : Optional [ Config ] = None ): if config is None : config = get_cfg () self . _config = config # Important: Always use a custom User-Agent, never a generic one. # Generic User-Agents are filtered by helpdesk to reduce spam. self . _headers = { \"User-Agent\" : \"Pytanis\" } self . _get_throttled = self . _get self . _post_throttled = self . _post self . set_throttling ( 2 , 1 ) # we are nice by default","title":"HelpDeskClient"},{"location":"reference/pytanis/#pytanis.helpdesk.client.HelpDeskClient.create_ticket","text":"Source code in pytanis/helpdesk/client.py def create_ticket ( self , ticket : NewTicket ): return self . post ( \"tickets\" , data = ticket . dict ())","title":"create_ticket()"},{"location":"reference/pytanis/#pytanis.helpdesk.client.HelpDeskClient.get","text":"Retrieve data via throttled GET request and return the JSON Source code in pytanis/helpdesk/client.py def get ( self , endpoint : str , params : Optional [ Dict [ str , str ]] = None ) -> JSON : \"\"\"Retrieve data via throttled GET request and return the JSON\"\"\" resp = self . _get_throttled ( endpoint , params ) resp . raise_for_status () return resp . json ()","title":"get()"},{"location":"reference/pytanis/#pytanis.helpdesk.client.HelpDeskClient.list_agents","text":"Source code in pytanis/helpdesk/client.py def list_agents ( self ) -> List [ Agent ]: agents = self . get ( \"agents\" ) assert isinstance ( agents , List ) return [ Agent . parse_obj ( dct ) for dct in agents ]","title":"list_agents()"},{"location":"reference/pytanis/#pytanis.helpdesk.client.HelpDeskClient.list_teams","text":"Source code in pytanis/helpdesk/client.py def list_teams ( self ) -> List [ Team ]: teams = self . get ( \"teams\" ) assert isinstance ( teams , List ) return [ Team . parse_obj ( dct ) for dct in teams ]","title":"list_teams()"},{"location":"reference/pytanis/#pytanis.helpdesk.client.HelpDeskClient.post","text":"Source code in pytanis/helpdesk/client.py def post ( self , endpoint : str , data : Dict [ str , Any ], params : Optional [ Dict [ str , str ]] = None ) -> JSON : resp = self . _post_throttled ( endpoint , data , params ) resp . raise_for_status () return resp . json ()","title":"post()"},{"location":"reference/pytanis/#pytanis.helpdesk.client.HelpDeskClient.set_throttling","text":"Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/helpdesk/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . debug ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get ) self . _post_throttled = throttle ( calls , seconds )( self . _post )","title":"set_throttling()"},{"location":"reference/pytanis/#pytanis.PretalxClient","text":"Client for the Pretalx API Source code in pytanis/pretalx/client.py def __init__ ( self , config : Optional [ Config ] = None , blocking : bool = False ): if config is None : config = get_cfg () self . _config = config self . _get_throttled = self . _get self . blocking = blocking self . set_throttling ( 1 , 2 ) # we are nice by default","title":"PretalxClient"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.blocking","text":"","title":"blocking"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.answer","text":"Returns a specific answer Source code in pytanis/pretalx/client.py def answer ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Answer : \"\"\"Returns a specific answer\"\"\" return self . _endpoint_id ( Answer , event_slug , \"answers\" , id , params = params )","title":"answer()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.answers","text":"Lists all answers and their details Source code in pytanis/pretalx/client.py def answers ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Answer ]]: \"\"\"Lists all answers and their details\"\"\" return self . _endpoint_lst ( Answer , event_slug , \"answers\" , params = params )","title":"answers()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.event","text":"Returns detailed information about a specific event Source code in pytanis/pretalx/client.py def event ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Event : \"\"\"Returns detailed information about a specific event\"\"\" endpoint = f \"/api/events/ { event_slug } /\" result = self . _get_one ( endpoint , params ) _logger . debug ( \"result\" , resp = result ) return Event . parse_obj ( result )","title":"event()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.events","text":"Lists all events and their details Source code in pytanis/pretalx/client.py def events ( self , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Event ]]: \"\"\"Lists all events and their details\"\"\" count , results = self . _get_many ( \"/api/events/\" , params ) events = iter ( _logger . debug ( \"result\" , resp = r ) or Event . parse_obj ( r ) for r in results ) return count , events","title":"events()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.me","text":"Returns what Pretalx knows about myself Source code in pytanis/pretalx/client.py def me ( self ) -> Me : \"\"\"Returns what Pretalx knows about myself\"\"\" result = self . _get_one ( \"/api/me\" ) return Me . parse_obj ( result )","title":"me()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.question","text":"Returns a specific question Source code in pytanis/pretalx/client.py def question ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Question : \"\"\"Returns a specific question\"\"\" return self . _endpoint_id ( Question , event_slug , \"questions\" , id , params = params )","title":"question()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.questions","text":"Lists all questions and their details Source code in pytanis/pretalx/client.py def questions ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Question ]]: \"\"\"Lists all questions and their details\"\"\" return self . _endpoint_lst ( Question , event_slug , \"questions\" , params = params )","title":"questions()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.review","text":"Returns a specific review Source code in pytanis/pretalx/client.py def review ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Review : \"\"\"Returns a specific review\"\"\" return self . _endpoint_id ( Review , event_slug , \"reviews\" , id , params = params )","title":"review()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.reviews","text":"Lists all reviews and their details Source code in pytanis/pretalx/client.py def reviews ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Review ]]: \"\"\"Lists all reviews and their details\"\"\" return self . _endpoint_lst ( Review , event_slug , \"reviews\" , params = params )","title":"reviews()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.room","text":"Returns a specific room Source code in pytanis/pretalx/client.py def room ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Room : \"\"\"Returns a specific room\"\"\" return self . _endpoint_id ( Room , event_slug , \"rooms\" , id , params = params )","title":"room()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.rooms","text":"Lists all rooms and their details Source code in pytanis/pretalx/client.py def rooms ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Room ]]: \"\"\"Lists all rooms and their details\"\"\" return self . _endpoint_lst ( Room , event_slug , \"rooms\" , params = params )","title":"rooms()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.set_throttling","text":"Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/pretalx/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . debug ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get )","title":"set_throttling()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.speaker","text":"Returns a specific speaker Source code in pytanis/pretalx/client.py def speaker ( self , event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Speaker : \"\"\"Returns a specific speaker\"\"\" return self . _endpoint_id ( Speaker , event_slug , \"speakers\" , code , params = params )","title":"speaker()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.speakers","text":"Lists all speakers and their details Source code in pytanis/pretalx/client.py def speakers ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Speaker ]]: \"\"\"Lists all speakers and their details\"\"\" return self . _endpoint_lst ( Speaker , event_slug , \"speakers\" , params = params )","title":"speakers()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.submission","text":"Returns a specific submission Source code in pytanis/pretalx/client.py def submission ( self , event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Submission : \"\"\"Returns a specific submission\"\"\" return self . _endpoint_id ( Submission , event_slug , \"submissions\" , code , params = params )","title":"submission()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.submissions","text":"Lists all submissions and their details Source code in pytanis/pretalx/client.py def submissions ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Submission ]]: \"\"\"Lists all submissions and their details\"\"\" return self . _endpoint_lst ( Submission , event_slug , \"submissions\" , params = params )","title":"submissions()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.tag","text":"Returns a specific tag Source code in pytanis/pretalx/client.py def tag ( self , event_slug : str , tag : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tag : \"\"\"Returns a specific tag\"\"\" return self . _endpoint_id ( Tag , event_slug , \"tags\" , tag , params = params )","title":"tag()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.tags","text":"Lists all tags and their details Source code in pytanis/pretalx/client.py def tags ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Tag ]]: \"\"\"Lists all tags and their details\"\"\" return self . _endpoint_lst ( Tag , event_slug , \"tags\" , params = params )","title":"tags()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.talk","text":"Returns a specific talk Source code in pytanis/pretalx/client.py def talk ( self , event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Talk : \"\"\"Returns a specific talk\"\"\" return self . _endpoint_id ( Talk , event_slug , \"talks\" , code , params = params )","title":"talk()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.talks","text":"Lists all talks and their details Source code in pytanis/pretalx/client.py def talks ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Talk ]]: \"\"\"Lists all talks and their details\"\"\" return self . _endpoint_lst ( Talk , event_slug , \"talks\" , params = params )","title":"talks()"},{"location":"reference/pytanis/config/","text":"config \u00b6 Handling the configuration PYTANIS_CFG_PATH : str = '.pytanis/config.toml' module-attribute \u00b6 Path within $HOME to the configuration file of Pytanis PYTANIS_ENV : str = 'PYTANIS_CONFIG' module-attribute \u00b6 Name of the environment variable to look up the path for the config Config \u00b6 Main configuration object Google : Google class-attribute \u00b6 HelpDesk : HelpDesk class-attribute \u00b6 Pretalx : Pretalx class-attribute \u00b6 cfg_path : FilePath class-attribute \u00b6 convert_json_path ( v , values ) classmethod \u00b6 Source code in pytanis/config.py @validator ( \"Google\" ) @classmethod def convert_json_path ( cls , v , values ): def make_rel_path_abs ( entry ): if entry is not None and not entry . is_absolute (): entry = values [ \"cfg_path\" ] . parent / entry return entry v . client_secret_json = make_rel_path_abs ( v . client_secret_json ) v . token_json = make_rel_path_abs ( v . token_json ) return v Google \u00b6 Configuration related to the Google API client_secret_json : Optional [ Path ] class-attribute \u00b6 token_json : Optional [ Path ] class-attribute \u00b6 HelpDesk \u00b6 Configuration related to the HelpDesk API account : Optional [ str ] class-attribute \u00b6 entity_id : Optional [ str ] class-attribute \u00b6 token : Optional [ str ] class-attribute \u00b6 Pretalx \u00b6 Configuration related to the Pretalx API api_token : Optional [ str ] class-attribute \u00b6 get_cfg () -> Config \u00b6 Returns the configuration as an object Source code in pytanis/config.py def get_cfg () -> Config : \"\"\"Returns the configuration as an object\"\"\" cfg_path = get_cfg_file () with open ( cfg_path , \"rb\" ) as fh : cfg_dict = tomli . load ( fh ) # add config path to later resolve relative paths of config values cfg_dict [ \"cfg_path\" ] = cfg_path return Config . parse_obj ( cfg_dict ) get_cfg_file () -> Path \u00b6 Determines the path of the config file Source code in pytanis/config.py def get_cfg_file () -> Path : \"\"\"Determines the path of the config file\"\"\" path_str = os . environ . get ( PYTANIS_ENV , None ) if path_str is None : path = Path . home () / Path ( PYTANIS_CFG_PATH ) else : path = Path ( path_str ) return path","title":"config"},{"location":"reference/pytanis/config/#pytanis.config","text":"Handling the configuration","title":"config"},{"location":"reference/pytanis/config/#pytanis.config.PYTANIS_CFG_PATH","text":"Path within $HOME to the configuration file of Pytanis","title":"PYTANIS_CFG_PATH"},{"location":"reference/pytanis/config/#pytanis.config.PYTANIS_ENV","text":"Name of the environment variable to look up the path for the config","title":"PYTANIS_ENV"},{"location":"reference/pytanis/config/#pytanis.config.Config","text":"Main configuration object","title":"Config"},{"location":"reference/pytanis/config/#pytanis.config.Config.Google","text":"","title":"Google"},{"location":"reference/pytanis/config/#pytanis.config.Config.HelpDesk","text":"","title":"HelpDesk"},{"location":"reference/pytanis/config/#pytanis.config.Config.Pretalx","text":"","title":"Pretalx"},{"location":"reference/pytanis/config/#pytanis.config.Config.cfg_path","text":"","title":"cfg_path"},{"location":"reference/pytanis/config/#pytanis.config.Config.convert_json_path","text":"Source code in pytanis/config.py @validator ( \"Google\" ) @classmethod def convert_json_path ( cls , v , values ): def make_rel_path_abs ( entry ): if entry is not None and not entry . is_absolute (): entry = values [ \"cfg_path\" ] . parent / entry return entry v . client_secret_json = make_rel_path_abs ( v . client_secret_json ) v . token_json = make_rel_path_abs ( v . token_json ) return v","title":"convert_json_path()"},{"location":"reference/pytanis/config/#pytanis.config.Google","text":"Configuration related to the Google API","title":"Google"},{"location":"reference/pytanis/config/#pytanis.config.Google.client_secret_json","text":"","title":"client_secret_json"},{"location":"reference/pytanis/config/#pytanis.config.Google.token_json","text":"","title":"token_json"},{"location":"reference/pytanis/config/#pytanis.config.HelpDesk","text":"Configuration related to the HelpDesk API","title":"HelpDesk"},{"location":"reference/pytanis/config/#pytanis.config.HelpDesk.account","text":"","title":"account"},{"location":"reference/pytanis/config/#pytanis.config.HelpDesk.entity_id","text":"","title":"entity_id"},{"location":"reference/pytanis/config/#pytanis.config.HelpDesk.token","text":"","title":"token"},{"location":"reference/pytanis/config/#pytanis.config.Pretalx","text":"Configuration related to the Pretalx API","title":"Pretalx"},{"location":"reference/pytanis/config/#pytanis.config.Pretalx.api_token","text":"","title":"api_token"},{"location":"reference/pytanis/config/#pytanis.config.get_cfg","text":"Returns the configuration as an object Source code in pytanis/config.py def get_cfg () -> Config : \"\"\"Returns the configuration as an object\"\"\" cfg_path = get_cfg_file () with open ( cfg_path , \"rb\" ) as fh : cfg_dict = tomli . load ( fh ) # add config path to later resolve relative paths of config values cfg_dict [ \"cfg_path\" ] = cfg_path return Config . parse_obj ( cfg_dict )","title":"get_cfg()"},{"location":"reference/pytanis/config/#pytanis.config.get_cfg_file","text":"Determines the path of the config file Source code in pytanis/config.py def get_cfg_file () -> Path : \"\"\"Determines the path of the config file\"\"\" path_str = os . environ . get ( PYTANIS_ENV , None ) if path_str is None : path = Path . home () / Path ( PYTANIS_CFG_PATH ) else : path = Path ( path_str ) return path","title":"get_cfg_file()"},{"location":"reference/pytanis/google/","text":"google \u00b6 Functionality around the Google API Documentation Google GSheet API GSpread GSpread-Dataframe __all__ = [ 'GSheetClient' , 'gsheet_rows_for_fmt' , 'PermissionDeniedException' ] module-attribute \u00b6 GSheetClient ( config : Optional [ Config ] = None , read_only : bool = True ) \u00b6 Google API to easily handle GSheets and other files on GDrive By default, only the least permissive scope GSHEET_RO in case of read_only = True is used. Source code in pytanis/google.py def __init__ ( self , config : Optional [ Config ] = None , read_only : bool = True ): self . _read_only = read_only if read_only : self . _scopes = [ Scope . GSHEET_RO ] else : self . _scopes = [ Scope . GSHEET_RW ] if config is None : config = get_cfg () self . _config = config self . gc = gspread_client ( self . _scopes , config ) # gspread client for more functionality gc = gspread_client ( self . _scopes , config ) instance-attribute \u00b6 clear_gsheet ( spreadsheet_id : str , worksheet_name : str ) \u00b6 Clear the worksheet including values, formatting, filtering, etc. Source code in pytanis/google.py def clear_gsheet ( self , spreadsheet_id : str , worksheet_name : str ): \"\"\"Clear the worksheet including values, formatting, filtering, etc.\"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name ) default_fmt = get_default_format ( worksheet . spreadsheet ) range = worksheet_range ( worksheet ) try : worksheet . clear () worksheet . clear_basic_filter () format_cell_range ( worksheet , range , default_fmt ) rules = get_conditional_format_rules ( worksheet ) rules . clear () rules . save () set_data_validation_for_cell_range ( worksheet , range , None ) except APIError as error : self . _exception_feedback ( error ) gsheet ( spreadsheet_id : str , worksheet_name : Optional [ str ] = None ) -> Union [ Worksheet , Spreadsheet ] \u00b6 Retrieve a Google sheet by its id and the name Open a Google sheet in your browser and check the URL to retrieve the id, e.g.: https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit ... If the spreadsheet as several worksheets (check the lower bar) then worksheet_name can be used to specify a specific one. Source code in pytanis/google.py def gsheet ( self , spreadsheet_id : str , worksheet_name : Optional [ str ] = None ) -> Union [ Worksheet , Spreadsheet ]: \"\"\"Retrieve a Google sheet by its id and the name Open a Google sheet in your browser and check the URL to retrieve the id, e.g.: https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit... If the spreadsheet as several worksheets (check the lower bar) then `worksheet_name` can be used to specify a specific one. \"\"\" spreadsheet = self . gc . open_by_key ( spreadsheet_id ) if worksheet_name is None : return spreadsheet else : worksheet = spreadsheet . worksheet ( worksheet_name ) return worksheet gsheet_as_df ( spreadsheet_id : str , worksheet_name : str , kwargs : Union [ str , bool , int ]) -> pd . DataFrame \u00b6 Returns a worksheet as dataframe Source code in pytanis/google.py def gsheet_as_df ( self , spreadsheet_id : str , worksheet_name : str , ** kwargs : Union [ str , bool , int ]) -> pd . DataFrame : \"\"\"Returns a worksheet as dataframe\"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name ) df = get_as_dataframe ( worksheet , ** kwargs ) # remove Nan rows & columns as they are exported by default df . dropna ( how = 'all' , inplace = True , axis = 0 ) df . dropna ( how = 'all' , inplace = True , axis = 1 ) return df recreate_token () \u00b6 Recreate the current token using the scopes given at initialization Source code in pytanis/google.py def recreate_token ( self ): \"\"\"Recreate the current token using the scopes given at initialization\"\"\" self . _config . Google . token_json . unlink ( missing_ok = True ) self . gc = gspread_client ( self . _scopes , self . _config ) save_df_as_gsheet ( df : pd . DataFrame , spreadsheet_id : str , worksheet_name : str , kwargs : Union [ str , bool , int ]) \u00b6 Save the given dataframe as worksheet in a spreadsheet Make sure that the scope passed gives you write permissions Parameters: Name Type Description Default df pd . DataFrame dataframe to save required spreadsheet_id str id of the Google spreadsheet required worksheet_name str name of the worksheet within the spreadsheet required **kwargs Union [ str , bool , int ] extra keyword arguments passed to set_with_dataframe {} Source code in pytanis/google.py def save_df_as_gsheet ( self , df : pd . DataFrame , spreadsheet_id : str , worksheet_name : str , ** kwargs : Union [ str , bool , int ] ): \"\"\"Save the given dataframe as worksheet in a spreadsheet Make sure that the scope passed gives you write permissions Args: df: dataframe to save spreadsheet_id: id of the Google spreadsheet worksheet_name: name of the worksheet within the spreadsheet **kwargs: extra keyword arguments passed to `set_with_dataframe` \"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name ) # make sure it's really only the dataframe, not some residue self . clear_gsheet ( spreadsheet_id , worksheet_name ) try : set_with_dataframe ( worksheet , df , ** kwargs ) except APIError as error : self . _exception_feedback ( error ) PermissionDeniedException \u00b6 Exception for APIError with status PERMISSION_DENIED Most likely thrown in cases when the scope is not GSHEET_RW or the token needs to be updated accordingly. Scope \u00b6 GDRIVE_FILE = 'https://www.googleapis.com/auth/drive.file' class-attribute \u00b6 GDRIVE_RO = 'https://www.googleapis.com/auth/drive.readonly' class-attribute \u00b6 GDRIVE_RW = 'https://www.googleapis.com/auth/drive' class-attribute \u00b6 GSHEET_RO = 'https://www.googleapis.com/auth/spreadsheets.readonly' class-attribute \u00b6 GSHEET_RW = 'https://www.googleapis.com/auth/spreadsheets' class-attribute \u00b6 gsheet_col ( idx : int ) -> str \u00b6 Convert a column index to Google Sheet range notation, e.g. A, BE, etc. Source code in pytanis/google.py def gsheet_col ( idx : int ) -> str : \"\"\"Convert a column index to Google Sheet range notation, e.g. A, BE, etc.\"\"\" idx += 1 chars = [] while idx : chars . append ( string . ascii_uppercase [( idx % 26 ) - 1 ]) idx //= 27 return \"\" . join ( chars [:: - 1 ]) gsheet_rows_for_fmt ( df : pd . DataFrame , mask : pd . Series ) -> List [ str ] \u00b6 Get the Google Sheet row range specifications for formatting Source code in pytanis/google.py def gsheet_rows_for_fmt ( df : pd . DataFrame , mask : pd . Series ) -> List [ str ]: \"\"\"Get the Google Sheet row range specifications for formatting\"\"\" rows = pd . Series ( np . argwhere ( mask . to_numpy ()) . reshape ( - 1 ) + 2 ) # +2 since 1-index and header last_col = gsheet_col ( len ( df . columns ) - 1 ) # last index rows = rows . map ( lambda x : f \"A { x } : { last_col }{ x } \" ) return rows . to_list () gspread_client ( scopes : List [ Scope ], config : Config ) -> gspread . client . Client \u00b6 Creates the GSheet client using our configuration Read GSpread for usage details Source code in pytanis/google.py def gspread_client ( scopes : List [ Scope ], config : Config ) -> gspread . client . Client : \"\"\"Creates the GSheet client using our configuration Read [GSpread](https://docs.gspread.org/) for usage details \"\"\" if ( secret_path := config . Google . client_secret_json ) is None : raise RuntimeError ( \"You have to set Google.client_secret_json in your config.toml!\" ) if ( token_path := config . Google . token_json ) is None : raise RuntimeError ( \"You have to set Google.token_json in your config.toml!\" ) gc = gspread . oauth ( scopes = [ scope . value for scope in scopes ], credentials_filename = str ( secret_path ), authorized_user_filename = str ( token_path ), ) return gc worksheet_range ( worksheet : Worksheet ) -> str \u00b6 Returns a range encompassing the whole worksheet Source code in pytanis/google.py def worksheet_range ( worksheet : Worksheet ) -> str : \"\"\"Returns a range encompassing the whole worksheet\"\"\" last_row = worksheet . row_count last_col = gsheet_col ( worksheet . col_count ) return f \"A1: { last_col }{ last_row } \"","title":"google"},{"location":"reference/pytanis/google/#pytanis.google","text":"Functionality around the Google API Documentation Google GSheet API GSpread GSpread-Dataframe","title":"google"},{"location":"reference/pytanis/google/#pytanis.google.__all__","text":"","title":"__all__"},{"location":"reference/pytanis/google/#pytanis.google.GSheetClient","text":"Google API to easily handle GSheets and other files on GDrive By default, only the least permissive scope GSHEET_RO in case of read_only = True is used. Source code in pytanis/google.py def __init__ ( self , config : Optional [ Config ] = None , read_only : bool = True ): self . _read_only = read_only if read_only : self . _scopes = [ Scope . GSHEET_RO ] else : self . _scopes = [ Scope . GSHEET_RW ] if config is None : config = get_cfg () self . _config = config self . gc = gspread_client ( self . _scopes , config ) # gspread client for more functionality","title":"GSheetClient"},{"location":"reference/pytanis/google/#pytanis.google.GSheetClient.gc","text":"","title":"gc"},{"location":"reference/pytanis/google/#pytanis.google.GSheetClient.clear_gsheet","text":"Clear the worksheet including values, formatting, filtering, etc. Source code in pytanis/google.py def clear_gsheet ( self , spreadsheet_id : str , worksheet_name : str ): \"\"\"Clear the worksheet including values, formatting, filtering, etc.\"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name ) default_fmt = get_default_format ( worksheet . spreadsheet ) range = worksheet_range ( worksheet ) try : worksheet . clear () worksheet . clear_basic_filter () format_cell_range ( worksheet , range , default_fmt ) rules = get_conditional_format_rules ( worksheet ) rules . clear () rules . save () set_data_validation_for_cell_range ( worksheet , range , None ) except APIError as error : self . _exception_feedback ( error )","title":"clear_gsheet()"},{"location":"reference/pytanis/google/#pytanis.google.GSheetClient.gsheet","text":"Retrieve a Google sheet by its id and the name Open a Google sheet in your browser and check the URL to retrieve the id, e.g.: https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit ... If the spreadsheet as several worksheets (check the lower bar) then worksheet_name can be used to specify a specific one. Source code in pytanis/google.py def gsheet ( self , spreadsheet_id : str , worksheet_name : Optional [ str ] = None ) -> Union [ Worksheet , Spreadsheet ]: \"\"\"Retrieve a Google sheet by its id and the name Open a Google sheet in your browser and check the URL to retrieve the id, e.g.: https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit... If the spreadsheet as several worksheets (check the lower bar) then `worksheet_name` can be used to specify a specific one. \"\"\" spreadsheet = self . gc . open_by_key ( spreadsheet_id ) if worksheet_name is None : return spreadsheet else : worksheet = spreadsheet . worksheet ( worksheet_name ) return worksheet","title":"gsheet()"},{"location":"reference/pytanis/google/#pytanis.google.GSheetClient.gsheet_as_df","text":"Returns a worksheet as dataframe Source code in pytanis/google.py def gsheet_as_df ( self , spreadsheet_id : str , worksheet_name : str , ** kwargs : Union [ str , bool , int ]) -> pd . DataFrame : \"\"\"Returns a worksheet as dataframe\"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name ) df = get_as_dataframe ( worksheet , ** kwargs ) # remove Nan rows & columns as they are exported by default df . dropna ( how = 'all' , inplace = True , axis = 0 ) df . dropna ( how = 'all' , inplace = True , axis = 1 ) return df","title":"gsheet_as_df()"},{"location":"reference/pytanis/google/#pytanis.google.GSheetClient.recreate_token","text":"Recreate the current token using the scopes given at initialization Source code in pytanis/google.py def recreate_token ( self ): \"\"\"Recreate the current token using the scopes given at initialization\"\"\" self . _config . Google . token_json . unlink ( missing_ok = True ) self . gc = gspread_client ( self . _scopes , self . _config )","title":"recreate_token()"},{"location":"reference/pytanis/google/#pytanis.google.GSheetClient.save_df_as_gsheet","text":"Save the given dataframe as worksheet in a spreadsheet Make sure that the scope passed gives you write permissions Parameters: Name Type Description Default df pd . DataFrame dataframe to save required spreadsheet_id str id of the Google spreadsheet required worksheet_name str name of the worksheet within the spreadsheet required **kwargs Union [ str , bool , int ] extra keyword arguments passed to set_with_dataframe {} Source code in pytanis/google.py def save_df_as_gsheet ( self , df : pd . DataFrame , spreadsheet_id : str , worksheet_name : str , ** kwargs : Union [ str , bool , int ] ): \"\"\"Save the given dataframe as worksheet in a spreadsheet Make sure that the scope passed gives you write permissions Args: df: dataframe to save spreadsheet_id: id of the Google spreadsheet worksheet_name: name of the worksheet within the spreadsheet **kwargs: extra keyword arguments passed to `set_with_dataframe` \"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name ) # make sure it's really only the dataframe, not some residue self . clear_gsheet ( spreadsheet_id , worksheet_name ) try : set_with_dataframe ( worksheet , df , ** kwargs ) except APIError as error : self . _exception_feedback ( error )","title":"save_df_as_gsheet()"},{"location":"reference/pytanis/google/#pytanis.google.PermissionDeniedException","text":"Exception for APIError with status PERMISSION_DENIED Most likely thrown in cases when the scope is not GSHEET_RW or the token needs to be updated accordingly.","title":"PermissionDeniedException"},{"location":"reference/pytanis/google/#pytanis.google.Scope","text":"","title":"Scope"},{"location":"reference/pytanis/google/#pytanis.google.Scope.GDRIVE_FILE","text":"","title":"GDRIVE_FILE"},{"location":"reference/pytanis/google/#pytanis.google.Scope.GDRIVE_RO","text":"","title":"GDRIVE_RO"},{"location":"reference/pytanis/google/#pytanis.google.Scope.GDRIVE_RW","text":"","title":"GDRIVE_RW"},{"location":"reference/pytanis/google/#pytanis.google.Scope.GSHEET_RO","text":"","title":"GSHEET_RO"},{"location":"reference/pytanis/google/#pytanis.google.Scope.GSHEET_RW","text":"","title":"GSHEET_RW"},{"location":"reference/pytanis/google/#pytanis.google.gsheet_col","text":"Convert a column index to Google Sheet range notation, e.g. A, BE, etc. Source code in pytanis/google.py def gsheet_col ( idx : int ) -> str : \"\"\"Convert a column index to Google Sheet range notation, e.g. A, BE, etc.\"\"\" idx += 1 chars = [] while idx : chars . append ( string . ascii_uppercase [( idx % 26 ) - 1 ]) idx //= 27 return \"\" . join ( chars [:: - 1 ])","title":"gsheet_col()"},{"location":"reference/pytanis/google/#pytanis.google.gsheet_rows_for_fmt","text":"Get the Google Sheet row range specifications for formatting Source code in pytanis/google.py def gsheet_rows_for_fmt ( df : pd . DataFrame , mask : pd . Series ) -> List [ str ]: \"\"\"Get the Google Sheet row range specifications for formatting\"\"\" rows = pd . Series ( np . argwhere ( mask . to_numpy ()) . reshape ( - 1 ) + 2 ) # +2 since 1-index and header last_col = gsheet_col ( len ( df . columns ) - 1 ) # last index rows = rows . map ( lambda x : f \"A { x } : { last_col }{ x } \" ) return rows . to_list ()","title":"gsheet_rows_for_fmt()"},{"location":"reference/pytanis/google/#pytanis.google.gspread_client","text":"Creates the GSheet client using our configuration Read GSpread for usage details Source code in pytanis/google.py def gspread_client ( scopes : List [ Scope ], config : Config ) -> gspread . client . Client : \"\"\"Creates the GSheet client using our configuration Read [GSpread](https://docs.gspread.org/) for usage details \"\"\" if ( secret_path := config . Google . client_secret_json ) is None : raise RuntimeError ( \"You have to set Google.client_secret_json in your config.toml!\" ) if ( token_path := config . Google . token_json ) is None : raise RuntimeError ( \"You have to set Google.token_json in your config.toml!\" ) gc = gspread . oauth ( scopes = [ scope . value for scope in scopes ], credentials_filename = str ( secret_path ), authorized_user_filename = str ( token_path ), ) return gc","title":"gspread_client()"},{"location":"reference/pytanis/google/#pytanis.google.worksheet_range","text":"Returns a range encompassing the whole worksheet Source code in pytanis/google.py def worksheet_range ( worksheet : Worksheet ) -> str : \"\"\"Returns a range encompassing the whole worksheet\"\"\" last_row = worksheet . row_count last_col = gsheet_col ( worksheet . col_count ) return f \"A1: { last_col }{ last_row } \"","title":"worksheet_range()"},{"location":"reference/pytanis/review/","text":"review \u00b6 Tools related to assigning proposals to reviewers In Pretalx assignments can be done in two directions Assign proposals to reviewers Assign reviewers to proposals We will always assume direction 1. in this file when we talk about an assignment. So in Operation Research-speak, resources get assigned tasks, not the other way around. The time needed for the task of reviewing a proposal is quite homogeneous while the number of reviews a single reviewer may highly vary. Also, we will rather use the name submission instead of proposal as this also reflects the naming of the Pretalx API. We follow the convention over configuration principle here and thus check out the Col class for the naming of columns. Col \u00b6 Additional conventions used for reviews address_as = 'Address as' class-attribute \u00b6 all_proposals = 'All Proposals' class-attribute \u00b6 committee_contact = 'Committee Contact' class-attribute \u00b6 curr_assignments = 'Current Assignments' class-attribute \u00b6 done_nreviews = 'Done #Reviews' class-attribute \u00b6 nassignments = '#Assignments' class-attribute \u00b6 nvotes = '#Votes' class-attribute \u00b6 pretalx_activated = 'Pretalx activated' class-attribute \u00b6 rem_nreviews = 'Remaining #Reviews' class-attribute \u00b6 target_nreviews = 'Target #Reviews' class-attribute \u00b6 track_prefs = 'Track Preferences' class-attribute \u00b6 vote_score = 'Vote Score' class-attribute \u00b6 read_assignment_as_df ( file_path : Path ) -> pd . DataFrame \u00b6 Reads an assignment and returns a dataframe Source code in pytanis/review.py def read_assignment_as_df ( file_path : Path ) -> pd . DataFrame : \"\"\"Reads an assignment and returns a dataframe\"\"\" with open ( file_path ) as fh : curr_assign = json . load ( fh ) df = pd . DataFrame ({ k : [ v ] for k , v in curr_assign . items ()}) df = df . T . rename_axis ( index = Col . email ) . rename ( columns = { 0 : Col . curr_assignments }) . reset_index () return df save_assignments_as_json ( df : pd . DataFrame , file_path : Union [ Path , str ]) \u00b6 Save the dataframe as proposal assignment JSON file Source code in pytanis/review.py def save_assignments_as_json ( df : pd . DataFrame , file_path : Union [ Path , str ]): \"\"\"Save the dataframe as proposal assignment JSON file\"\"\" file_path = Path ( file_path ) df = df . loc [:, [ Col . email , Col . curr_assignments ]] json_dct = json . loads ( df . set_index ( Col . email ) . to_json ())[ Col . curr_assignments ] # prettify the json string for human-edit-ability if reviewers need to be dropped later json_str = json . dumps ( json_dct ) . replace ( \"{\" , \"{ \\n \" ) . replace ( \"], \" , \"], \\n \" ) . replace ( \"]}\" , \"] \\n }\" ) with open ( file_path , \"w\" ) as fh : fh . write ( json_str )","title":"review"},{"location":"reference/pytanis/review/#pytanis.review","text":"Tools related to assigning proposals to reviewers In Pretalx assignments can be done in two directions Assign proposals to reviewers Assign reviewers to proposals We will always assume direction 1. in this file when we talk about an assignment. So in Operation Research-speak, resources get assigned tasks, not the other way around. The time needed for the task of reviewing a proposal is quite homogeneous while the number of reviews a single reviewer may highly vary. Also, we will rather use the name submission instead of proposal as this also reflects the naming of the Pretalx API. We follow the convention over configuration principle here and thus check out the Col class for the naming of columns.","title":"review"},{"location":"reference/pytanis/review/#pytanis.review.Col","text":"Additional conventions used for reviews","title":"Col"},{"location":"reference/pytanis/review/#pytanis.review.Col.address_as","text":"","title":"address_as"},{"location":"reference/pytanis/review/#pytanis.review.Col.all_proposals","text":"","title":"all_proposals"},{"location":"reference/pytanis/review/#pytanis.review.Col.committee_contact","text":"","title":"committee_contact"},{"location":"reference/pytanis/review/#pytanis.review.Col.curr_assignments","text":"","title":"curr_assignments"},{"location":"reference/pytanis/review/#pytanis.review.Col.done_nreviews","text":"","title":"done_nreviews"},{"location":"reference/pytanis/review/#pytanis.review.Col.nassignments","text":"","title":"nassignments"},{"location":"reference/pytanis/review/#pytanis.review.Col.nvotes","text":"","title":"nvotes"},{"location":"reference/pytanis/review/#pytanis.review.Col.pretalx_activated","text":"","title":"pretalx_activated"},{"location":"reference/pytanis/review/#pytanis.review.Col.rem_nreviews","text":"","title":"rem_nreviews"},{"location":"reference/pytanis/review/#pytanis.review.Col.target_nreviews","text":"","title":"target_nreviews"},{"location":"reference/pytanis/review/#pytanis.review.Col.track_prefs","text":"","title":"track_prefs"},{"location":"reference/pytanis/review/#pytanis.review.Col.vote_score","text":"","title":"vote_score"},{"location":"reference/pytanis/review/#pytanis.review.read_assignment_as_df","text":"Reads an assignment and returns a dataframe Source code in pytanis/review.py def read_assignment_as_df ( file_path : Path ) -> pd . DataFrame : \"\"\"Reads an assignment and returns a dataframe\"\"\" with open ( file_path ) as fh : curr_assign = json . load ( fh ) df = pd . DataFrame ({ k : [ v ] for k , v in curr_assign . items ()}) df = df . T . rename_axis ( index = Col . email ) . rename ( columns = { 0 : Col . curr_assignments }) . reset_index () return df","title":"read_assignment_as_df()"},{"location":"reference/pytanis/review/#pytanis.review.save_assignments_as_json","text":"Save the dataframe as proposal assignment JSON file Source code in pytanis/review.py def save_assignments_as_json ( df : pd . DataFrame , file_path : Union [ Path , str ]): \"\"\"Save the dataframe as proposal assignment JSON file\"\"\" file_path = Path ( file_path ) df = df . loc [:, [ Col . email , Col . curr_assignments ]] json_dct = json . loads ( df . set_index ( Col . email ) . to_json ())[ Col . curr_assignments ] # prettify the json string for human-edit-ability if reviewers need to be dropped later json_str = json . dumps ( json_dct ) . replace ( \"{\" , \"{ \\n \" ) . replace ( \"], \" , \"], \\n \" ) . replace ( \"]}\" , \"] \\n }\" ) with open ( file_path , \"w\" ) as fh : fh . write ( json_str )","title":"save_assignments_as_json()"},{"location":"reference/pytanis/utils/","text":"utils \u00b6 Additional utilities RT = TypeVar ( 'RT' ) module-attribute \u00b6 implode ( df : pd . DataFrame , cols : Union [ str , List [ str ]]) -> pd . DataFrame \u00b6 The inverse of Pandas' explode Source code in pytanis/utils.py def implode ( df : pd . DataFrame , cols : Union [ str , List [ str ]]) -> pd . DataFrame : \"\"\"The inverse of Pandas' explode\"\"\" if not isinstance ( cols , list ): cols = [ cols ] orig_cols = df . columns grp_cols = [ col for col in df . columns if col not in cols ] df = df . groupby ( grp_cols , group_keys = True , dropna = False ) . aggregate ({ col : lambda x : x . tolist () for col in cols }) df . reset_index ( inplace = True ) df = df . loc [:, orig_cols ] return df pretty_timedelta ( seconds : int ) -> str \u00b6 Converts timedelta in seconds to human-readable string Parameters: Name Type Description Default seconds int time delta in seconds required Returns: Type Description str timedelta as pretty string Source code in pytanis/utils.py def pretty_timedelta ( seconds : int ) -> str : \"\"\"Converts timedelta in seconds to human-readable string Args: seconds: time delta in seconds Returns: timedelta as pretty string \"\"\" sign = '-' if seconds < 0 else '' seconds = abs ( int ( seconds )) days , seconds = divmod ( seconds , 86400 ) hours , seconds = divmod ( seconds , 3600 ) minutes , seconds = divmod ( seconds , 60 ) if days > 0 : return ' {}{} d {} h {} m {} s' . format ( sign , days , hours , minutes , seconds ) elif hours > 0 : return ' {}{} h {} m {} s' . format ( sign , hours , minutes , seconds ) elif minutes > 0 : return ' {}{} m {} s' . format ( sign , minutes , seconds ) else : return ' {}{} s' . format ( sign , seconds ) rm_keys ( keys : Union [ Any , List [ Any ]], dct : Dict [ Any , Any ]) -> Dict [ Any , Any ] \u00b6 Return a copy with keys removed from dictionary Source code in pytanis/utils.py def rm_keys ( keys : Union [ Any , List [ Any ]], dct : Dict [ Any , Any ], ) -> Dict [ Any , Any ]: \"\"\"Return a copy with keys removed from dictionary\"\"\" if not isinstance ( keys , list ): keys = [ keys ] return { k : v for k , v in dct . items () if k not in keys } throttle ( calls : int , seconds : int = 1 ) -> Callable [[ Callable [ ... , RT ]], Callable [ ... , RT ]] \u00b6 Decorator for throttling a function to number of calls per seconds Parameters: Name Type Description Default calls int number of calls per interval required seconds int number of seconds in interval 1 Returns: Type Description Callable [[ Callable [..., RT ]], Callable [..., RT ]] wrapped function Source code in pytanis/utils.py def throttle ( calls : int , seconds : int = 1 ) -> Callable [[ Callable [ ... , RT ]], Callable [ ... , RT ]]: \"\"\"Decorator for throttling a function to number of calls per seconds Args: calls: number of calls per interval seconds: number of seconds in interval Returns: wrapped function \"\"\" assert isinstance ( calls , int ), 'number of calls must be integer' assert isinstance ( seconds , int ), 'number of seconds must be integer' def decorator ( func : Callable [ ... , RT ]) -> Callable [ ... , RT ]: # keeps track of the last calls last_calls : List [ float ] = list () @functools . wraps ( func ) def wrapper ( * args , ** kwargs ) -> RT : curr_time = time . time () if last_calls : # remove calls from last_calls list older than interval in seconds idx_old_calls = [ i for i , t in enumerate ( last_calls ) if t < curr_time - seconds ] if idx_old_calls : del last_calls [: idx_old_calls [ - 1 ]] if len ( last_calls ) >= calls : idx = len ( last_calls ) - calls delta = fabs ( 1 - curr_time + last_calls [ idx ]) logger = get_logger () logger . debug ( \"stalling call\" , func = func . __name__ , secs = delta ) time . sleep ( delta ) resp = func ( * args , ** kwargs ) last_calls . append ( time . time ()) return resp return wrapper return decorator","title":"utils"},{"location":"reference/pytanis/utils/#pytanis.utils","text":"Additional utilities","title":"utils"},{"location":"reference/pytanis/utils/#pytanis.utils.RT","text":"","title":"RT"},{"location":"reference/pytanis/utils/#pytanis.utils.implode","text":"The inverse of Pandas' explode Source code in pytanis/utils.py def implode ( df : pd . DataFrame , cols : Union [ str , List [ str ]]) -> pd . DataFrame : \"\"\"The inverse of Pandas' explode\"\"\" if not isinstance ( cols , list ): cols = [ cols ] orig_cols = df . columns grp_cols = [ col for col in df . columns if col not in cols ] df = df . groupby ( grp_cols , group_keys = True , dropna = False ) . aggregate ({ col : lambda x : x . tolist () for col in cols }) df . reset_index ( inplace = True ) df = df . loc [:, orig_cols ] return df","title":"implode()"},{"location":"reference/pytanis/utils/#pytanis.utils.pretty_timedelta","text":"Converts timedelta in seconds to human-readable string Parameters: Name Type Description Default seconds int time delta in seconds required Returns: Type Description str timedelta as pretty string Source code in pytanis/utils.py def pretty_timedelta ( seconds : int ) -> str : \"\"\"Converts timedelta in seconds to human-readable string Args: seconds: time delta in seconds Returns: timedelta as pretty string \"\"\" sign = '-' if seconds < 0 else '' seconds = abs ( int ( seconds )) days , seconds = divmod ( seconds , 86400 ) hours , seconds = divmod ( seconds , 3600 ) minutes , seconds = divmod ( seconds , 60 ) if days > 0 : return ' {}{} d {} h {} m {} s' . format ( sign , days , hours , minutes , seconds ) elif hours > 0 : return ' {}{} h {} m {} s' . format ( sign , hours , minutes , seconds ) elif minutes > 0 : return ' {}{} m {} s' . format ( sign , minutes , seconds ) else : return ' {}{} s' . format ( sign , seconds )","title":"pretty_timedelta()"},{"location":"reference/pytanis/utils/#pytanis.utils.rm_keys","text":"Return a copy with keys removed from dictionary Source code in pytanis/utils.py def rm_keys ( keys : Union [ Any , List [ Any ]], dct : Dict [ Any , Any ], ) -> Dict [ Any , Any ]: \"\"\"Return a copy with keys removed from dictionary\"\"\" if not isinstance ( keys , list ): keys = [ keys ] return { k : v for k , v in dct . items () if k not in keys }","title":"rm_keys()"},{"location":"reference/pytanis/utils/#pytanis.utils.throttle","text":"Decorator for throttling a function to number of calls per seconds Parameters: Name Type Description Default calls int number of calls per interval required seconds int number of seconds in interval 1 Returns: Type Description Callable [[ Callable [..., RT ]], Callable [..., RT ]] wrapped function Source code in pytanis/utils.py def throttle ( calls : int , seconds : int = 1 ) -> Callable [[ Callable [ ... , RT ]], Callable [ ... , RT ]]: \"\"\"Decorator for throttling a function to number of calls per seconds Args: calls: number of calls per interval seconds: number of seconds in interval Returns: wrapped function \"\"\" assert isinstance ( calls , int ), 'number of calls must be integer' assert isinstance ( seconds , int ), 'number of seconds must be integer' def decorator ( func : Callable [ ... , RT ]) -> Callable [ ... , RT ]: # keeps track of the last calls last_calls : List [ float ] = list () @functools . wraps ( func ) def wrapper ( * args , ** kwargs ) -> RT : curr_time = time . time () if last_calls : # remove calls from last_calls list older than interval in seconds idx_old_calls = [ i for i , t in enumerate ( last_calls ) if t < curr_time - seconds ] if idx_old_calls : del last_calls [: idx_old_calls [ - 1 ]] if len ( last_calls ) >= calls : idx = len ( last_calls ) - calls delta = fabs ( 1 - curr_time + last_calls [ idx ]) logger = get_logger () logger . debug ( \"stalling call\" , func = func . __name__ , secs = delta ) time . sleep ( delta ) resp = func ( * args , ** kwargs ) last_calls . append ( time . time ()) return resp return wrapper return decorator","title":"throttle()"},{"location":"reference/pytanis/helpdesk/","text":"helpdesk \u00b6 Functionality around the HelpDesk / LiveChat API __all__ = [ 'HelpDeskClient' , 'Mail' , 'MailClient' , 'Recipient' ] module-attribute \u00b6 HelpDeskClient ( config : Optional [ Config ] = None ) \u00b6 Source code in pytanis/helpdesk/client.py def __init__ ( self , config : Optional [ Config ] = None ): if config is None : config = get_cfg () self . _config = config # Important: Always use a custom User-Agent, never a generic one. # Generic User-Agents are filtered by helpdesk to reduce spam. self . _headers = { \"User-Agent\" : \"Pytanis\" } self . _get_throttled = self . _get self . _post_throttled = self . _post self . set_throttling ( 2 , 1 ) # we are nice by default create_ticket ( ticket : NewTicket ) \u00b6 Source code in pytanis/helpdesk/client.py def create_ticket ( self , ticket : NewTicket ): return self . post ( \"tickets\" , data = ticket . dict ()) get ( endpoint : str , params : Optional [ Dict [ str , str ]] = None ) -> JSON \u00b6 Retrieve data via throttled GET request and return the JSON Source code in pytanis/helpdesk/client.py def get ( self , endpoint : str , params : Optional [ Dict [ str , str ]] = None ) -> JSON : \"\"\"Retrieve data via throttled GET request and return the JSON\"\"\" resp = self . _get_throttled ( endpoint , params ) resp . raise_for_status () return resp . json () list_agents () -> List [ Agent ] \u00b6 Source code in pytanis/helpdesk/client.py def list_agents ( self ) -> List [ Agent ]: agents = self . get ( \"agents\" ) assert isinstance ( agents , List ) return [ Agent . parse_obj ( dct ) for dct in agents ] list_teams () -> List [ Team ] \u00b6 Source code in pytanis/helpdesk/client.py def list_teams ( self ) -> List [ Team ]: teams = self . get ( \"teams\" ) assert isinstance ( teams , List ) return [ Team . parse_obj ( dct ) for dct in teams ] post ( endpoint : str , data : Dict [ str , Any ], params : Optional [ Dict [ str , str ]] = None ) -> JSON \u00b6 Source code in pytanis/helpdesk/client.py def post ( self , endpoint : str , data : Dict [ str , Any ], params : Optional [ Dict [ str , str ]] = None ) -> JSON : resp = self . _post_throttled ( endpoint , data , params ) resp . raise_for_status () return resp . json () set_throttling ( calls : int , seconds : int ) \u00b6 Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/helpdesk/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . debug ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get ) self . _post_throttled = throttle ( calls , seconds )( self . _post ) Mail \u00b6 Mail template Use the data field to store additional information You can use the typical Format String Syntax and the objects recipient and mail to access metadata to complement the template, e.g.: Hello {recipient.address_as}, We hope it's ok to address you your first name rather than using your full name being {recipient.name}. Have you read the email's subject '{mail.subject}'? How is your work right now at {recipient.data.company}? Cheers! agent_id : str class-attribute \u00b6 data : Optional [ MetaData ] class-attribute \u00b6 recipients : List [ Recipient ] class-attribute \u00b6 status : str = 'solved' class-attribute \u00b6 subject : str class-attribute \u00b6 team_id : str class-attribute \u00b6 text : str class-attribute \u00b6 MailClient ( helpdesk_client : Optional [ HelpDeskClient ] = None ) \u00b6 Mail client for mass mails over HelpDesk Source code in pytanis/helpdesk/mail.py def __init__ ( self , helpdesk_client : Optional [ HelpDeskClient ] = None ): if helpdesk_client is None : helpdesk_client = HelpDeskClient () self . _helpdesk_client = helpdesk_client self . dry_run : Callable [[ NewTicket ], None ] = self . print_new_ticket dry_run : Callable [[ NewTicket ], None ] = self . print_new_ticket instance-attribute \u00b6 print_new_ticket ( ticket : NewTicket ) staticmethod \u00b6 Default action in a dry-run. Mainly for making sure you sent what you mean! Overwrite it by assigning to self.dry_run another function ToDo: Make this function nice, maybe use the rich library even Source code in pytanis/helpdesk/mail.py @staticmethod def print_new_ticket ( ticket : NewTicket ): \"\"\"Default action in a dry-run. Mainly for making sure you sent what you mean! Overwrite it by assigning to self.dry_run another function ToDo: Make this function nice, maybe use the `rich` library even \"\"\" print ( \"#\" * 40 ) print ( f \"Recipient: { ticket . requester . name } < { ticket . requester . email } >\" ) print ( f \"Subject: { ticket . subject } \" ) print ( f \" { ticket . message . text } \" ) send ( mail : Mail , dry_run : bool = True ) -> Tuple [ List [ Tuple [ Recipient , Optional [ Ticket ]]], List [ Tuple [ Recipient , Exception ]]] \u00b6 Send a mail to all recipients using HelpDesk Source code in pytanis/helpdesk/mail.py def send ( self , mail : Mail , dry_run : bool = True ) -> Tuple [ List [ Tuple [ Recipient , Optional [ Ticket ]]], List [ Tuple [ Recipient , Exception ]]]: \"\"\"Send a mail to all recipients using HelpDesk\"\"\" errors = [] tickets = [] for recipient in tqdm ( mail . recipients ): recip_mail = mail . copy () try : recip_mail . subject = mail . subject . format ( recipient = recipient , mail = mail ) # be aware here that the body might reference to subject line, so it must be filled already recip_mail . text = recip_mail . text . format ( recipient = recipient , mail = recip_mail ) ticket = self . _create_ticket ( recip_mail , recipient ) if dry_run : self . print_new_ticket ( ticket ) resp_ticket = None else : resp = self . _helpdesk_client . create_ticket ( ticket ) resp_ticket = Ticket . parse_obj ( resp ) except Exception as e : errors . append (( recipient , e )) else : tickets . append (( recipient , resp_ticket )) return tickets , errors Recipient \u00b6 Details about the recipient Use the data field to store additional information address_as : Optional [ str ] class-attribute \u00b6 data : Optional [ MetaData ] class-attribute \u00b6 email : str class-attribute \u00b6 name : str class-attribute \u00b6 fill_with_name ( v , values ) classmethod \u00b6 Source code in pytanis/helpdesk/mail.py @validator ( \"address_as\" ) @classmethod def fill_with_name ( cls , v , values ): if v is None : v = values [ \"name\" ] return v","title":"helpdesk"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk","text":"Functionality around the HelpDesk / LiveChat API","title":"helpdesk"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.__all__","text":"","title":"__all__"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.HelpDeskClient","text":"Source code in pytanis/helpdesk/client.py def __init__ ( self , config : Optional [ Config ] = None ): if config is None : config = get_cfg () self . _config = config # Important: Always use a custom User-Agent, never a generic one. # Generic User-Agents are filtered by helpdesk to reduce spam. self . _headers = { \"User-Agent\" : \"Pytanis\" } self . _get_throttled = self . _get self . _post_throttled = self . _post self . set_throttling ( 2 , 1 ) # we are nice by default","title":"HelpDeskClient"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.client.HelpDeskClient.create_ticket","text":"Source code in pytanis/helpdesk/client.py def create_ticket ( self , ticket : NewTicket ): return self . post ( \"tickets\" , data = ticket . dict ())","title":"create_ticket()"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.client.HelpDeskClient.get","text":"Retrieve data via throttled GET request and return the JSON Source code in pytanis/helpdesk/client.py def get ( self , endpoint : str , params : Optional [ Dict [ str , str ]] = None ) -> JSON : \"\"\"Retrieve data via throttled GET request and return the JSON\"\"\" resp = self . _get_throttled ( endpoint , params ) resp . raise_for_status () return resp . json ()","title":"get()"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.client.HelpDeskClient.list_agents","text":"Source code in pytanis/helpdesk/client.py def list_agents ( self ) -> List [ Agent ]: agents = self . get ( \"agents\" ) assert isinstance ( agents , List ) return [ Agent . parse_obj ( dct ) for dct in agents ]","title":"list_agents()"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.client.HelpDeskClient.list_teams","text":"Source code in pytanis/helpdesk/client.py def list_teams ( self ) -> List [ Team ]: teams = self . get ( \"teams\" ) assert isinstance ( teams , List ) return [ Team . parse_obj ( dct ) for dct in teams ]","title":"list_teams()"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.client.HelpDeskClient.post","text":"Source code in pytanis/helpdesk/client.py def post ( self , endpoint : str , data : Dict [ str , Any ], params : Optional [ Dict [ str , str ]] = None ) -> JSON : resp = self . _post_throttled ( endpoint , data , params ) resp . raise_for_status () return resp . json ()","title":"post()"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.client.HelpDeskClient.set_throttling","text":"Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/helpdesk/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . debug ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get ) self . _post_throttled = throttle ( calls , seconds )( self . _post )","title":"set_throttling()"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Mail","text":"Mail template Use the data field to store additional information You can use the typical Format String Syntax and the objects recipient and mail to access metadata to complement the template, e.g.: Hello {recipient.address_as}, We hope it's ok to address you your first name rather than using your full name being {recipient.name}. Have you read the email's subject '{mail.subject}'? How is your work right now at {recipient.data.company}? Cheers!","title":"Mail"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Mail.agent_id","text":"","title":"agent_id"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Mail.data","text":"","title":"data"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Mail.recipients","text":"","title":"recipients"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Mail.status","text":"","title":"status"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Mail.subject","text":"","title":"subject"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Mail.team_id","text":"","title":"team_id"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Mail.text","text":"","title":"text"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.MailClient","text":"Mail client for mass mails over HelpDesk Source code in pytanis/helpdesk/mail.py def __init__ ( self , helpdesk_client : Optional [ HelpDeskClient ] = None ): if helpdesk_client is None : helpdesk_client = HelpDeskClient () self . _helpdesk_client = helpdesk_client self . dry_run : Callable [[ NewTicket ], None ] = self . print_new_ticket","title":"MailClient"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.MailClient.dry_run","text":"","title":"dry_run"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.MailClient.print_new_ticket","text":"Default action in a dry-run. Mainly for making sure you sent what you mean! Overwrite it by assigning to self.dry_run another function ToDo: Make this function nice, maybe use the rich library even Source code in pytanis/helpdesk/mail.py @staticmethod def print_new_ticket ( ticket : NewTicket ): \"\"\"Default action in a dry-run. Mainly for making sure you sent what you mean! Overwrite it by assigning to self.dry_run another function ToDo: Make this function nice, maybe use the `rich` library even \"\"\" print ( \"#\" * 40 ) print ( f \"Recipient: { ticket . requester . name } < { ticket . requester . email } >\" ) print ( f \"Subject: { ticket . subject } \" ) print ( f \" { ticket . message . text } \" )","title":"print_new_ticket()"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.MailClient.send","text":"Send a mail to all recipients using HelpDesk Source code in pytanis/helpdesk/mail.py def send ( self , mail : Mail , dry_run : bool = True ) -> Tuple [ List [ Tuple [ Recipient , Optional [ Ticket ]]], List [ Tuple [ Recipient , Exception ]]]: \"\"\"Send a mail to all recipients using HelpDesk\"\"\" errors = [] tickets = [] for recipient in tqdm ( mail . recipients ): recip_mail = mail . copy () try : recip_mail . subject = mail . subject . format ( recipient = recipient , mail = mail ) # be aware here that the body might reference to subject line, so it must be filled already recip_mail . text = recip_mail . text . format ( recipient = recipient , mail = recip_mail ) ticket = self . _create_ticket ( recip_mail , recipient ) if dry_run : self . print_new_ticket ( ticket ) resp_ticket = None else : resp = self . _helpdesk_client . create_ticket ( ticket ) resp_ticket = Ticket . parse_obj ( resp ) except Exception as e : errors . append (( recipient , e )) else : tickets . append (( recipient , resp_ticket )) return tickets , errors","title":"send()"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Recipient","text":"Details about the recipient Use the data field to store additional information","title":"Recipient"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Recipient.address_as","text":"","title":"address_as"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Recipient.data","text":"","title":"data"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Recipient.email","text":"","title":"email"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Recipient.name","text":"","title":"name"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Recipient.fill_with_name","text":"Source code in pytanis/helpdesk/mail.py @validator ( \"address_as\" ) @classmethod def fill_with_name ( cls , v , values ): if v is None : v = values [ \"name\" ] return v","title":"fill_with_name()"},{"location":"reference/pytanis/helpdesk/client/","text":"client \u00b6 Client for the HelpDesk / LiveChat API Documentation: https://api.helpdesk.com/docs ToDo Transfer more functionality from PYCONDE/py_helpdesk_com JSON = Union [ JSONObj , JSONLst ] module-attribute \u00b6 Type of the JSON response as returned by the HelpDesk / LiveChat API JSONLst = List [ JSONObj ] module-attribute \u00b6 Type of a JSON list of JSON objects JSONObj = Dict [ str , Any ] module-attribute \u00b6 Type of a JSON object (without recursion) HelpDeskClient ( config : Optional [ Config ] = None ) \u00b6 Source code in pytanis/helpdesk/client.py def __init__ ( self , config : Optional [ Config ] = None ): if config is None : config = get_cfg () self . _config = config # Important: Always use a custom User-Agent, never a generic one. # Generic User-Agents are filtered by helpdesk to reduce spam. self . _headers = { \"User-Agent\" : \"Pytanis\" } self . _get_throttled = self . _get self . _post_throttled = self . _post self . set_throttling ( 2 , 1 ) # we are nice by default create_ticket ( ticket : NewTicket ) \u00b6 Source code in pytanis/helpdesk/client.py def create_ticket ( self , ticket : NewTicket ): return self . post ( \"tickets\" , data = ticket . dict ()) get ( endpoint : str , params : Optional [ Dict [ str , str ]] = None ) -> JSON \u00b6 Retrieve data via throttled GET request and return the JSON Source code in pytanis/helpdesk/client.py def get ( self , endpoint : str , params : Optional [ Dict [ str , str ]] = None ) -> JSON : \"\"\"Retrieve data via throttled GET request and return the JSON\"\"\" resp = self . _get_throttled ( endpoint , params ) resp . raise_for_status () return resp . json () list_agents () -> List [ Agent ] \u00b6 Source code in pytanis/helpdesk/client.py def list_agents ( self ) -> List [ Agent ]: agents = self . get ( \"agents\" ) assert isinstance ( agents , List ) return [ Agent . parse_obj ( dct ) for dct in agents ] list_teams () -> List [ Team ] \u00b6 Source code in pytanis/helpdesk/client.py def list_teams ( self ) -> List [ Team ]: teams = self . get ( \"teams\" ) assert isinstance ( teams , List ) return [ Team . parse_obj ( dct ) for dct in teams ] post ( endpoint : str , data : Dict [ str , Any ], params : Optional [ Dict [ str , str ]] = None ) -> JSON \u00b6 Source code in pytanis/helpdesk/client.py def post ( self , endpoint : str , data : Dict [ str , Any ], params : Optional [ Dict [ str , str ]] = None ) -> JSON : resp = self . _post_throttled ( endpoint , data , params ) resp . raise_for_status () return resp . json () set_throttling ( calls : int , seconds : int ) \u00b6 Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/helpdesk/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . debug ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get ) self . _post_throttled = throttle ( calls , seconds )( self . _post )","title":"client"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client","text":"Client for the HelpDesk / LiveChat API Documentation: https://api.helpdesk.com/docs ToDo Transfer more functionality from PYCONDE/py_helpdesk_com","title":"client"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.JSON","text":"Type of the JSON response as returned by the HelpDesk / LiveChat API","title":"JSON"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.JSONLst","text":"Type of a JSON list of JSON objects","title":"JSONLst"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.JSONObj","text":"Type of a JSON object (without recursion)","title":"JSONObj"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient","text":"Source code in pytanis/helpdesk/client.py def __init__ ( self , config : Optional [ Config ] = None ): if config is None : config = get_cfg () self . _config = config # Important: Always use a custom User-Agent, never a generic one. # Generic User-Agents are filtered by helpdesk to reduce spam. self . _headers = { \"User-Agent\" : \"Pytanis\" } self . _get_throttled = self . _get self . _post_throttled = self . _post self . set_throttling ( 2 , 1 ) # we are nice by default","title":"HelpDeskClient"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.create_ticket","text":"Source code in pytanis/helpdesk/client.py def create_ticket ( self , ticket : NewTicket ): return self . post ( \"tickets\" , data = ticket . dict ())","title":"create_ticket()"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.get","text":"Retrieve data via throttled GET request and return the JSON Source code in pytanis/helpdesk/client.py def get ( self , endpoint : str , params : Optional [ Dict [ str , str ]] = None ) -> JSON : \"\"\"Retrieve data via throttled GET request and return the JSON\"\"\" resp = self . _get_throttled ( endpoint , params ) resp . raise_for_status () return resp . json ()","title":"get()"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.list_agents","text":"Source code in pytanis/helpdesk/client.py def list_agents ( self ) -> List [ Agent ]: agents = self . get ( \"agents\" ) assert isinstance ( agents , List ) return [ Agent . parse_obj ( dct ) for dct in agents ]","title":"list_agents()"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.list_teams","text":"Source code in pytanis/helpdesk/client.py def list_teams ( self ) -> List [ Team ]: teams = self . get ( \"teams\" ) assert isinstance ( teams , List ) return [ Team . parse_obj ( dct ) for dct in teams ]","title":"list_teams()"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.post","text":"Source code in pytanis/helpdesk/client.py def post ( self , endpoint : str , data : Dict [ str , Any ], params : Optional [ Dict [ str , str ]] = None ) -> JSON : resp = self . _post_throttled ( endpoint , data , params ) resp . raise_for_status () return resp . json ()","title":"post()"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.set_throttling","text":"Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/helpdesk/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . debug ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get ) self . _post_throttled = throttle ( calls , seconds )( self . _post )","title":"set_throttling()"},{"location":"reference/pytanis/helpdesk/mail/","text":"mail \u00b6 Functionality around mailing ToDo add logging where appropriate Find out why extra=Extra.allow causes mypy to fail. Seems like a bug in pydantic. Sending mails is quite slow, so using tqdm to show feedback to the current progress would be nice Mail \u00b6 Mail template Use the data field to store additional information You can use the typical Format String Syntax and the objects recipient and mail to access metadata to complement the template, e.g.: Hello {recipient.address_as}, We hope it's ok to address you your first name rather than using your full name being {recipient.name}. Have you read the email's subject '{mail.subject}'? How is your work right now at {recipient.data.company}? Cheers! agent_id : str class-attribute \u00b6 data : Optional [ MetaData ] class-attribute \u00b6 recipients : List [ Recipient ] class-attribute \u00b6 status : str = 'solved' class-attribute \u00b6 subject : str class-attribute \u00b6 team_id : str class-attribute \u00b6 text : str class-attribute \u00b6 MailClient ( helpdesk_client : Optional [ HelpDeskClient ] = None ) \u00b6 Mail client for mass mails over HelpDesk Source code in pytanis/helpdesk/mail.py def __init__ ( self , helpdesk_client : Optional [ HelpDeskClient ] = None ): if helpdesk_client is None : helpdesk_client = HelpDeskClient () self . _helpdesk_client = helpdesk_client self . dry_run : Callable [[ NewTicket ], None ] = self . print_new_ticket dry_run : Callable [[ NewTicket ], None ] = self . print_new_ticket instance-attribute \u00b6 print_new_ticket ( ticket : NewTicket ) staticmethod \u00b6 Default action in a dry-run. Mainly for making sure you sent what you mean! Overwrite it by assigning to self.dry_run another function ToDo: Make this function nice, maybe use the rich library even Source code in pytanis/helpdesk/mail.py @staticmethod def print_new_ticket ( ticket : NewTicket ): \"\"\"Default action in a dry-run. Mainly for making sure you sent what you mean! Overwrite it by assigning to self.dry_run another function ToDo: Make this function nice, maybe use the `rich` library even \"\"\" print ( \"#\" * 40 ) print ( f \"Recipient: { ticket . requester . name } < { ticket . requester . email } >\" ) print ( f \"Subject: { ticket . subject } \" ) print ( f \" { ticket . message . text } \" ) send ( mail : Mail , dry_run : bool = True ) -> Tuple [ List [ Tuple [ Recipient , Optional [ Ticket ]]], List [ Tuple [ Recipient , Exception ]]] \u00b6 Send a mail to all recipients using HelpDesk Source code in pytanis/helpdesk/mail.py def send ( self , mail : Mail , dry_run : bool = True ) -> Tuple [ List [ Tuple [ Recipient , Optional [ Ticket ]]], List [ Tuple [ Recipient , Exception ]]]: \"\"\"Send a mail to all recipients using HelpDesk\"\"\" errors = [] tickets = [] for recipient in tqdm ( mail . recipients ): recip_mail = mail . copy () try : recip_mail . subject = mail . subject . format ( recipient = recipient , mail = mail ) # be aware here that the body might reference to subject line, so it must be filled already recip_mail . text = recip_mail . text . format ( recipient = recipient , mail = recip_mail ) ticket = self . _create_ticket ( recip_mail , recipient ) if dry_run : self . print_new_ticket ( ticket ) resp_ticket = None else : resp = self . _helpdesk_client . create_ticket ( ticket ) resp_ticket = Ticket . parse_obj ( resp ) except Exception as e : errors . append (( recipient , e )) else : tickets . append (( recipient , resp_ticket )) return tickets , errors MetaData \u00b6 Additional, arbitrary metadata provided by the user like for template filling Recipient \u00b6 Details about the recipient Use the data field to store additional information address_as : Optional [ str ] class-attribute \u00b6 data : Optional [ MetaData ] class-attribute \u00b6 email : str class-attribute \u00b6 name : str class-attribute \u00b6 fill_with_name ( v , values ) classmethod \u00b6 Source code in pytanis/helpdesk/mail.py @validator ( \"address_as\" ) @classmethod def fill_with_name ( cls , v , values ): if v is None : v = values [ \"name\" ] return v","title":"mail"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail","text":"Functionality around mailing ToDo add logging where appropriate Find out why extra=Extra.allow causes mypy to fail. Seems like a bug in pydantic. Sending mails is quite slow, so using tqdm to show feedback to the current progress would be nice","title":"mail"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail","text":"Mail template Use the data field to store additional information You can use the typical Format String Syntax and the objects recipient and mail to access metadata to complement the template, e.g.: Hello {recipient.address_as}, We hope it's ok to address you your first name rather than using your full name being {recipient.name}. Have you read the email's subject '{mail.subject}'? How is your work right now at {recipient.data.company}? Cheers!","title":"Mail"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.agent_id","text":"","title":"agent_id"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.data","text":"","title":"data"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.recipients","text":"","title":"recipients"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.status","text":"","title":"status"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.subject","text":"","title":"subject"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.team_id","text":"","title":"team_id"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.text","text":"","title":"text"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MailClient","text":"Mail client for mass mails over HelpDesk Source code in pytanis/helpdesk/mail.py def __init__ ( self , helpdesk_client : Optional [ HelpDeskClient ] = None ): if helpdesk_client is None : helpdesk_client = HelpDeskClient () self . _helpdesk_client = helpdesk_client self . dry_run : Callable [[ NewTicket ], None ] = self . print_new_ticket","title":"MailClient"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MailClient.dry_run","text":"","title":"dry_run"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MailClient.print_new_ticket","text":"Default action in a dry-run. Mainly for making sure you sent what you mean! Overwrite it by assigning to self.dry_run another function ToDo: Make this function nice, maybe use the rich library even Source code in pytanis/helpdesk/mail.py @staticmethod def print_new_ticket ( ticket : NewTicket ): \"\"\"Default action in a dry-run. Mainly for making sure you sent what you mean! Overwrite it by assigning to self.dry_run another function ToDo: Make this function nice, maybe use the `rich` library even \"\"\" print ( \"#\" * 40 ) print ( f \"Recipient: { ticket . requester . name } < { ticket . requester . email } >\" ) print ( f \"Subject: { ticket . subject } \" ) print ( f \" { ticket . message . text } \" )","title":"print_new_ticket()"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MailClient.send","text":"Send a mail to all recipients using HelpDesk Source code in pytanis/helpdesk/mail.py def send ( self , mail : Mail , dry_run : bool = True ) -> Tuple [ List [ Tuple [ Recipient , Optional [ Ticket ]]], List [ Tuple [ Recipient , Exception ]]]: \"\"\"Send a mail to all recipients using HelpDesk\"\"\" errors = [] tickets = [] for recipient in tqdm ( mail . recipients ): recip_mail = mail . copy () try : recip_mail . subject = mail . subject . format ( recipient = recipient , mail = mail ) # be aware here that the body might reference to subject line, so it must be filled already recip_mail . text = recip_mail . text . format ( recipient = recipient , mail = recip_mail ) ticket = self . _create_ticket ( recip_mail , recipient ) if dry_run : self . print_new_ticket ( ticket ) resp_ticket = None else : resp = self . _helpdesk_client . create_ticket ( ticket ) resp_ticket = Ticket . parse_obj ( resp ) except Exception as e : errors . append (( recipient , e )) else : tickets . append (( recipient , resp_ticket )) return tickets , errors","title":"send()"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MetaData","text":"Additional, arbitrary metadata provided by the user like for template filling","title":"MetaData"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient","text":"Details about the recipient Use the data field to store additional information","title":"Recipient"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient.address_as","text":"","title":"address_as"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient.data","text":"","title":"data"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient.email","text":"","title":"email"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient.name","text":"","title":"name"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient.fill_with_name","text":"Source code in pytanis/helpdesk/mail.py @validator ( \"address_as\" ) @classmethod def fill_with_name ( cls , v , values ): if v is None : v = values [ \"name\" ] return v","title":"fill_with_name()"},{"location":"reference/pytanis/helpdesk/types/","text":"types \u00b6 Return types of the HelpDesk / LiveChat API Documentation: https://api.helpdesk.com/docs ToDo Implement the types below correctly instead of using Extra.Allow Find out why extra=Extra.allow causes mypy to fail. Seems like a bug in pydantic. Agent \u00b6 Assignment \u00b6 agent : Id class-attribute \u00b6 team : Id class-attribute \u00b6 Id \u00b6 ID : str class-attribute \u00b6 Message \u00b6 text : str class-attribute \u00b6 NewTicket \u00b6 Object that needs to be sent when creating a NEW ticket assignment : Optional [ Assignment ] class-attribute \u00b6 message : Message class-attribute \u00b6 requester : Requester class-attribute \u00b6 status : Optional [ str ] class-attribute \u00b6 subject : Optional [ str ] class-attribute \u00b6 teamIDs : Optional [ List [ str ]] class-attribute \u00b6 Requester \u00b6 email : str class-attribute \u00b6 name : str class-attribute \u00b6 Team \u00b6 Ticket \u00b6 Actual ticket as returned by the API","title":"types"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types","text":"Return types of the HelpDesk / LiveChat API Documentation: https://api.helpdesk.com/docs ToDo Implement the types below correctly instead of using Extra.Allow Find out why extra=Extra.allow causes mypy to fail. Seems like a bug in pydantic.","title":"types"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Agent","text":"","title":"Agent"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Assignment","text":"","title":"Assignment"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Assignment.agent","text":"","title":"agent"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Assignment.team","text":"","title":"team"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Id","text":"","title":"Id"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Id.ID","text":"","title":"ID"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Message","text":"","title":"Message"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Message.text","text":"","title":"text"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.NewTicket","text":"Object that needs to be sent when creating a NEW ticket","title":"NewTicket"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.NewTicket.assignment","text":"","title":"assignment"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.NewTicket.message","text":"","title":"message"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.NewTicket.requester","text":"","title":"requester"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.NewTicket.status","text":"","title":"status"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.NewTicket.subject","text":"","title":"subject"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.NewTicket.teamIDs","text":"","title":"teamIDs"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Requester","text":"","title":"Requester"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Requester.email","text":"","title":"email"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Requester.name","text":"","title":"name"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Team","text":"","title":"Team"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Ticket","text":"Actual ticket as returned by the API","title":"Ticket"},{"location":"reference/pytanis/pretalx/","text":"pretalx \u00b6 Functionality around the Pretalx API __all__ = [ 'PretalxClient' , 'subs_as_df' , 'speakers_as_df' , 'reviews_as_df' ] module-attribute \u00b6 PretalxClient ( config : Optional [ Config ] = None , blocking : bool = False ) \u00b6 Client for the Pretalx API Source code in pytanis/pretalx/client.py def __init__ ( self , config : Optional [ Config ] = None , blocking : bool = False ): if config is None : config = get_cfg () self . _config = config self . _get_throttled = self . _get self . blocking = blocking self . set_throttling ( 1 , 2 ) # we are nice by default blocking = blocking instance-attribute \u00b6 answer ( event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Answer \u00b6 Returns a specific answer Source code in pytanis/pretalx/client.py def answer ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Answer : \"\"\"Returns a specific answer\"\"\" return self . _endpoint_id ( Answer , event_slug , \"answers\" , id , params = params ) answers ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Answer ]] \u00b6 Lists all answers and their details Source code in pytanis/pretalx/client.py def answers ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Answer ]]: \"\"\"Lists all answers and their details\"\"\" return self . _endpoint_lst ( Answer , event_slug , \"answers\" , params = params ) event ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Event \u00b6 Returns detailed information about a specific event Source code in pytanis/pretalx/client.py def event ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Event : \"\"\"Returns detailed information about a specific event\"\"\" endpoint = f \"/api/events/ { event_slug } /\" result = self . _get_one ( endpoint , params ) _logger . debug ( \"result\" , resp = result ) return Event . parse_obj ( result ) events ( * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Event ]] \u00b6 Lists all events and their details Source code in pytanis/pretalx/client.py def events ( self , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Event ]]: \"\"\"Lists all events and their details\"\"\" count , results = self . _get_many ( \"/api/events/\" , params ) events = iter ( _logger . debug ( \"result\" , resp = r ) or Event . parse_obj ( r ) for r in results ) return count , events me () -> Me \u00b6 Returns what Pretalx knows about myself Source code in pytanis/pretalx/client.py def me ( self ) -> Me : \"\"\"Returns what Pretalx knows about myself\"\"\" result = self . _get_one ( \"/api/me\" ) return Me . parse_obj ( result ) question ( event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Question \u00b6 Returns a specific question Source code in pytanis/pretalx/client.py def question ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Question : \"\"\"Returns a specific question\"\"\" return self . _endpoint_id ( Question , event_slug , \"questions\" , id , params = params ) questions ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Question ]] \u00b6 Lists all questions and their details Source code in pytanis/pretalx/client.py def questions ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Question ]]: \"\"\"Lists all questions and their details\"\"\" return self . _endpoint_lst ( Question , event_slug , \"questions\" , params = params ) review ( event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Review \u00b6 Returns a specific review Source code in pytanis/pretalx/client.py def review ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Review : \"\"\"Returns a specific review\"\"\" return self . _endpoint_id ( Review , event_slug , \"reviews\" , id , params = params ) reviews ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Review ]] \u00b6 Lists all reviews and their details Source code in pytanis/pretalx/client.py def reviews ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Review ]]: \"\"\"Lists all reviews and their details\"\"\" return self . _endpoint_lst ( Review , event_slug , \"reviews\" , params = params ) room ( event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Room \u00b6 Returns a specific room Source code in pytanis/pretalx/client.py def room ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Room : \"\"\"Returns a specific room\"\"\" return self . _endpoint_id ( Room , event_slug , \"rooms\" , id , params = params ) rooms ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Room ]] \u00b6 Lists all rooms and their details Source code in pytanis/pretalx/client.py def rooms ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Room ]]: \"\"\"Lists all rooms and their details\"\"\" return self . _endpoint_lst ( Room , event_slug , \"rooms\" , params = params ) set_throttling ( calls : int , seconds : int ) \u00b6 Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/pretalx/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . debug ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get ) speaker ( event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Speaker \u00b6 Returns a specific speaker Source code in pytanis/pretalx/client.py def speaker ( self , event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Speaker : \"\"\"Returns a specific speaker\"\"\" return self . _endpoint_id ( Speaker , event_slug , \"speakers\" , code , params = params ) speakers ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Speaker ]] \u00b6 Lists all speakers and their details Source code in pytanis/pretalx/client.py def speakers ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Speaker ]]: \"\"\"Lists all speakers and their details\"\"\" return self . _endpoint_lst ( Speaker , event_slug , \"speakers\" , params = params ) submission ( event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Submission \u00b6 Returns a specific submission Source code in pytanis/pretalx/client.py def submission ( self , event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Submission : \"\"\"Returns a specific submission\"\"\" return self . _endpoint_id ( Submission , event_slug , \"submissions\" , code , params = params ) submissions ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Submission ]] \u00b6 Lists all submissions and their details Source code in pytanis/pretalx/client.py def submissions ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Submission ]]: \"\"\"Lists all submissions and their details\"\"\" return self . _endpoint_lst ( Submission , event_slug , \"submissions\" , params = params ) tag ( event_slug : str , tag : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tag \u00b6 Returns a specific tag Source code in pytanis/pretalx/client.py def tag ( self , event_slug : str , tag : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tag : \"\"\"Returns a specific tag\"\"\" return self . _endpoint_id ( Tag , event_slug , \"tags\" , tag , params = params ) tags ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Tag ]] \u00b6 Lists all tags and their details Source code in pytanis/pretalx/client.py def tags ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Tag ]]: \"\"\"Lists all tags and their details\"\"\" return self . _endpoint_lst ( Tag , event_slug , \"tags\" , params = params ) talk ( event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Talk \u00b6 Returns a specific talk Source code in pytanis/pretalx/client.py def talk ( self , event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Talk : \"\"\"Returns a specific talk\"\"\" return self . _endpoint_id ( Talk , event_slug , \"talks\" , code , params = params ) talks ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Talk ]] \u00b6 Lists all talks and their details Source code in pytanis/pretalx/client.py def talks ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Talk ]]: \"\"\"Lists all talks and their details\"\"\" return self . _endpoint_lst ( Talk , event_slug , \"talks\" , params = params ) reviews_as_df ( reviews : Iterable [ Review ]) -> pd . DataFrame \u00b6 Convert the reviews to a dataframe Source code in pytanis/pretalx/utils.py def reviews_as_df ( reviews : Iterable [ Review ]) -> pd . DataFrame : \"\"\"Convert the reviews to a dataframe\"\"\" df = pd . DataFrame ([ review . dict () for review in reviews ]) # make first letter of column upper-case in accordance with our convention df . rename ( columns = { col : col . title () for col in df . columns }, inplace = True ) # user is the speaker name to use for joining df . rename ( columns = { \"User\" : Col . pretalx_user , \"Score\" : Col . review_score }, inplace = True ) return df speakers_as_df ( speakers : Iterable [ Speaker ], with_questions : bool = False , question_prefix : str = 'Q: ' ) -> pd . DataFrame \u00b6 Convert speakers into a dataframe Make sure to have params={\"questions\": \"all\"} for the PretalxAPI if with_questions is True. Source code in pytanis/pretalx/utils.py def speakers_as_df ( speakers : Iterable [ Speaker ], with_questions : bool = False , question_prefix : str = \"Q: \" ) -> pd . DataFrame : \"\"\"Convert speakers into a dataframe Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True. \"\"\" rows = [] for speaker in speakers : row = { Col . speaker_code : speaker . code , Col . speaker_name : speaker . name , Col . email : speaker . email , Col . biography : speaker . biography , Col . submission : speaker . submissions , } if with_questions and speaker . answers is not None : for answer in speaker . answers : # The API returns also questions that are 'per proposal/submission', we get these using the # submission endpoint and don't want them here due to ambiguity if several submission were made. if answer . person is not None : row [ f \" { question_prefix }{ answer . question . question . en } \" ] = answer . answer rows . append ( row ) return pd . DataFrame ( rows ) subs_as_df ( subs : Iterable [ Submission ], with_questions : bool = False , question_prefix : str = 'Q: ' ) -> pd . DataFrame \u00b6 Convert submissions into a dataframe Make sure to have params={\"questions\": \"all\"} for the PretalxAPI if with_questions is True. Source code in pytanis/pretalx/utils.py def subs_as_df ( subs : Iterable [ Submission ], with_questions : bool = False , question_prefix : str = \"Q: \" ) -> pd . DataFrame : \"\"\"Convert submissions into a dataframe Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True. \"\"\" rows = [] for sub in subs : row = { Col . submission : sub . code , Col . title : sub . title , Col . track : sub . track . en if sub . track else None , Col . speaker_code : [ speaker . code for speaker in sub . speakers ], Col . speaker_name : [ speaker . name for speaker in sub . speakers ], Col . duration : sub . duration , Col . submission_type : sub . submission_type . en , Col . submission_type_id : sub . submission_type_id , Col . state : sub . state , Col . pending_state : sub . pending_state , Col . created : sub . created , } if with_questions and sub . answers is not None : for answer in sub . answers : row [ f \" { question_prefix }{ answer . question . question . en } \" ] = answer . answer rows . append ( row ) return pd . DataFrame ( rows )","title":"pretalx"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx","text":"Functionality around the Pretalx API","title":"pretalx"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.__all__","text":"","title":"__all__"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient","text":"Client for the Pretalx API Source code in pytanis/pretalx/client.py def __init__ ( self , config : Optional [ Config ] = None , blocking : bool = False ): if config is None : config = get_cfg () self . _config = config self . _get_throttled = self . _get self . blocking = blocking self . set_throttling ( 1 , 2 ) # we are nice by default","title":"PretalxClient"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.blocking","text":"","title":"blocking"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.answer","text":"Returns a specific answer Source code in pytanis/pretalx/client.py def answer ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Answer : \"\"\"Returns a specific answer\"\"\" return self . _endpoint_id ( Answer , event_slug , \"answers\" , id , params = params )","title":"answer()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.answers","text":"Lists all answers and their details Source code in pytanis/pretalx/client.py def answers ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Answer ]]: \"\"\"Lists all answers and their details\"\"\" return self . _endpoint_lst ( Answer , event_slug , \"answers\" , params = params )","title":"answers()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.event","text":"Returns detailed information about a specific event Source code in pytanis/pretalx/client.py def event ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Event : \"\"\"Returns detailed information about a specific event\"\"\" endpoint = f \"/api/events/ { event_slug } /\" result = self . _get_one ( endpoint , params ) _logger . debug ( \"result\" , resp = result ) return Event . parse_obj ( result )","title":"event()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.events","text":"Lists all events and their details Source code in pytanis/pretalx/client.py def events ( self , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Event ]]: \"\"\"Lists all events and their details\"\"\" count , results = self . _get_many ( \"/api/events/\" , params ) events = iter ( _logger . debug ( \"result\" , resp = r ) or Event . parse_obj ( r ) for r in results ) return count , events","title":"events()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.me","text":"Returns what Pretalx knows about myself Source code in pytanis/pretalx/client.py def me ( self ) -> Me : \"\"\"Returns what Pretalx knows about myself\"\"\" result = self . _get_one ( \"/api/me\" ) return Me . parse_obj ( result )","title":"me()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.question","text":"Returns a specific question Source code in pytanis/pretalx/client.py def question ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Question : \"\"\"Returns a specific question\"\"\" return self . _endpoint_id ( Question , event_slug , \"questions\" , id , params = params )","title":"question()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.questions","text":"Lists all questions and their details Source code in pytanis/pretalx/client.py def questions ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Question ]]: \"\"\"Lists all questions and their details\"\"\" return self . _endpoint_lst ( Question , event_slug , \"questions\" , params = params )","title":"questions()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.review","text":"Returns a specific review Source code in pytanis/pretalx/client.py def review ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Review : \"\"\"Returns a specific review\"\"\" return self . _endpoint_id ( Review , event_slug , \"reviews\" , id , params = params )","title":"review()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.reviews","text":"Lists all reviews and their details Source code in pytanis/pretalx/client.py def reviews ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Review ]]: \"\"\"Lists all reviews and their details\"\"\" return self . _endpoint_lst ( Review , event_slug , \"reviews\" , params = params )","title":"reviews()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.room","text":"Returns a specific room Source code in pytanis/pretalx/client.py def room ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Room : \"\"\"Returns a specific room\"\"\" return self . _endpoint_id ( Room , event_slug , \"rooms\" , id , params = params )","title":"room()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.rooms","text":"Lists all rooms and their details Source code in pytanis/pretalx/client.py def rooms ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Room ]]: \"\"\"Lists all rooms and their details\"\"\" return self . _endpoint_lst ( Room , event_slug , \"rooms\" , params = params )","title":"rooms()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.set_throttling","text":"Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/pretalx/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . debug ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get )","title":"set_throttling()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.speaker","text":"Returns a specific speaker Source code in pytanis/pretalx/client.py def speaker ( self , event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Speaker : \"\"\"Returns a specific speaker\"\"\" return self . _endpoint_id ( Speaker , event_slug , \"speakers\" , code , params = params )","title":"speaker()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.speakers","text":"Lists all speakers and their details Source code in pytanis/pretalx/client.py def speakers ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Speaker ]]: \"\"\"Lists all speakers and their details\"\"\" return self . _endpoint_lst ( Speaker , event_slug , \"speakers\" , params = params )","title":"speakers()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.submission","text":"Returns a specific submission Source code in pytanis/pretalx/client.py def submission ( self , event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Submission : \"\"\"Returns a specific submission\"\"\" return self . _endpoint_id ( Submission , event_slug , \"submissions\" , code , params = params )","title":"submission()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.submissions","text":"Lists all submissions and their details Source code in pytanis/pretalx/client.py def submissions ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Submission ]]: \"\"\"Lists all submissions and their details\"\"\" return self . _endpoint_lst ( Submission , event_slug , \"submissions\" , params = params )","title":"submissions()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.tag","text":"Returns a specific tag Source code in pytanis/pretalx/client.py def tag ( self , event_slug : str , tag : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tag : \"\"\"Returns a specific tag\"\"\" return self . _endpoint_id ( Tag , event_slug , \"tags\" , tag , params = params )","title":"tag()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.tags","text":"Lists all tags and their details Source code in pytanis/pretalx/client.py def tags ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Tag ]]: \"\"\"Lists all tags and their details\"\"\" return self . _endpoint_lst ( Tag , event_slug , \"tags\" , params = params )","title":"tags()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.talk","text":"Returns a specific talk Source code in pytanis/pretalx/client.py def talk ( self , event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Talk : \"\"\"Returns a specific talk\"\"\" return self . _endpoint_id ( Talk , event_slug , \"talks\" , code , params = params )","title":"talk()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.talks","text":"Lists all talks and their details Source code in pytanis/pretalx/client.py def talks ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Talk ]]: \"\"\"Lists all talks and their details\"\"\" return self . _endpoint_lst ( Talk , event_slug , \"talks\" , params = params )","title":"talks()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.reviews_as_df","text":"Convert the reviews to a dataframe Source code in pytanis/pretalx/utils.py def reviews_as_df ( reviews : Iterable [ Review ]) -> pd . DataFrame : \"\"\"Convert the reviews to a dataframe\"\"\" df = pd . DataFrame ([ review . dict () for review in reviews ]) # make first letter of column upper-case in accordance with our convention df . rename ( columns = { col : col . title () for col in df . columns }, inplace = True ) # user is the speaker name to use for joining df . rename ( columns = { \"User\" : Col . pretalx_user , \"Score\" : Col . review_score }, inplace = True ) return df","title":"reviews_as_df()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.speakers_as_df","text":"Convert speakers into a dataframe Make sure to have params={\"questions\": \"all\"} for the PretalxAPI if with_questions is True. Source code in pytanis/pretalx/utils.py def speakers_as_df ( speakers : Iterable [ Speaker ], with_questions : bool = False , question_prefix : str = \"Q: \" ) -> pd . DataFrame : \"\"\"Convert speakers into a dataframe Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True. \"\"\" rows = [] for speaker in speakers : row = { Col . speaker_code : speaker . code , Col . speaker_name : speaker . name , Col . email : speaker . email , Col . biography : speaker . biography , Col . submission : speaker . submissions , } if with_questions and speaker . answers is not None : for answer in speaker . answers : # The API returns also questions that are 'per proposal/submission', we get these using the # submission endpoint and don't want them here due to ambiguity if several submission were made. if answer . person is not None : row [ f \" { question_prefix }{ answer . question . question . en } \" ] = answer . answer rows . append ( row ) return pd . DataFrame ( rows )","title":"speakers_as_df()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.subs_as_df","text":"Convert submissions into a dataframe Make sure to have params={\"questions\": \"all\"} for the PretalxAPI if with_questions is True. Source code in pytanis/pretalx/utils.py def subs_as_df ( subs : Iterable [ Submission ], with_questions : bool = False , question_prefix : str = \"Q: \" ) -> pd . DataFrame : \"\"\"Convert submissions into a dataframe Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True. \"\"\" rows = [] for sub in subs : row = { Col . submission : sub . code , Col . title : sub . title , Col . track : sub . track . en if sub . track else None , Col . speaker_code : [ speaker . code for speaker in sub . speakers ], Col . speaker_name : [ speaker . name for speaker in sub . speakers ], Col . duration : sub . duration , Col . submission_type : sub . submission_type . en , Col . submission_type_id : sub . submission_type_id , Col . state : sub . state , Col . pending_state : sub . pending_state , Col . created : sub . created , } if with_questions and sub . answers is not None : for answer in sub . answers : row [ f \" { question_prefix }{ answer . question . question . en } \" ] = answer . answer rows . append ( row ) return pd . DataFrame ( rows )","title":"subs_as_df()"},{"location":"reference/pytanis/pretalx/client/","text":"client \u00b6 Client for the Pretalx API Documentation: https://docs.pretalx.org/api/resources/index.html ToDo add additional parameters explicitly like querying according to the API JSON = Union [ JSONObj , JSONLst ] module-attribute \u00b6 Type of the JSON response as returned by the Pretalx API JSONLst = List [ JSONObj ] module-attribute \u00b6 Type of a JSON list of JSON objects JSONObj = Dict [ str , Any ] module-attribute \u00b6 Type of a JSON object (without recursion) T = TypeVar ( 'T' , bound = BaseModel ) module-attribute \u00b6 PretalxClient ( config : Optional [ Config ] = None , blocking : bool = False ) \u00b6 Client for the Pretalx API Source code in pytanis/pretalx/client.py def __init__ ( self , config : Optional [ Config ] = None , blocking : bool = False ): if config is None : config = get_cfg () self . _config = config self . _get_throttled = self . _get self . blocking = blocking self . set_throttling ( 1 , 2 ) # we are nice by default blocking = blocking instance-attribute \u00b6 answer ( event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Answer \u00b6 Returns a specific answer Source code in pytanis/pretalx/client.py def answer ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Answer : \"\"\"Returns a specific answer\"\"\" return self . _endpoint_id ( Answer , event_slug , \"answers\" , id , params = params ) answers ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Answer ]] \u00b6 Lists all answers and their details Source code in pytanis/pretalx/client.py def answers ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Answer ]]: \"\"\"Lists all answers and their details\"\"\" return self . _endpoint_lst ( Answer , event_slug , \"answers\" , params = params ) event ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Event \u00b6 Returns detailed information about a specific event Source code in pytanis/pretalx/client.py def event ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Event : \"\"\"Returns detailed information about a specific event\"\"\" endpoint = f \"/api/events/ { event_slug } /\" result = self . _get_one ( endpoint , params ) _logger . debug ( \"result\" , resp = result ) return Event . parse_obj ( result ) events ( * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Event ]] \u00b6 Lists all events and their details Source code in pytanis/pretalx/client.py def events ( self , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Event ]]: \"\"\"Lists all events and their details\"\"\" count , results = self . _get_many ( \"/api/events/\" , params ) events = iter ( _logger . debug ( \"result\" , resp = r ) or Event . parse_obj ( r ) for r in results ) return count , events me () -> Me \u00b6 Returns what Pretalx knows about myself Source code in pytanis/pretalx/client.py def me ( self ) -> Me : \"\"\"Returns what Pretalx knows about myself\"\"\" result = self . _get_one ( \"/api/me\" ) return Me . parse_obj ( result ) question ( event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Question \u00b6 Returns a specific question Source code in pytanis/pretalx/client.py def question ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Question : \"\"\"Returns a specific question\"\"\" return self . _endpoint_id ( Question , event_slug , \"questions\" , id , params = params ) questions ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Question ]] \u00b6 Lists all questions and their details Source code in pytanis/pretalx/client.py def questions ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Question ]]: \"\"\"Lists all questions and their details\"\"\" return self . _endpoint_lst ( Question , event_slug , \"questions\" , params = params ) review ( event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Review \u00b6 Returns a specific review Source code in pytanis/pretalx/client.py def review ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Review : \"\"\"Returns a specific review\"\"\" return self . _endpoint_id ( Review , event_slug , \"reviews\" , id , params = params ) reviews ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Review ]] \u00b6 Lists all reviews and their details Source code in pytanis/pretalx/client.py def reviews ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Review ]]: \"\"\"Lists all reviews and their details\"\"\" return self . _endpoint_lst ( Review , event_slug , \"reviews\" , params = params ) room ( event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Room \u00b6 Returns a specific room Source code in pytanis/pretalx/client.py def room ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Room : \"\"\"Returns a specific room\"\"\" return self . _endpoint_id ( Room , event_slug , \"rooms\" , id , params = params ) rooms ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Room ]] \u00b6 Lists all rooms and their details Source code in pytanis/pretalx/client.py def rooms ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Room ]]: \"\"\"Lists all rooms and their details\"\"\" return self . _endpoint_lst ( Room , event_slug , \"rooms\" , params = params ) set_throttling ( calls : int , seconds : int ) \u00b6 Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/pretalx/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . debug ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get ) speaker ( event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Speaker \u00b6 Returns a specific speaker Source code in pytanis/pretalx/client.py def speaker ( self , event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Speaker : \"\"\"Returns a specific speaker\"\"\" return self . _endpoint_id ( Speaker , event_slug , \"speakers\" , code , params = params ) speakers ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Speaker ]] \u00b6 Lists all speakers and their details Source code in pytanis/pretalx/client.py def speakers ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Speaker ]]: \"\"\"Lists all speakers and their details\"\"\" return self . _endpoint_lst ( Speaker , event_slug , \"speakers\" , params = params ) submission ( event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Submission \u00b6 Returns a specific submission Source code in pytanis/pretalx/client.py def submission ( self , event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Submission : \"\"\"Returns a specific submission\"\"\" return self . _endpoint_id ( Submission , event_slug , \"submissions\" , code , params = params ) submissions ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Submission ]] \u00b6 Lists all submissions and their details Source code in pytanis/pretalx/client.py def submissions ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Submission ]]: \"\"\"Lists all submissions and their details\"\"\" return self . _endpoint_lst ( Submission , event_slug , \"submissions\" , params = params ) tag ( event_slug : str , tag : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tag \u00b6 Returns a specific tag Source code in pytanis/pretalx/client.py def tag ( self , event_slug : str , tag : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tag : \"\"\"Returns a specific tag\"\"\" return self . _endpoint_id ( Tag , event_slug , \"tags\" , tag , params = params ) tags ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Tag ]] \u00b6 Lists all tags and their details Source code in pytanis/pretalx/client.py def tags ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Tag ]]: \"\"\"Lists all tags and their details\"\"\" return self . _endpoint_lst ( Tag , event_slug , \"tags\" , params = params ) talk ( event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Talk \u00b6 Returns a specific talk Source code in pytanis/pretalx/client.py def talk ( self , event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Talk : \"\"\"Returns a specific talk\"\"\" return self . _endpoint_id ( Talk , event_slug , \"talks\" , code , params = params ) talks ( event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Talk ]] \u00b6 Lists all talks and their details Source code in pytanis/pretalx/client.py def talks ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Talk ]]: \"\"\"Lists all talks and their details\"\"\" return self . _endpoint_lst ( Talk , event_slug , \"talks\" , params = params )","title":"client"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client","text":"Client for the Pretalx API Documentation: https://docs.pretalx.org/api/resources/index.html ToDo add additional parameters explicitly like querying according to the API","title":"client"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.JSON","text":"Type of the JSON response as returned by the Pretalx API","title":"JSON"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.JSONLst","text":"Type of a JSON list of JSON objects","title":"JSONLst"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.JSONObj","text":"Type of a JSON object (without recursion)","title":"JSONObj"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.T","text":"","title":"T"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient","text":"Client for the Pretalx API Source code in pytanis/pretalx/client.py def __init__ ( self , config : Optional [ Config ] = None , blocking : bool = False ): if config is None : config = get_cfg () self . _config = config self . _get_throttled = self . _get self . blocking = blocking self . set_throttling ( 1 , 2 ) # we are nice by default","title":"PretalxClient"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.blocking","text":"","title":"blocking"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.answer","text":"Returns a specific answer Source code in pytanis/pretalx/client.py def answer ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Answer : \"\"\"Returns a specific answer\"\"\" return self . _endpoint_id ( Answer , event_slug , \"answers\" , id , params = params )","title":"answer()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.answers","text":"Lists all answers and their details Source code in pytanis/pretalx/client.py def answers ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Answer ]]: \"\"\"Lists all answers and their details\"\"\" return self . _endpoint_lst ( Answer , event_slug , \"answers\" , params = params )","title":"answers()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.event","text":"Returns detailed information about a specific event Source code in pytanis/pretalx/client.py def event ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Event : \"\"\"Returns detailed information about a specific event\"\"\" endpoint = f \"/api/events/ { event_slug } /\" result = self . _get_one ( endpoint , params ) _logger . debug ( \"result\" , resp = result ) return Event . parse_obj ( result )","title":"event()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.events","text":"Lists all events and their details Source code in pytanis/pretalx/client.py def events ( self , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Event ]]: \"\"\"Lists all events and their details\"\"\" count , results = self . _get_many ( \"/api/events/\" , params ) events = iter ( _logger . debug ( \"result\" , resp = r ) or Event . parse_obj ( r ) for r in results ) return count , events","title":"events()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.me","text":"Returns what Pretalx knows about myself Source code in pytanis/pretalx/client.py def me ( self ) -> Me : \"\"\"Returns what Pretalx knows about myself\"\"\" result = self . _get_one ( \"/api/me\" ) return Me . parse_obj ( result )","title":"me()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.question","text":"Returns a specific question Source code in pytanis/pretalx/client.py def question ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Question : \"\"\"Returns a specific question\"\"\" return self . _endpoint_id ( Question , event_slug , \"questions\" , id , params = params )","title":"question()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.questions","text":"Lists all questions and their details Source code in pytanis/pretalx/client.py def questions ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Question ]]: \"\"\"Lists all questions and their details\"\"\" return self . _endpoint_lst ( Question , event_slug , \"questions\" , params = params )","title":"questions()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.review","text":"Returns a specific review Source code in pytanis/pretalx/client.py def review ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Review : \"\"\"Returns a specific review\"\"\" return self . _endpoint_id ( Review , event_slug , \"reviews\" , id , params = params )","title":"review()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.reviews","text":"Lists all reviews and their details Source code in pytanis/pretalx/client.py def reviews ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Review ]]: \"\"\"Lists all reviews and their details\"\"\" return self . _endpoint_lst ( Review , event_slug , \"reviews\" , params = params )","title":"reviews()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.room","text":"Returns a specific room Source code in pytanis/pretalx/client.py def room ( self , event_slug : str , id : int , * , params : Optional [ Dict [ str , str ]] = None ) -> Room : \"\"\"Returns a specific room\"\"\" return self . _endpoint_id ( Room , event_slug , \"rooms\" , id , params = params )","title":"room()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.rooms","text":"Lists all rooms and their details Source code in pytanis/pretalx/client.py def rooms ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Room ]]: \"\"\"Lists all rooms and their details\"\"\" return self . _endpoint_lst ( Room , event_slug , \"rooms\" , params = params )","title":"rooms()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.set_throttling","text":"Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/pretalx/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . debug ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get )","title":"set_throttling()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.speaker","text":"Returns a specific speaker Source code in pytanis/pretalx/client.py def speaker ( self , event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Speaker : \"\"\"Returns a specific speaker\"\"\" return self . _endpoint_id ( Speaker , event_slug , \"speakers\" , code , params = params )","title":"speaker()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.speakers","text":"Lists all speakers and their details Source code in pytanis/pretalx/client.py def speakers ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Speaker ]]: \"\"\"Lists all speakers and their details\"\"\" return self . _endpoint_lst ( Speaker , event_slug , \"speakers\" , params = params )","title":"speakers()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.submission","text":"Returns a specific submission Source code in pytanis/pretalx/client.py def submission ( self , event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Submission : \"\"\"Returns a specific submission\"\"\" return self . _endpoint_id ( Submission , event_slug , \"submissions\" , code , params = params )","title":"submission()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.submissions","text":"Lists all submissions and their details Source code in pytanis/pretalx/client.py def submissions ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Submission ]]: \"\"\"Lists all submissions and their details\"\"\" return self . _endpoint_lst ( Submission , event_slug , \"submissions\" , params = params )","title":"submissions()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.tag","text":"Returns a specific tag Source code in pytanis/pretalx/client.py def tag ( self , event_slug : str , tag : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tag : \"\"\"Returns a specific tag\"\"\" return self . _endpoint_id ( Tag , event_slug , \"tags\" , tag , params = params )","title":"tag()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.tags","text":"Lists all tags and their details Source code in pytanis/pretalx/client.py def tags ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Tag ]]: \"\"\"Lists all tags and their details\"\"\" return self . _endpoint_lst ( Tag , event_slug , \"tags\" , params = params )","title":"tags()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.talk","text":"Returns a specific talk Source code in pytanis/pretalx/client.py def talk ( self , event_slug : str , code : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Talk : \"\"\"Returns a specific talk\"\"\" return self . _endpoint_id ( Talk , event_slug , \"talks\" , code , params = params )","title":"talk()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.talks","text":"Lists all talks and their details Source code in pytanis/pretalx/client.py def talks ( self , event_slug : str , * , params : Optional [ Dict [ str , str ]] = None ) -> Tuple [ int , Iterator [ Talk ]]: \"\"\"Lists all talks and their details\"\"\" return self . _endpoint_lst ( Talk , event_slug , \"talks\" , params = params )","title":"talks()"},{"location":"reference/pytanis/pretalx/types/","text":"types \u00b6 Return types of the Pretalx API Documentation: https://docs.pretalx.org/api/resources/index.html Attention: Quite often the API docs and the actual results of the API differ! ToDo Find out why extra=Extra.allow causes mypy to fail. Seems like a bug in pydantic. Answer \u00b6 answer : str class-attribute \u00b6 answer_file : Optional [ str ] class-attribute \u00b6 id : int class-attribute \u00b6 options : List [ Option ] class-attribute \u00b6 person : Optional [ str ] class-attribute \u00b6 question : AnswerQuestionRef class-attribute \u00b6 review : Optional [ int ] class-attribute \u00b6 submission : Optional [ str ] class-attribute \u00b6 AnswerQuestionRef \u00b6 id : int class-attribute \u00b6 question : MultiLingualStr class-attribute \u00b6 Event \u00b6 date_from : date class-attribute \u00b6 date_to : Optional [ date ] class-attribute \u00b6 is_public : bool class-attribute \u00b6 name : MultiLingualStr class-attribute \u00b6 slug : str class-attribute \u00b6 timezone : str class-attribute \u00b6 urls : URLs class-attribute \u00b6 Me \u00b6 email : str class-attribute \u00b6 local : Optional [ str ] class-attribute \u00b6 name : str class-attribute \u00b6 timezone : str class-attribute \u00b6 MultiLingualStr \u00b6 de : Optional [ str ] class-attribute \u00b6 en : Optional [ str ] class-attribute \u00b6 Option \u00b6 answer : MultiLingualStr class-attribute \u00b6 id : int class-attribute \u00b6 Question \u00b6 contains_personal_data : bool class-attribute \u00b6 deadline : Optional [ datetime ] class-attribute \u00b6 default_answer : Optional [ str ] class-attribute \u00b6 freeze_after : Optional [ datetime ] class-attribute \u00b6 help_text : MultiLingualStr class-attribute \u00b6 id : int class-attribute \u00b6 is_public : bool class-attribute \u00b6 is_visible_to_reviewers : bool class-attribute \u00b6 max_length : Optional [ int ] class-attribute \u00b6 min_length : Optional [ int ] class-attribute \u00b6 options : List [ Option ] class-attribute \u00b6 question : MultiLingualStr class-attribute \u00b6 question_required : str class-attribute \u00b6 read_only : Optional [ bool ] class-attribute \u00b6 required : bool class-attribute \u00b6 target : str class-attribute \u00b6 variant : str class-attribute \u00b6 Resource \u00b6 description : str class-attribute \u00b6 resource : str class-attribute \u00b6 Review \u00b6 answers : List [ str ] class-attribute \u00b6 created : datetime class-attribute \u00b6 id : int class-attribute \u00b6 score : Optional [ float ] class-attribute \u00b6 submission : str class-attribute \u00b6 text : Optional [ str ] class-attribute \u00b6 updated : datetime class-attribute \u00b6 user : str class-attribute \u00b6 Room \u00b6 availabilities : Optional [ List [ RoomAvailability ]] class-attribute \u00b6 capacity : Optional [ int ] class-attribute \u00b6 description : MultiLingualStr class-attribute \u00b6 id : int class-attribute \u00b6 name : MultiLingualStr class-attribute \u00b6 position : Optional [ int ] class-attribute \u00b6 speaker_info : Optional [ MultiLingualStr ] class-attribute \u00b6 RoomAvailability \u00b6 end : datetime class-attribute \u00b6 start : datetime class-attribute \u00b6 Slot \u00b6 end : str class-attribute \u00b6 room : MultiLingualStr class-attribute \u00b6 room_id : int class-attribute \u00b6 start : str class-attribute \u00b6 Speaker \u00b6 answers : Optional [ List [ Answer ]] class-attribute \u00b6 availabilities : Optional [ List [ SpeakerAvailability ]] class-attribute \u00b6 submissions : List [ str ] class-attribute \u00b6 SpeakerAvailability \u00b6 allDay : str = Field ( Ellipsis , alias = 'all_day' ) class-attribute \u00b6 end : str class-attribute \u00b6 id : int class-attribute \u00b6 start : str class-attribute \u00b6 Submission \u00b6 abstract : str class-attribute \u00b6 answers : Optional [ List [ Answer ]] class-attribute \u00b6 code : str class-attribute \u00b6 content_locale : str class-attribute \u00b6 created : Optional [ datetime ] class-attribute \u00b6 description : str class-attribute \u00b6 do_not_record : bool class-attribute \u00b6 duration : Optional [ int ] class-attribute \u00b6 image : Optional [ str ] class-attribute \u00b6 internal_notes : Optional [ str ] class-attribute \u00b6 is_featured : bool class-attribute \u00b6 notes : Optional [ str ] class-attribute \u00b6 pending_state : Optional [ str ] class-attribute \u00b6 resources : List [ Resource ] class-attribute \u00b6 slot : Optional [ Slot ] class-attribute \u00b6 slot_count : int class-attribute \u00b6 speakers : List [ SubmissionSpeaker ] class-attribute \u00b6 state : str class-attribute \u00b6 submission_type : MultiLingualStr class-attribute \u00b6 submission_type_id : int class-attribute \u00b6 tag_ids : Optional [ List [ int ]] class-attribute \u00b6 tags : Optional [ List [ str ]] class-attribute \u00b6 title : str class-attribute \u00b6 track : Optional [ MultiLingualStr ] class-attribute \u00b6 track_id : Optional [ int ] class-attribute \u00b6 SubmissionSpeaker \u00b6 avatar : Optional [ str ] class-attribute \u00b6 biography : Optional [ str ] class-attribute \u00b6 code : str class-attribute \u00b6 email : Optional [ str ] class-attribute \u00b6 name : str class-attribute \u00b6 Tag \u00b6 color : str class-attribute \u00b6 description : MultiLingualStr class-attribute \u00b6 tag : str class-attribute \u00b6 Talk \u00b6 URLs \u00b6 base : str class-attribute \u00b6 feed : str class-attribute \u00b6 login : str class-attribute \u00b6 schedule : str class-attribute \u00b6 User \u00b6 email : str class-attribute \u00b6 name : str class-attribute \u00b6","title":"types"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types","text":"Return types of the Pretalx API Documentation: https://docs.pretalx.org/api/resources/index.html Attention: Quite often the API docs and the actual results of the API differ! ToDo Find out why extra=Extra.allow causes mypy to fail. Seems like a bug in pydantic.","title":"types"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Answer","text":"","title":"Answer"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Answer.answer","text":"","title":"answer"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Answer.answer_file","text":"","title":"answer_file"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Answer.id","text":"","title":"id"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Answer.options","text":"","title":"options"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Answer.person","text":"","title":"person"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Answer.question","text":"","title":"question"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Answer.review","text":"","title":"review"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Answer.submission","text":"","title":"submission"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.AnswerQuestionRef","text":"","title":"AnswerQuestionRef"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.AnswerQuestionRef.id","text":"","title":"id"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.AnswerQuestionRef.question","text":"","title":"question"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Event","text":"","title":"Event"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Event.date_from","text":"","title":"date_from"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Event.date_to","text":"","title":"date_to"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Event.is_public","text":"","title":"is_public"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Event.name","text":"","title":"name"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Event.slug","text":"","title":"slug"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Event.timezone","text":"","title":"timezone"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Event.urls","text":"","title":"urls"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Me","text":"","title":"Me"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Me.email","text":"","title":"email"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Me.local","text":"","title":"local"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Me.name","text":"","title":"name"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Me.timezone","text":"","title":"timezone"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.MultiLingualStr","text":"","title":"MultiLingualStr"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.MultiLingualStr.de","text":"","title":"de"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.MultiLingualStr.en","text":"","title":"en"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Option","text":"","title":"Option"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Option.answer","text":"","title":"answer"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Option.id","text":"","title":"id"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question","text":"","title":"Question"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.contains_personal_data","text":"","title":"contains_personal_data"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.deadline","text":"","title":"deadline"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.default_answer","text":"","title":"default_answer"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.freeze_after","text":"","title":"freeze_after"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.help_text","text":"","title":"help_text"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.id","text":"","title":"id"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.is_public","text":"","title":"is_public"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.is_visible_to_reviewers","text":"","title":"is_visible_to_reviewers"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.max_length","text":"","title":"max_length"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.min_length","text":"","title":"min_length"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.options","text":"","title":"options"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.question","text":"","title":"question"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.question_required","text":"","title":"question_required"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.read_only","text":"","title":"read_only"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.required","text":"","title":"required"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.target","text":"","title":"target"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.variant","text":"","title":"variant"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Resource","text":"","title":"Resource"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Resource.description","text":"","title":"description"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Resource.resource","text":"","title":"resource"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Review","text":"","title":"Review"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Review.answers","text":"","title":"answers"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Review.created","text":"","title":"created"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Review.id","text":"","title":"id"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Review.score","text":"","title":"score"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Review.submission","text":"","title":"submission"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Review.text","text":"","title":"text"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Review.updated","text":"","title":"updated"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Review.user","text":"","title":"user"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Room","text":"","title":"Room"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Room.availabilities","text":"","title":"availabilities"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Room.capacity","text":"","title":"capacity"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Room.description","text":"","title":"description"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Room.id","text":"","title":"id"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Room.name","text":"","title":"name"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Room.position","text":"","title":"position"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Room.speaker_info","text":"","title":"speaker_info"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.RoomAvailability","text":"","title":"RoomAvailability"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.RoomAvailability.end","text":"","title":"end"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.RoomAvailability.start","text":"","title":"start"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Slot","text":"","title":"Slot"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Slot.end","text":"","title":"end"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Slot.room","text":"","title":"room"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Slot.room_id","text":"","title":"room_id"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Slot.start","text":"","title":"start"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Speaker","text":"","title":"Speaker"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Speaker.answers","text":"","title":"answers"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Speaker.availabilities","text":"","title":"availabilities"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Speaker.submissions","text":"","title":"submissions"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.SpeakerAvailability","text":"","title":"SpeakerAvailability"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.SpeakerAvailability.allDay","text":"","title":"allDay"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.SpeakerAvailability.end","text":"","title":"end"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.SpeakerAvailability.id","text":"","title":"id"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.SpeakerAvailability.start","text":"","title":"start"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission","text":"","title":"Submission"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.abstract","text":"","title":"abstract"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.answers","text":"","title":"answers"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.code","text":"","title":"code"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.content_locale","text":"","title":"content_locale"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.created","text":"","title":"created"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.description","text":"","title":"description"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.do_not_record","text":"","title":"do_not_record"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.duration","text":"","title":"duration"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.image","text":"","title":"image"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.internal_notes","text":"","title":"internal_notes"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.is_featured","text":"","title":"is_featured"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.notes","text":"","title":"notes"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.pending_state","text":"","title":"pending_state"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.resources","text":"","title":"resources"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.slot","text":"","title":"slot"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.slot_count","text":"","title":"slot_count"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.speakers","text":"","title":"speakers"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.state","text":"","title":"state"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.submission_type","text":"","title":"submission_type"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.submission_type_id","text":"","title":"submission_type_id"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.tag_ids","text":"","title":"tag_ids"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.tags","text":"","title":"tags"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.title","text":"","title":"title"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.track","text":"","title":"track"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.track_id","text":"","title":"track_id"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.SubmissionSpeaker","text":"","title":"SubmissionSpeaker"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.SubmissionSpeaker.avatar","text":"","title":"avatar"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.SubmissionSpeaker.biography","text":"","title":"biography"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.SubmissionSpeaker.code","text":"","title":"code"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.SubmissionSpeaker.email","text":"","title":"email"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.SubmissionSpeaker.name","text":"","title":"name"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Tag","text":"","title":"Tag"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Tag.color","text":"","title":"color"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Tag.description","text":"","title":"description"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Tag.tag","text":"","title":"tag"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Talk","text":"","title":"Talk"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.URLs","text":"","title":"URLs"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.URLs.base","text":"","title":"base"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.URLs.feed","text":"","title":"feed"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.URLs.login","text":"","title":"login"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.URLs.schedule","text":"","title":"schedule"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.User","text":"","title":"User"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.User.email","text":"","title":"email"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.User.name","text":"","title":"name"},{"location":"reference/pytanis/pretalx/utils/","text":"utils \u00b6 Utilities related to Pretalx Col \u00b6 Convention of Pretalx column names for the functions below. affiliation = 'Affiliation' class-attribute \u00b6 availability = 'Availability' class-attribute \u00b6 availability_comment = 'Availability Comment' class-attribute \u00b6 biography = 'Biography' class-attribute \u00b6 comment = 'Comment' class-attribute \u00b6 created = 'Created' class-attribute \u00b6 duration = 'Duration' class-attribute \u00b6 email = 'Email' class-attribute \u00b6 nreviews = '#Reviews' class-attribute \u00b6 pending_state = 'Pending state' class-attribute \u00b6 pretalx_user = 'Pretalx user' class-attribute \u00b6 public = 'Public' class-attribute \u00b6 review_score = 'Review Score' class-attribute \u00b6 speaker_code = 'Speaker code' class-attribute \u00b6 speaker_name = 'Speaker name' class-attribute \u00b6 state = 'State' class-attribute \u00b6 submission = 'Submission' class-attribute \u00b6 submission_type = 'Submission type' class-attribute \u00b6 submission_type_id = 'Submission type id' class-attribute \u00b6 title = 'Title' class-attribute \u00b6 track = 'Track' class-attribute \u00b6 reviews_as_df ( reviews : Iterable [ Review ]) -> pd . DataFrame \u00b6 Convert the reviews to a dataframe Source code in pytanis/pretalx/utils.py def reviews_as_df ( reviews : Iterable [ Review ]) -> pd . DataFrame : \"\"\"Convert the reviews to a dataframe\"\"\" df = pd . DataFrame ([ review . dict () for review in reviews ]) # make first letter of column upper-case in accordance with our convention df . rename ( columns = { col : col . title () for col in df . columns }, inplace = True ) # user is the speaker name to use for joining df . rename ( columns = { \"User\" : Col . pretalx_user , \"Score\" : Col . review_score }, inplace = True ) return df speakers_as_df ( speakers : Iterable [ Speaker ], with_questions : bool = False , question_prefix : str = 'Q: ' ) -> pd . DataFrame \u00b6 Convert speakers into a dataframe Make sure to have params={\"questions\": \"all\"} for the PretalxAPI if with_questions is True. Source code in pytanis/pretalx/utils.py def speakers_as_df ( speakers : Iterable [ Speaker ], with_questions : bool = False , question_prefix : str = \"Q: \" ) -> pd . DataFrame : \"\"\"Convert speakers into a dataframe Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True. \"\"\" rows = [] for speaker in speakers : row = { Col . speaker_code : speaker . code , Col . speaker_name : speaker . name , Col . email : speaker . email , Col . biography : speaker . biography , Col . submission : speaker . submissions , } if with_questions and speaker . answers is not None : for answer in speaker . answers : # The API returns also questions that are 'per proposal/submission', we get these using the # submission endpoint and don't want them here due to ambiguity if several submission were made. if answer . person is not None : row [ f \" { question_prefix }{ answer . question . question . en } \" ] = answer . answer rows . append ( row ) return pd . DataFrame ( rows ) subs_as_df ( subs : Iterable [ Submission ], with_questions : bool = False , question_prefix : str = 'Q: ' ) -> pd . DataFrame \u00b6 Convert submissions into a dataframe Make sure to have params={\"questions\": \"all\"} for the PretalxAPI if with_questions is True. Source code in pytanis/pretalx/utils.py def subs_as_df ( subs : Iterable [ Submission ], with_questions : bool = False , question_prefix : str = \"Q: \" ) -> pd . DataFrame : \"\"\"Convert submissions into a dataframe Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True. \"\"\" rows = [] for sub in subs : row = { Col . submission : sub . code , Col . title : sub . title , Col . track : sub . track . en if sub . track else None , Col . speaker_code : [ speaker . code for speaker in sub . speakers ], Col . speaker_name : [ speaker . name for speaker in sub . speakers ], Col . duration : sub . duration , Col . submission_type : sub . submission_type . en , Col . submission_type_id : sub . submission_type_id , Col . state : sub . state , Col . pending_state : sub . pending_state , Col . created : sub . created , } if with_questions and sub . answers is not None : for answer in sub . answers : row [ f \" { question_prefix }{ answer . question . question . en } \" ] = answer . answer rows . append ( row ) return pd . DataFrame ( rows )","title":"utils"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils","text":"Utilities related to Pretalx","title":"utils"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col","text":"Convention of Pretalx column names for the functions below.","title":"Col"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.affiliation","text":"","title":"affiliation"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.availability","text":"","title":"availability"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.availability_comment","text":"","title":"availability_comment"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.biography","text":"","title":"biography"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.comment","text":"","title":"comment"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.created","text":"","title":"created"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.duration","text":"","title":"duration"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.email","text":"","title":"email"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.nreviews","text":"","title":"nreviews"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.pending_state","text":"","title":"pending_state"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.pretalx_user","text":"","title":"pretalx_user"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.public","text":"","title":"public"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.review_score","text":"","title":"review_score"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.speaker_code","text":"","title":"speaker_code"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.speaker_name","text":"","title":"speaker_name"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.state","text":"","title":"state"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.submission","text":"","title":"submission"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.submission_type","text":"","title":"submission_type"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.submission_type_id","text":"","title":"submission_type_id"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.title","text":"","title":"title"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.track","text":"","title":"track"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.reviews_as_df","text":"Convert the reviews to a dataframe Source code in pytanis/pretalx/utils.py def reviews_as_df ( reviews : Iterable [ Review ]) -> pd . DataFrame : \"\"\"Convert the reviews to a dataframe\"\"\" df = pd . DataFrame ([ review . dict () for review in reviews ]) # make first letter of column upper-case in accordance with our convention df . rename ( columns = { col : col . title () for col in df . columns }, inplace = True ) # user is the speaker name to use for joining df . rename ( columns = { \"User\" : Col . pretalx_user , \"Score\" : Col . review_score }, inplace = True ) return df","title":"reviews_as_df()"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.speakers_as_df","text":"Convert speakers into a dataframe Make sure to have params={\"questions\": \"all\"} for the PretalxAPI if with_questions is True. Source code in pytanis/pretalx/utils.py def speakers_as_df ( speakers : Iterable [ Speaker ], with_questions : bool = False , question_prefix : str = \"Q: \" ) -> pd . DataFrame : \"\"\"Convert speakers into a dataframe Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True. \"\"\" rows = [] for speaker in speakers : row = { Col . speaker_code : speaker . code , Col . speaker_name : speaker . name , Col . email : speaker . email , Col . biography : speaker . biography , Col . submission : speaker . submissions , } if with_questions and speaker . answers is not None : for answer in speaker . answers : # The API returns also questions that are 'per proposal/submission', we get these using the # submission endpoint and don't want them here due to ambiguity if several submission were made. if answer . person is not None : row [ f \" { question_prefix }{ answer . question . question . en } \" ] = answer . answer rows . append ( row ) return pd . DataFrame ( rows )","title":"speakers_as_df()"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.subs_as_df","text":"Convert submissions into a dataframe Make sure to have params={\"questions\": \"all\"} for the PretalxAPI if with_questions is True. Source code in pytanis/pretalx/utils.py def subs_as_df ( subs : Iterable [ Submission ], with_questions : bool = False , question_prefix : str = \"Q: \" ) -> pd . DataFrame : \"\"\"Convert submissions into a dataframe Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True. \"\"\" rows = [] for sub in subs : row = { Col . submission : sub . code , Col . title : sub . title , Col . track : sub . track . en if sub . track else None , Col . speaker_code : [ speaker . code for speaker in sub . speakers ], Col . speaker_name : [ speaker . name for speaker in sub . speakers ], Col . duration : sub . duration , Col . submission_type : sub . submission_type . en , Col . submission_type_id : sub . submission_type_id , Col . state : sub . state , Col . pending_state : sub . pending_state , Col . created : sub . created , } if with_questions and sub . answers is not None : for answer in sub . answers : row [ f \" { question_prefix }{ answer . question . question . en } \" ] = answer . answer rows . append ( row ) return pd . DataFrame ( rows )","title":"subs_as_df()"},{"location":"usage/installation/","text":"To install Pytanis simple run: pip install pytanis or to install all recommended additional dependencies: pip install pytanis[all] Then create a configuration file and directory in your user's home directory. For Linux/MacOS/Unix use ~/.pytanis/config.toml and for Windows $HOME\\.pytanis\\config.toml , where $HOME is e.g. C:\\Users\\yourusername\\ . Use your favourite editor to open config.toml within the .pytanis directory and add the following content: [Pretalx] api_token = \"932ndsf9uk32nf9sdkn3454532nj32jn\" [Google] client_secret_json = \"client_secret.json\" token_json = \"token.json\" [HelpDesk] account = \"934jcjkdf-39df-9df-93kf-934jfhuuij39fd\" entity_id = \"email@host.com\" token = \"dal:Sx4id934C3Y-X934jldjdfjk\" where you need to replace the dummy values in the sections [Pretalx] and [HelpDesk] accordingly. Retrieving the credentials and token \u00b6 Google : Follow the Python Quickstart for the Google API to generate and download the file client_secret.json . Move it to the ~/.pytanis folder as client_secret.json . The file token.json will be automatically generated later. Note that config.toml references those two files relative to its own location. Pretalx : The API token for the Pretalx API can be found in your user settings. HelpDesk : Use the same (shared) email you use to log into HelpDesk/LiveChat to create the token following this video . In case there is any trouble with livechat, contact a helpdesk admin.","title":"Getting Started"},{"location":"usage/installation/#retrieving-the-credentials-and-token","text":"Google : Follow the Python Quickstart for the Google API to generate and download the file client_secret.json . Move it to the ~/.pytanis folder as client_secret.json . The file token.json will be automatically generated later. Note that config.toml references those two files relative to its own location. Pretalx : The API token for the Pretalx API can be found in your user settings. HelpDesk : Use the same (shared) email you use to log into HelpDesk/LiveChat to create the token following this video . In case there is any trouble with livechat, contact a helpdesk admin.","title":"Retrieving the credentials and token"},{"location":"usage/review/","text":"The Review Process \u00b6 On a high-level, the review process of the proposals for a conference works like that: 1. finding external reviewers and learning about their preferences, 2. onboarding reviewers in Pretalx , 3. assign proposals to reviewers according to their preferences, 4. communicate with the reviewers occasionally for updates, 5. track the whole process. Finding external Reviewers and learning about their preferences \u00b6 For the PyConDE / PyData Berlin 2023, we were looking for about 50 external reviewers since we expected about 400 proposals, and we wanted to have 3 reviews per proposal. This would about to 25 proposals to review per person and still manageable within a few weeks if you schedule 5-15 minutes per proposal. To get external reviewers, we would only ask within our circle of trust and refer them to some Google Forms . This basically consisted of following questions with descriptions: Name [short answer]: Please write your name starting with your first name, e.g. Albert Einstein. Affiliation [short answer]: Please state the name or organisation you are affiliated with. Who do you know from the Committee? [short answer]: We believe in the ring of trust model. With this question, we really only want to make sure that not random people sign up with no connection to any member of the Program Committee at all. Availability during the Review Period [checkboxes]: The bulk of the review work will take place from January 5 th to February 13 th , 2023, so it is important that you are broadly available during this period. That being said, you will be quite flexible in managing your time but being on vacation with no internet for 3 weeks might be suboptimal here ;-) There was only one mandatory checkbox: Yes, I am broadly available during this period. Additional comments regarding your availability during the review period. [long answer] Topics you want to review : These are the topics you are interested in reviewing. The more you select the better. Don't be shy, you don't have to be an expert in a topic to review a proposal. If you are interested in a topic and have some knowledge about it, you are totally up for the job :-) Each track in Pretalx corresponded to one checkbox in this form. At least 5 preferences needed to be chosen. Do you want your name to be listed as a reviewer on the conference website? [checkbox] Mandatory yes/no checkboxes Any additional comments for the Program Committee [long answer] Tip Google Form will use the separator , (comma, whitespace) for the selected checkboxes. Having the same separator in your track name, e.g. \"General: Community, Diversity, Career, Life and everything else\", will make it a bit harder to parse the resulting Google Sheet . So it's better to avoid them in track names. Every submission of the Google Form is then automatically added to a Google Sheet, which can be easily read with the help of Pytanis. Onboarding Reviewers in Pretalx \u00b6 Under Construction Mention the Pretalx feature request pretalx/pretalx#1417 , mention that username should be unique until then add question to the Form if user want additional proposals for review once their batch is done....","title":"Proposal Review"},{"location":"usage/review/#the-review-process","text":"On a high-level, the review process of the proposals for a conference works like that: 1. finding external reviewers and learning about their preferences, 2. onboarding reviewers in Pretalx , 3. assign proposals to reviewers according to their preferences, 4. communicate with the reviewers occasionally for updates, 5. track the whole process.","title":"The Review Process"},{"location":"usage/review/#finding-external-reviewers-and-learning-about-their-preferences","text":"For the PyConDE / PyData Berlin 2023, we were looking for about 50 external reviewers since we expected about 400 proposals, and we wanted to have 3 reviews per proposal. This would about to 25 proposals to review per person and still manageable within a few weeks if you schedule 5-15 minutes per proposal. To get external reviewers, we would only ask within our circle of trust and refer them to some Google Forms . This basically consisted of following questions with descriptions: Name [short answer]: Please write your name starting with your first name, e.g. Albert Einstein. Affiliation [short answer]: Please state the name or organisation you are affiliated with. Who do you know from the Committee? [short answer]: We believe in the ring of trust model. With this question, we really only want to make sure that not random people sign up with no connection to any member of the Program Committee at all. Availability during the Review Period [checkboxes]: The bulk of the review work will take place from January 5 th to February 13 th , 2023, so it is important that you are broadly available during this period. That being said, you will be quite flexible in managing your time but being on vacation with no internet for 3 weeks might be suboptimal here ;-) There was only one mandatory checkbox: Yes, I am broadly available during this period. Additional comments regarding your availability during the review period. [long answer] Topics you want to review : These are the topics you are interested in reviewing. The more you select the better. Don't be shy, you don't have to be an expert in a topic to review a proposal. If you are interested in a topic and have some knowledge about it, you are totally up for the job :-) Each track in Pretalx corresponded to one checkbox in this form. At least 5 preferences needed to be chosen. Do you want your name to be listed as a reviewer on the conference website? [checkbox] Mandatory yes/no checkboxes Any additional comments for the Program Committee [long answer] Tip Google Form will use the separator , (comma, whitespace) for the selected checkboxes. Having the same separator in your track name, e.g. \"General: Community, Diversity, Career, Life and everything else\", will make it a bit harder to parse the resulting Google Sheet . So it's better to avoid them in track names. Every submission of the Google Form is then automatically added to a Google Sheet, which can be easily read with the help of Pytanis.","title":"Finding external Reviewers and learning about their preferences"},{"location":"usage/review/#onboarding-reviewers-in-pretalx","text":"Under Construction Mention the Pretalx feature request pretalx/pretalx#1417 , mention that username should be unique until then add question to the Form if user want additional proposals for review once their batch is done....","title":"Onboarding Reviewers in Pretalx"}]}