{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u200b \u00b6 Pytanis includes a Pretalx client and all the tooling you need for conferences using Pretalx , from handling the initial call for papers to creating the final program. Trivia : The name Pytanis is a reference to Prytanis using the typical py prefix of Python tools. Prytanis was the name given to the leading members of the government of a city (polis) in ancient Greece. Offices that used this title usually had responsibility for presiding over councils of some kind, which met in the Prytaneion . Romani ite domum! Features \u00b6 simple configuration management with a config folder in your home directory, just like many other tools do easily access Google Sheets , potentially filled by some Google Forms , and download sheets as data frames easy to use Pretalx client that returns proper Python objects thanks to the power of pydantic simple HelpDesk client for batch mails, e.g. to your reviewers awesome documentation with best practices for the program committee of any community-based conference tools to assign proposals to reviewers based on constraints like preferences tools to support the final selection process of proposals tools to support the creation of the final program schedule License \u00b6 Pytanis is distributed under the terms of the MIT license. Navigation \u00b6 Documentation for specific MAJOR.MINOR versions can be chosen by using the dropdown on the top of every page. The dev version reflects changes that have not yet been released. Also, desktop readers can use special keyboard shortcuts: Keys Action , (comma) p Navigate to the \"previous\" page . (period) n Navigate to the \"next\" page / s Display the search modal","title":"About"},{"location":"#_1","text":"Pytanis includes a Pretalx client and all the tooling you need for conferences using Pretalx , from handling the initial call for papers to creating the final program. Trivia : The name Pytanis is a reference to Prytanis using the typical py prefix of Python tools. Prytanis was the name given to the leading members of the government of a city (polis) in ancient Greece. Offices that used this title usually had responsibility for presiding over councils of some kind, which met in the Prytaneion . Romani ite domum!","title":"\u200b"},{"location":"#features","text":"simple configuration management with a config folder in your home directory, just like many other tools do easily access Google Sheets , potentially filled by some Google Forms , and download sheets as data frames easy to use Pretalx client that returns proper Python objects thanks to the power of pydantic simple HelpDesk client for batch mails, e.g. to your reviewers awesome documentation with best practices for the program committee of any community-based conference tools to assign proposals to reviewers based on constraints like preferences tools to support the final selection process of proposals tools to support the creation of the final program schedule","title":"Features"},{"location":"#license","text":"Pytanis is distributed under the terms of the MIT license.","title":"License"},{"location":"#navigation","text":"Documentation for specific MAJOR.MINOR versions can be chosen by using the dropdown on the top of every page. The dev version reflects changes that have not yet been released. Also, desktop readers can use special keyboard shortcuts: Keys Action , (comma) p Navigate to the \"previous\" page . (period) n Navigate to the \"next\" page / s Display the search modal","title":"Navigation"},{"location":"authors/","text":"Contributors \u00b6 Florian Wilhelm Alexander Hendorf Paula Gonz\u00e1lez Avalos Christopher Schultz Theodore Meynard","title":"Authors"},{"location":"authors/#contributors","text":"Florian Wilhelm Alexander Hendorf Paula Gonz\u00e1lez Avalos Christopher Schultz Theodore Meynard","title":"Contributors"},{"location":"changelog/","text":"Changelog \u00b6 Version 0.4 (2023-03-10) \u00b6 More functionality regarding the proposal selection process like mark_rows Pretalx submissions states are now proper Enums. GSheetClient.save_df_as_gsheet also applies some default BasicFormatter for nicer headlines etc. Added some MIP helpers ( highs ) to support the scheduling process Extended the documentation quite a bit Version 0.3 (2023-02-17) \u00b6 Allow creating a worksheet from GSheetClient Make get_cfg importable from pytanis Fix bug in PretalxClient that returned wrong number of results if a list was passed as params in conjunction with pagination. Version 0.2 (2023-02-11) \u00b6 have a progress bar for long-running commands when possible switched to gspread for handling the low-level GoogleAPI using gspread-dataframe for converting a worksheet into a dataframe timeout of 60s for PretalxAPI as it is really slow, which caused a lot of timeout errors rename *API to *Client as it's rather a client for an API moved some functionality from review to pretalx.utils GSheetClient allows now uploading dataframes as Google Sheets an awesome logo created by Paula Gonz\u00e1lez Avalos way more usage documentation Version 0.1.1 (2023-01-16) \u00b6 fix typo sent -> send in MailClient Version 0.1 (2023-01-15) \u00b6 First alpha version that can be used Google client to retrieve Google Sheets implemented Pretalx client implement A very basic HelpDesk client (minimal functionality) implemented Basic e-mail client implemented to send mails via HelpDesk Central configuration management for secrets and credentials implemented","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#version-04-2023-03-10","text":"More functionality regarding the proposal selection process like mark_rows Pretalx submissions states are now proper Enums. GSheetClient.save_df_as_gsheet also applies some default BasicFormatter for nicer headlines etc. Added some MIP helpers ( highs ) to support the scheduling process Extended the documentation quite a bit","title":"Version 0.4 (2023-03-10)"},{"location":"changelog/#version-03-2023-02-17","text":"Allow creating a worksheet from GSheetClient Make get_cfg importable from pytanis Fix bug in PretalxClient that returned wrong number of results if a list was passed as params in conjunction with pagination.","title":"Version 0.3 (2023-02-17)"},{"location":"changelog/#version-02-2023-02-11","text":"have a progress bar for long-running commands when possible switched to gspread for handling the low-level GoogleAPI using gspread-dataframe for converting a worksheet into a dataframe timeout of 60s for PretalxAPI as it is really slow, which caused a lot of timeout errors rename *API to *Client as it's rather a client for an API moved some functionality from review to pretalx.utils GSheetClient allows now uploading dataframes as Google Sheets an awesome logo created by Paula Gonz\u00e1lez Avalos way more usage documentation","title":"Version 0.2 (2023-02-11)"},{"location":"changelog/#version-011-2023-01-16","text":"fix typo sent -> send in MailClient","title":"Version 0.1.1 (2023-01-16)"},{"location":"changelog/#version-01-2023-01-15","text":"First alpha version that can be used Google client to retrieve Google Sheets implemented Pretalx client implement A very basic HelpDesk client (minimal functionality) implemented Basic e-mail client implemented to send mails via HelpDesk Central configuration management for secrets and credentials implemented","title":"Version 0.1 (2023-01-15)"},{"location":"contributing/","text":"Contributing \u00b6 Welcome to the contributor guide of Pytanis. This document focuses on getting any potential contributor familiarized with the development processes, but other kinds of contributions are also appreciated. If you are new to using git or have never collaborated in a project previously, please have a look at contribution-guide.org . Other resources are also listed in the excellent guide created by Freecodecamp 1 . Please notice, all users and contributors are expected to be open, considerate, reasonable, and respectful . When in doubt, Python Software Foundation's Code of Conduct is a good reference in terms of behavior guidelines. Issue Reports \u00b6 If you experience bugs or general issues with Pytanis, please have a look on the issue tracker . If you don't see anything useful there, please feel free to fire an issue report. Tip Please don't forget to include the closed issues in your search. Sometimes a solution was already reported, and the problem is considered solved . New issue reports should include information about your programming environment (e.g., operating system, Python version) and steps to reproduce the problem. Please try also to simplify the reproduction steps to a very minimal example that still illustrates the problem you are facing. By removing other factors, you help us to identify the root cause of the issue. Documentation improvements \u00b6 You can help to the documentation of Pytanis by making them more readable and coherent, or by adding missing information and correcting mistakes. The documentation uses mkdocs as its main documentation compiler. This means that the docs are kept in the same repository as the project code, and that any documentation update is done in the same way was a code contribution. Tip Please notice that the GitHub web interface provides a quick way of propose changes in Pytanis ' files. While this mechanism can be tricky for normal code contributions, it works perfectly fine for contributing to the docs, and can be quite handy. If you are interested in trying this method out, please navigate to the docs folder in the source repository , find which file you would like to propose changes and click in the little pencil icon at the top, to open GitHub's code editor . Once you finish editing the file, please write a message in the form at the bottom of the page describing which changes have you made and what are the motivations behind them and submit your proposal. When working on documentation changes in your local machine, you can build and serve them using hatch with hatch run docs:build and hatch run docs:serve , respectively. Code Contributions \u00b6 Submit an issue \u00b6 Before you work on any non-trivial code contribution it's best to first create a report in the issue tracker to start a discussion on the subject. This often provides additional considerations and avoids unnecessary work. Clone the repository \u00b6 Create a user account on GitHub if you do not already have one. Fork the project repository : click on the Fork button near the top of the page. This creates a copy of the code under your account on GitHub. Clone this copy to your local disk: git clone git@github.com:YourLogin/pytanis.git cd pytanis Make sure hatch is installed using pipx : pipx install hatch [only once] install pre-commit hooks in the default environment with: hatch run pre-commit install Implement your changes \u00b6 Create a branch to hold your changes: git checkout -b my-feature and start making changes. Never work on the main branch! Start your work on this branch. Don't forget to add docstrings in Google style to new functions, modules and classes, especially if they are part of public APIs. Add yourself to the list of contributors in AUTHORS.md . When you\u2019re done editing, do: git add <MODIFIED FILES> git commit to record your changes in git . Please make sure to see the validation messages from pre-commit and fix any eventual issues. This should automatically use flake8 / black to check/fix the code style in a way that is compatible with the project. Info Don't forget to add unit tests and documentation in case your contribution adds a feature and is not just a bugfix. Moreover, writing an descriptive commit message is highly recommended. In case of doubt, you can check the commit history with: git log --graph --decorate --pretty=oneline --abbrev-commit --all to look for recurring communication patterns. Please check that your changes don't break any unit tests with hatch run test:cov or hatch run test:no-cov to run the unitest with or without coverage reports, respectively. For code hygiene, execute hatch run lint:all in order to run flake8 , isort , black , mypy , etc. Submit your contribution \u00b6 If everything works fine, push your local branch to the remote server with: git push -u origin my-feature Go to the web page of your fork and click \"Create pull request\" to send your changes for review. Find more detailed information in creating a PR . You might also want to open the PR as a draft first and mark it as ready for review after the feedbacks from the continuous integration (CI) system or any required fixes. Even though, these resources focus on open source projects and communities, the general ideas behind collaborating with other developers to collectively create software are general and can be applied to all sorts of environments, including private companies and proprietary code bases. \u21a9","title":"Contributing"},{"location":"contributing/#contributing","text":"Welcome to the contributor guide of Pytanis. This document focuses on getting any potential contributor familiarized with the development processes, but other kinds of contributions are also appreciated. If you are new to using git or have never collaborated in a project previously, please have a look at contribution-guide.org . Other resources are also listed in the excellent guide created by Freecodecamp 1 . Please notice, all users and contributors are expected to be open, considerate, reasonable, and respectful . When in doubt, Python Software Foundation's Code of Conduct is a good reference in terms of behavior guidelines.","title":"Contributing"},{"location":"contributing/#issue-reports","text":"If you experience bugs or general issues with Pytanis, please have a look on the issue tracker . If you don't see anything useful there, please feel free to fire an issue report. Tip Please don't forget to include the closed issues in your search. Sometimes a solution was already reported, and the problem is considered solved . New issue reports should include information about your programming environment (e.g., operating system, Python version) and steps to reproduce the problem. Please try also to simplify the reproduction steps to a very minimal example that still illustrates the problem you are facing. By removing other factors, you help us to identify the root cause of the issue.","title":"Issue Reports"},{"location":"contributing/#documentation-improvements","text":"You can help to the documentation of Pytanis by making them more readable and coherent, or by adding missing information and correcting mistakes. The documentation uses mkdocs as its main documentation compiler. This means that the docs are kept in the same repository as the project code, and that any documentation update is done in the same way was a code contribution. Tip Please notice that the GitHub web interface provides a quick way of propose changes in Pytanis ' files. While this mechanism can be tricky for normal code contributions, it works perfectly fine for contributing to the docs, and can be quite handy. If you are interested in trying this method out, please navigate to the docs folder in the source repository , find which file you would like to propose changes and click in the little pencil icon at the top, to open GitHub's code editor . Once you finish editing the file, please write a message in the form at the bottom of the page describing which changes have you made and what are the motivations behind them and submit your proposal. When working on documentation changes in your local machine, you can build and serve them using hatch with hatch run docs:build and hatch run docs:serve , respectively.","title":"Documentation improvements"},{"location":"contributing/#code-contributions","text":"","title":"Code Contributions"},{"location":"contributing/#submit-an-issue","text":"Before you work on any non-trivial code contribution it's best to first create a report in the issue tracker to start a discussion on the subject. This often provides additional considerations and avoids unnecessary work.","title":"Submit an issue"},{"location":"contributing/#clone-the-repository","text":"Create a user account on GitHub if you do not already have one. Fork the project repository : click on the Fork button near the top of the page. This creates a copy of the code under your account on GitHub. Clone this copy to your local disk: git clone git@github.com:YourLogin/pytanis.git cd pytanis Make sure hatch is installed using pipx : pipx install hatch [only once] install pre-commit hooks in the default environment with: hatch run pre-commit install","title":"Clone the repository"},{"location":"contributing/#implement-your-changes","text":"Create a branch to hold your changes: git checkout -b my-feature and start making changes. Never work on the main branch! Start your work on this branch. Don't forget to add docstrings in Google style to new functions, modules and classes, especially if they are part of public APIs. Add yourself to the list of contributors in AUTHORS.md . When you\u2019re done editing, do: git add <MODIFIED FILES> git commit to record your changes in git . Please make sure to see the validation messages from pre-commit and fix any eventual issues. This should automatically use flake8 / black to check/fix the code style in a way that is compatible with the project. Info Don't forget to add unit tests and documentation in case your contribution adds a feature and is not just a bugfix. Moreover, writing an descriptive commit message is highly recommended. In case of doubt, you can check the commit history with: git log --graph --decorate --pretty=oneline --abbrev-commit --all to look for recurring communication patterns. Please check that your changes don't break any unit tests with hatch run test:cov or hatch run test:no-cov to run the unitest with or without coverage reports, respectively. For code hygiene, execute hatch run lint:all in order to run flake8 , isort , black , mypy , etc.","title":"Implement your changes"},{"location":"contributing/#submit-your-contribution","text":"If everything works fine, push your local branch to the remote server with: git push -u origin my-feature Go to the web page of your fork and click \"Create pull request\" to send your changes for review. Find more detailed information in creating a PR . You might also want to open the PR as a draft first and mark it as ready for review after the feedbacks from the continuous integration (CI) system or any required fixes. Even though, these resources focus on open source projects and communities, the general ideas behind collaborating with other developers to collectively create software are general and can be applied to all sorts of environments, including private companies and proprietary code bases. \u21a9","title":"Submit your contribution"},{"location":"license/","text":"The MIT License (MIT) Copyright \u00a9 2023 Florian Wilhelm Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"reference/SUMMARY/","text":"pytanis config google helpdesk client mail types highs pretalx client types utils review utils","title":"SUMMARY"},{"location":"reference/pytanis/","text":"pytanis \u00b6 __all__ = [ '__version__' , 'GSheetClient' , 'PretalxClient' , 'HelpDeskClient' , 'get_cfg' ] module-attribute \u00b6 __version__ = version ( 'pytanis' ) module-attribute \u00b6 GSheetClient ( config : Optional [ Config ] = None , read_only : bool = True ) \u00b6 Google API to easily handle GSheets and other files on GDrive By default, only the least permissive scope GSHEET_RO in case of read_only = True is used. Source code in pytanis/google.py def __init__ ( self , config : Optional [ Config ] = None , read_only : bool = True ): self . _read_only = read_only if read_only : self . _scopes = [ Scope . GSHEET_RO ] else : self . _scopes = [ Scope . GSHEET_RW ] if config is None : config = get_cfg () self . _config = config self . gc = gspread_client ( self . _scopes , config ) # gspread client for more functionality gc = gspread_client ( self . _scopes , config ) instance-attribute \u00b6 clear_gsheet ( spreadsheet_id : str , worksheet_name : str ) \u00b6 Clear the worksheet including values, formatting, filtering, etc. Source code in pytanis/google.py def clear_gsheet ( self , spreadsheet_id : str , worksheet_name : str ): \"\"\"Clear the worksheet including values, formatting, filtering, etc.\"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name , create_ws = False ) default_fmt = get_default_format ( worksheet . spreadsheet ) range = worksheet_range ( worksheet ) try : worksheet . clear () worksheet . clear_basic_filter () format_cell_range ( worksheet , range , default_fmt ) rules = get_conditional_format_rules ( worksheet ) rules . clear () rules . save () set_data_validation_for_cell_range ( worksheet , range , None ) except APIError as error : self . _exception_feedback ( error ) gsheet ( spreadsheet_id : str , worksheet_name : Optional [ str ] = None , create_ws : bool = False ) -> Union [ Worksheet , Spreadsheet ] \u00b6 Retrieve a Google sheet by its id and the name Open a Google sheet in your browser and check the URL to retrieve the id, e.g.: https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit ... If the spreadsheet as several worksheets (check the lower bar) then worksheet_name can be used to specify a specific one. Source code in pytanis/google.py def gsheet ( self , spreadsheet_id : str , worksheet_name : Optional [ str ] = None , create_ws : bool = False ) -> Union [ Worksheet , Spreadsheet ]: \"\"\"Retrieve a Google sheet by its id and the name Open a Google sheet in your browser and check the URL to retrieve the id, e.g.: https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit... If the spreadsheet as several worksheets (check the lower bar) then `worksheet_name` can be used to specify a specific one. \"\"\" spreadsheet = self . gc . open_by_key ( spreadsheet_id ) if worksheet_name is None : return spreadsheet else : if worksheet_name in [ ws . title for ws in spreadsheet . worksheets ()]: return spreadsheet . worksheet ( worksheet_name ) elif create_ws : worksheet = spreadsheet . add_worksheet ( title = worksheet_name , rows = 100 , cols = 20 ) self . _wait_for_worksheet ( spreadsheet_id , worksheet_name ) return worksheet else : return spreadsheet . worksheet ( worksheet_name ) # raises exception gsheet_as_df ( spreadsheet_id : str , worksheet_name : str , kwargs : Union [ str , bool , int ]) -> pd . DataFrame \u00b6 Returns a worksheet as dataframe Source code in pytanis/google.py def gsheet_as_df ( self , spreadsheet_id : str , worksheet_name : str , ** kwargs : Union [ str , bool , int ]) -> pd . DataFrame : \"\"\"Returns a worksheet as dataframe\"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name ) df = get_as_dataframe ( worksheet , ** kwargs ) # remove Nan rows & columns as they are exported by default df . dropna ( how = 'all' , inplace = True , axis = 0 ) df . dropna ( how = 'all' , inplace = True , axis = 1 ) return df recreate_token () \u00b6 Recreate the current token using the scopes given at initialization Source code in pytanis/google.py def recreate_token ( self ): \"\"\"Recreate the current token using the scopes given at initialization\"\"\" self . _config . Google . token_json . unlink ( missing_ok = True ) self . gc = gspread_client ( self . _scopes , self . _config ) save_df_as_gsheet ( df : pd . DataFrame , spreadsheet_id : str , worksheet_name : str , create_ws : bool = False , default_fmt : bool = True , kwargs : Union [ str , bool , int ]) \u00b6 Save the given dataframe as worksheet in a spreadsheet Make sure that the scope passed gives you write permissions Parameters: Name Type Description Default df pd . DataFrame dataframe to save required spreadsheet_id str id of the Google spreadsheet required worksheet_name str name of the worksheet within the spreadsheet required create_ws bool create the worksheet if non-existent False default_fmt bool apply default formatter BasicFormatter True **kwargs Union [ str , bool , int ] extra keyword arguments passed to set_with_dataframe {} Source code in pytanis/google.py def save_df_as_gsheet ( self , df : pd . DataFrame , spreadsheet_id : str , worksheet_name : str , create_ws : bool = False , default_fmt : bool = True , ** kwargs : Union [ str , bool , int ], ): \"\"\"Save the given dataframe as worksheet in a spreadsheet Make sure that the scope passed gives you write permissions Args: df: dataframe to save spreadsheet_id: id of the Google spreadsheet worksheet_name: name of the worksheet within the spreadsheet create_ws: create the worksheet if non-existent default_fmt: apply default formatter `BasicFormatter` **kwargs: extra keyword arguments passed to `set_with_dataframe` \"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name , create_ws = create_ws ) # make sure it's really only the dataframe, not some residue self . clear_gsheet ( spreadsheet_id , worksheet_name ) # ToDo: Starting from Python 3.9 on just use the | operator params = { ** dict ( resize = True ), ** dict ( ** kwargs )} # set sane defaults try : set_with_dataframe ( worksheet , df , ** params ) if default_fmt : format_with_dataframe ( worksheet , df ) except APIError as error : self . _exception_feedback ( error ) HelpDeskClient ( config : Optional [ Config ] = None ) \u00b6 Source code in pytanis/helpdesk/client.py def __init__ ( self , config : Optional [ Config ] = None ): if config is None : config = get_cfg () self . _config = config # Important: Always use a custom User-Agent, never a generic one. # Generic User-Agents are filtered by helpdesk to reduce spam. self . _headers = { \"User-Agent\" : \"Pytanis\" } self . _get_throttled = self . _get self . _post_throttled = self . _post self . set_throttling ( 2 , 1 ) # we are nice by default create_ticket ( ticket : NewTicket ) \u00b6 Source code in pytanis/helpdesk/client.py def create_ticket ( self , ticket : NewTicket ): return self . post ( \"tickets\" , data = ticket . dict ()) get ( endpoint : str , params : Optional [ Dict [ str , str ]] = None ) -> JSON \u00b6 Retrieve data via throttled GET request and return the JSON Source code in pytanis/helpdesk/client.py def get ( self , endpoint : str , params : Optional [ Dict [ str , str ]] = None ) -> JSON : \"\"\"Retrieve data via throttled GET request and return the JSON\"\"\" resp = self . _get_throttled ( endpoint , params ) resp . raise_for_status () return resp . json () list_agents () -> List [ Agent ] \u00b6 Source code in pytanis/helpdesk/client.py def list_agents ( self ) -> List [ Agent ]: agents = self . get ( \"agents\" ) assert isinstance ( agents , List ) return [ Agent . parse_obj ( dct ) for dct in agents ] list_teams () -> List [ Team ] \u00b6 Source code in pytanis/helpdesk/client.py def list_teams ( self ) -> List [ Team ]: teams = self . get ( \"teams\" ) assert isinstance ( teams , List ) return [ Team . parse_obj ( dct ) for dct in teams ] post ( endpoint : str , data : Dict [ str , Any ], params : Optional [ Dict [ str , str ]] = None ) -> JSON \u00b6 Source code in pytanis/helpdesk/client.py def post ( self , endpoint : str , data : Dict [ str , Any ], params : Optional [ Dict [ str , str ]] = None ) -> JSON : resp = self . _post_throttled ( endpoint , data , params ) resp . raise_for_status () return resp . json () set_throttling ( calls : int , seconds : int ) \u00b6 Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/helpdesk/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . debug ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get ) self . _post_throttled = throttle ( calls , seconds )( self . _post ) PretalxClient ( config : Optional [ Config ] = None , blocking : bool = False ) \u00b6 Client for the Pretalx API Source code in pytanis/pretalx/client.py def __init__ ( self , config : Optional [ Config ] = None , blocking : bool = False ): if config is None : config = get_cfg () self . _config = config self . _get_throttled = self . _get self . blocking = blocking self . set_throttling ( 1 , 2 ) # we are nice by default blocking = blocking instance-attribute \u00b6 answer ( event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Answer \u00b6 Returns a specific answer Source code in pytanis/pretalx/client.py def answer ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Answer : \"\"\"Returns a specific answer\"\"\" return self . _endpoint_id ( Answer , event_slug , \"answers\" , id , params = params ) answers ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Answer ]] \u00b6 Lists all answers and their details Source code in pytanis/pretalx/client.py def answers ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Answer ]]: \"\"\"Lists all answers and their details\"\"\" return self . _endpoint_lst ( Answer , event_slug , \"answers\" , params = params ) event ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Event \u00b6 Returns detailed information about a specific event Source code in pytanis/pretalx/client.py def event ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Event : \"\"\"Returns detailed information about a specific event\"\"\" endpoint = f \"/api/events/ { event_slug } /\" result = self . _get_one ( endpoint , params ) _logger . debug ( \"result\" , resp = result ) return Event . parse_obj ( result ) events ( * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Event ]] \u00b6 Lists all events and their details Source code in pytanis/pretalx/client.py def events ( self , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Event ]]: \"\"\"Lists all events and their details\"\"\" count , results = self . _get_many ( \"/api/events/\" , params ) events = iter ( _logger . debug ( \"result\" , resp = r ) or Event . parse_obj ( r ) for r in results ) return count , events me () -> Me \u00b6 Returns what Pretalx knows about myself Source code in pytanis/pretalx/client.py def me ( self ) -> Me : \"\"\"Returns what Pretalx knows about myself\"\"\" result = self . _get_one ( \"/api/me\" ) return Me . parse_obj ( result ) question ( event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Question \u00b6 Returns a specific question Source code in pytanis/pretalx/client.py def question ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Question : \"\"\"Returns a specific question\"\"\" return self . _endpoint_id ( Question , event_slug , \"questions\" , id , params = params ) questions ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Question ]] \u00b6 Lists all questions and their details Source code in pytanis/pretalx/client.py def questions ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Question ]]: \"\"\"Lists all questions and their details\"\"\" return self . _endpoint_lst ( Question , event_slug , \"questions\" , params = params ) review ( event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Review \u00b6 Returns a specific review Source code in pytanis/pretalx/client.py def review ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Review : \"\"\"Returns a specific review\"\"\" return self . _endpoint_id ( Review , event_slug , \"reviews\" , id , params = params ) reviews ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Review ]] \u00b6 Lists all reviews and their details Source code in pytanis/pretalx/client.py def reviews ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Review ]]: \"\"\"Lists all reviews and their details\"\"\" return self . _endpoint_lst ( Review , event_slug , \"reviews\" , params = params ) room ( event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Room \u00b6 Returns a specific room Source code in pytanis/pretalx/client.py def room ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Room : \"\"\"Returns a specific room\"\"\" return self . _endpoint_id ( Room , event_slug , \"rooms\" , id , params = params ) rooms ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Room ]] \u00b6 Lists all rooms and their details Source code in pytanis/pretalx/client.py def rooms ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Room ]]: \"\"\"Lists all rooms and their details\"\"\" return self . _endpoint_lst ( Room , event_slug , \"rooms\" , params = params ) set_throttling ( calls : int , seconds : int ) \u00b6 Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/pretalx/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . info ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get ) speaker ( event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Speaker \u00b6 Returns a specific speaker Source code in pytanis/pretalx/client.py def speaker ( self , event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Speaker : \"\"\"Returns a specific speaker\"\"\" return self . _endpoint_id ( Speaker , event_slug , \"speakers\" , code , params = params ) speakers ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Speaker ]] \u00b6 Lists all speakers and their details Source code in pytanis/pretalx/client.py def speakers ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Speaker ]]: \"\"\"Lists all speakers and their details\"\"\" return self . _endpoint_lst ( Speaker , event_slug , \"speakers\" , params = params ) submission ( event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Submission \u00b6 Returns a specific submission Source code in pytanis/pretalx/client.py def submission ( self , event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Submission : \"\"\"Returns a specific submission\"\"\" return self . _endpoint_id ( Submission , event_slug , \"submissions\" , code , params = params ) submissions ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Submission ]] \u00b6 Lists all submissions and their details Source code in pytanis/pretalx/client.py def submissions ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Submission ]]: \"\"\"Lists all submissions and their details\"\"\" return self . _endpoint_lst ( Submission , event_slug , \"submissions\" , params = params ) tag ( event_slug : str , tag : str , * , params : Optional [ QueryParamType ] = None ) -> Tag \u00b6 Returns a specific tag Source code in pytanis/pretalx/client.py def tag ( self , event_slug : str , tag : str , * , params : Optional [ QueryParamType ] = None ) -> Tag : \"\"\"Returns a specific tag\"\"\" return self . _endpoint_id ( Tag , event_slug , \"tags\" , tag , params = params ) tags ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Tag ]] \u00b6 Lists all tags and their details Source code in pytanis/pretalx/client.py def tags ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Tag ]]: \"\"\"Lists all tags and their details\"\"\" return self . _endpoint_lst ( Tag , event_slug , \"tags\" , params = params ) talk ( event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Talk \u00b6 Returns a specific talk Source code in pytanis/pretalx/client.py def talk ( self , event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Talk : \"\"\"Returns a specific talk\"\"\" return self . _endpoint_id ( Talk , event_slug , \"talks\" , code , params = params ) talks ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Talk ]] \u00b6 Lists all talks and their details Source code in pytanis/pretalx/client.py def talks ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Talk ]]: \"\"\"Lists all talks and their details\"\"\" return self . _endpoint_lst ( Talk , event_slug , \"talks\" , params = params ) get_cfg () -> Config \u00b6 Returns the configuration as an object Source code in pytanis/config.py def get_cfg () -> Config : \"\"\"Returns the configuration as an object\"\"\" cfg_path = get_cfg_file () with open ( cfg_path , \"rb\" ) as fh : cfg_dict = tomli . load ( fh ) # add config path to later resolve relative paths of config values cfg_dict [ \"cfg_path\" ] = cfg_path return Config . parse_obj ( cfg_dict )","title":"pytanis"},{"location":"reference/pytanis/#pytanis","text":"","title":"pytanis"},{"location":"reference/pytanis/#pytanis.__all__","text":"","title":"__all__"},{"location":"reference/pytanis/#pytanis.__version__","text":"","title":"__version__"},{"location":"reference/pytanis/#pytanis.GSheetClient","text":"Google API to easily handle GSheets and other files on GDrive By default, only the least permissive scope GSHEET_RO in case of read_only = True is used. Source code in pytanis/google.py def __init__ ( self , config : Optional [ Config ] = None , read_only : bool = True ): self . _read_only = read_only if read_only : self . _scopes = [ Scope . GSHEET_RO ] else : self . _scopes = [ Scope . GSHEET_RW ] if config is None : config = get_cfg () self . _config = config self . gc = gspread_client ( self . _scopes , config ) # gspread client for more functionality","title":"GSheetClient"},{"location":"reference/pytanis/#pytanis.google.GSheetClient.gc","text":"","title":"gc"},{"location":"reference/pytanis/#pytanis.google.GSheetClient.clear_gsheet","text":"Clear the worksheet including values, formatting, filtering, etc. Source code in pytanis/google.py def clear_gsheet ( self , spreadsheet_id : str , worksheet_name : str ): \"\"\"Clear the worksheet including values, formatting, filtering, etc.\"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name , create_ws = False ) default_fmt = get_default_format ( worksheet . spreadsheet ) range = worksheet_range ( worksheet ) try : worksheet . clear () worksheet . clear_basic_filter () format_cell_range ( worksheet , range , default_fmt ) rules = get_conditional_format_rules ( worksheet ) rules . clear () rules . save () set_data_validation_for_cell_range ( worksheet , range , None ) except APIError as error : self . _exception_feedback ( error )","title":"clear_gsheet()"},{"location":"reference/pytanis/#pytanis.google.GSheetClient.gsheet","text":"Retrieve a Google sheet by its id and the name Open a Google sheet in your browser and check the URL to retrieve the id, e.g.: https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit ... If the spreadsheet as several worksheets (check the lower bar) then worksheet_name can be used to specify a specific one. Source code in pytanis/google.py def gsheet ( self , spreadsheet_id : str , worksheet_name : Optional [ str ] = None , create_ws : bool = False ) -> Union [ Worksheet , Spreadsheet ]: \"\"\"Retrieve a Google sheet by its id and the name Open a Google sheet in your browser and check the URL to retrieve the id, e.g.: https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit... If the spreadsheet as several worksheets (check the lower bar) then `worksheet_name` can be used to specify a specific one. \"\"\" spreadsheet = self . gc . open_by_key ( spreadsheet_id ) if worksheet_name is None : return spreadsheet else : if worksheet_name in [ ws . title for ws in spreadsheet . worksheets ()]: return spreadsheet . worksheet ( worksheet_name ) elif create_ws : worksheet = spreadsheet . add_worksheet ( title = worksheet_name , rows = 100 , cols = 20 ) self . _wait_for_worksheet ( spreadsheet_id , worksheet_name ) return worksheet else : return spreadsheet . worksheet ( worksheet_name ) # raises exception","title":"gsheet()"},{"location":"reference/pytanis/#pytanis.google.GSheetClient.gsheet_as_df","text":"Returns a worksheet as dataframe Source code in pytanis/google.py def gsheet_as_df ( self , spreadsheet_id : str , worksheet_name : str , ** kwargs : Union [ str , bool , int ]) -> pd . DataFrame : \"\"\"Returns a worksheet as dataframe\"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name ) df = get_as_dataframe ( worksheet , ** kwargs ) # remove Nan rows & columns as they are exported by default df . dropna ( how = 'all' , inplace = True , axis = 0 ) df . dropna ( how = 'all' , inplace = True , axis = 1 ) return df","title":"gsheet_as_df()"},{"location":"reference/pytanis/#pytanis.google.GSheetClient.recreate_token","text":"Recreate the current token using the scopes given at initialization Source code in pytanis/google.py def recreate_token ( self ): \"\"\"Recreate the current token using the scopes given at initialization\"\"\" self . _config . Google . token_json . unlink ( missing_ok = True ) self . gc = gspread_client ( self . _scopes , self . _config )","title":"recreate_token()"},{"location":"reference/pytanis/#pytanis.google.GSheetClient.save_df_as_gsheet","text":"Save the given dataframe as worksheet in a spreadsheet Make sure that the scope passed gives you write permissions Parameters: Name Type Description Default df pd . DataFrame dataframe to save required spreadsheet_id str id of the Google spreadsheet required worksheet_name str name of the worksheet within the spreadsheet required create_ws bool create the worksheet if non-existent False default_fmt bool apply default formatter BasicFormatter True **kwargs Union [ str , bool , int ] extra keyword arguments passed to set_with_dataframe {} Source code in pytanis/google.py def save_df_as_gsheet ( self , df : pd . DataFrame , spreadsheet_id : str , worksheet_name : str , create_ws : bool = False , default_fmt : bool = True , ** kwargs : Union [ str , bool , int ], ): \"\"\"Save the given dataframe as worksheet in a spreadsheet Make sure that the scope passed gives you write permissions Args: df: dataframe to save spreadsheet_id: id of the Google spreadsheet worksheet_name: name of the worksheet within the spreadsheet create_ws: create the worksheet if non-existent default_fmt: apply default formatter `BasicFormatter` **kwargs: extra keyword arguments passed to `set_with_dataframe` \"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name , create_ws = create_ws ) # make sure it's really only the dataframe, not some residue self . clear_gsheet ( spreadsheet_id , worksheet_name ) # ToDo: Starting from Python 3.9 on just use the | operator params = { ** dict ( resize = True ), ** dict ( ** kwargs )} # set sane defaults try : set_with_dataframe ( worksheet , df , ** params ) if default_fmt : format_with_dataframe ( worksheet , df ) except APIError as error : self . _exception_feedback ( error )","title":"save_df_as_gsheet()"},{"location":"reference/pytanis/#pytanis.HelpDeskClient","text":"Source code in pytanis/helpdesk/client.py def __init__ ( self , config : Optional [ Config ] = None ): if config is None : config = get_cfg () self . _config = config # Important: Always use a custom User-Agent, never a generic one. # Generic User-Agents are filtered by helpdesk to reduce spam. self . _headers = { \"User-Agent\" : \"Pytanis\" } self . _get_throttled = self . _get self . _post_throttled = self . _post self . set_throttling ( 2 , 1 ) # we are nice by default","title":"HelpDeskClient"},{"location":"reference/pytanis/#pytanis.helpdesk.client.HelpDeskClient.create_ticket","text":"Source code in pytanis/helpdesk/client.py def create_ticket ( self , ticket : NewTicket ): return self . post ( \"tickets\" , data = ticket . dict ())","title":"create_ticket()"},{"location":"reference/pytanis/#pytanis.helpdesk.client.HelpDeskClient.get","text":"Retrieve data via throttled GET request and return the JSON Source code in pytanis/helpdesk/client.py def get ( self , endpoint : str , params : Optional [ Dict [ str , str ]] = None ) -> JSON : \"\"\"Retrieve data via throttled GET request and return the JSON\"\"\" resp = self . _get_throttled ( endpoint , params ) resp . raise_for_status () return resp . json ()","title":"get()"},{"location":"reference/pytanis/#pytanis.helpdesk.client.HelpDeskClient.list_agents","text":"Source code in pytanis/helpdesk/client.py def list_agents ( self ) -> List [ Agent ]: agents = self . get ( \"agents\" ) assert isinstance ( agents , List ) return [ Agent . parse_obj ( dct ) for dct in agents ]","title":"list_agents()"},{"location":"reference/pytanis/#pytanis.helpdesk.client.HelpDeskClient.list_teams","text":"Source code in pytanis/helpdesk/client.py def list_teams ( self ) -> List [ Team ]: teams = self . get ( \"teams\" ) assert isinstance ( teams , List ) return [ Team . parse_obj ( dct ) for dct in teams ]","title":"list_teams()"},{"location":"reference/pytanis/#pytanis.helpdesk.client.HelpDeskClient.post","text":"Source code in pytanis/helpdesk/client.py def post ( self , endpoint : str , data : Dict [ str , Any ], params : Optional [ Dict [ str , str ]] = None ) -> JSON : resp = self . _post_throttled ( endpoint , data , params ) resp . raise_for_status () return resp . json ()","title":"post()"},{"location":"reference/pytanis/#pytanis.helpdesk.client.HelpDeskClient.set_throttling","text":"Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/helpdesk/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . debug ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get ) self . _post_throttled = throttle ( calls , seconds )( self . _post )","title":"set_throttling()"},{"location":"reference/pytanis/#pytanis.PretalxClient","text":"Client for the Pretalx API Source code in pytanis/pretalx/client.py def __init__ ( self , config : Optional [ Config ] = None , blocking : bool = False ): if config is None : config = get_cfg () self . _config = config self . _get_throttled = self . _get self . blocking = blocking self . set_throttling ( 1 , 2 ) # we are nice by default","title":"PretalxClient"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.blocking","text":"","title":"blocking"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.answer","text":"Returns a specific answer Source code in pytanis/pretalx/client.py def answer ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Answer : \"\"\"Returns a specific answer\"\"\" return self . _endpoint_id ( Answer , event_slug , \"answers\" , id , params = params )","title":"answer()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.answers","text":"Lists all answers and their details Source code in pytanis/pretalx/client.py def answers ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Answer ]]: \"\"\"Lists all answers and their details\"\"\" return self . _endpoint_lst ( Answer , event_slug , \"answers\" , params = params )","title":"answers()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.event","text":"Returns detailed information about a specific event Source code in pytanis/pretalx/client.py def event ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Event : \"\"\"Returns detailed information about a specific event\"\"\" endpoint = f \"/api/events/ { event_slug } /\" result = self . _get_one ( endpoint , params ) _logger . debug ( \"result\" , resp = result ) return Event . parse_obj ( result )","title":"event()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.events","text":"Lists all events and their details Source code in pytanis/pretalx/client.py def events ( self , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Event ]]: \"\"\"Lists all events and their details\"\"\" count , results = self . _get_many ( \"/api/events/\" , params ) events = iter ( _logger . debug ( \"result\" , resp = r ) or Event . parse_obj ( r ) for r in results ) return count , events","title":"events()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.me","text":"Returns what Pretalx knows about myself Source code in pytanis/pretalx/client.py def me ( self ) -> Me : \"\"\"Returns what Pretalx knows about myself\"\"\" result = self . _get_one ( \"/api/me\" ) return Me . parse_obj ( result )","title":"me()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.question","text":"Returns a specific question Source code in pytanis/pretalx/client.py def question ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Question : \"\"\"Returns a specific question\"\"\" return self . _endpoint_id ( Question , event_slug , \"questions\" , id , params = params )","title":"question()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.questions","text":"Lists all questions and their details Source code in pytanis/pretalx/client.py def questions ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Question ]]: \"\"\"Lists all questions and their details\"\"\" return self . _endpoint_lst ( Question , event_slug , \"questions\" , params = params )","title":"questions()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.review","text":"Returns a specific review Source code in pytanis/pretalx/client.py def review ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Review : \"\"\"Returns a specific review\"\"\" return self . _endpoint_id ( Review , event_slug , \"reviews\" , id , params = params )","title":"review()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.reviews","text":"Lists all reviews and their details Source code in pytanis/pretalx/client.py def reviews ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Review ]]: \"\"\"Lists all reviews and their details\"\"\" return self . _endpoint_lst ( Review , event_slug , \"reviews\" , params = params )","title":"reviews()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.room","text":"Returns a specific room Source code in pytanis/pretalx/client.py def room ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Room : \"\"\"Returns a specific room\"\"\" return self . _endpoint_id ( Room , event_slug , \"rooms\" , id , params = params )","title":"room()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.rooms","text":"Lists all rooms and their details Source code in pytanis/pretalx/client.py def rooms ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Room ]]: \"\"\"Lists all rooms and their details\"\"\" return self . _endpoint_lst ( Room , event_slug , \"rooms\" , params = params )","title":"rooms()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.set_throttling","text":"Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/pretalx/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . info ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get )","title":"set_throttling()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.speaker","text":"Returns a specific speaker Source code in pytanis/pretalx/client.py def speaker ( self , event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Speaker : \"\"\"Returns a specific speaker\"\"\" return self . _endpoint_id ( Speaker , event_slug , \"speakers\" , code , params = params )","title":"speaker()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.speakers","text":"Lists all speakers and their details Source code in pytanis/pretalx/client.py def speakers ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Speaker ]]: \"\"\"Lists all speakers and their details\"\"\" return self . _endpoint_lst ( Speaker , event_slug , \"speakers\" , params = params )","title":"speakers()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.submission","text":"Returns a specific submission Source code in pytanis/pretalx/client.py def submission ( self , event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Submission : \"\"\"Returns a specific submission\"\"\" return self . _endpoint_id ( Submission , event_slug , \"submissions\" , code , params = params )","title":"submission()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.submissions","text":"Lists all submissions and their details Source code in pytanis/pretalx/client.py def submissions ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Submission ]]: \"\"\"Lists all submissions and their details\"\"\" return self . _endpoint_lst ( Submission , event_slug , \"submissions\" , params = params )","title":"submissions()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.tag","text":"Returns a specific tag Source code in pytanis/pretalx/client.py def tag ( self , event_slug : str , tag : str , * , params : Optional [ QueryParamType ] = None ) -> Tag : \"\"\"Returns a specific tag\"\"\" return self . _endpoint_id ( Tag , event_slug , \"tags\" , tag , params = params )","title":"tag()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.tags","text":"Lists all tags and their details Source code in pytanis/pretalx/client.py def tags ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Tag ]]: \"\"\"Lists all tags and their details\"\"\" return self . _endpoint_lst ( Tag , event_slug , \"tags\" , params = params )","title":"tags()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.talk","text":"Returns a specific talk Source code in pytanis/pretalx/client.py def talk ( self , event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Talk : \"\"\"Returns a specific talk\"\"\" return self . _endpoint_id ( Talk , event_slug , \"talks\" , code , params = params )","title":"talk()"},{"location":"reference/pytanis/#pytanis.pretalx.client.PretalxClient.talks","text":"Lists all talks and their details Source code in pytanis/pretalx/client.py def talks ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Talk ]]: \"\"\"Lists all talks and their details\"\"\" return self . _endpoint_lst ( Talk , event_slug , \"talks\" , params = params )","title":"talks()"},{"location":"reference/pytanis/#pytanis.get_cfg","text":"Returns the configuration as an object Source code in pytanis/config.py def get_cfg () -> Config : \"\"\"Returns the configuration as an object\"\"\" cfg_path = get_cfg_file () with open ( cfg_path , \"rb\" ) as fh : cfg_dict = tomli . load ( fh ) # add config path to later resolve relative paths of config values cfg_dict [ \"cfg_path\" ] = cfg_path return Config . parse_obj ( cfg_dict )","title":"get_cfg()"},{"location":"reference/pytanis/config/","text":"config \u00b6 Handling the configuration PYTANIS_CFG_PATH : str = '.pytanis/config.toml' module-attribute \u00b6 Path within $HOME to the configuration file of Pytanis PYTANIS_ENV : str = 'PYTANIS_CONFIG' module-attribute \u00b6 Name of the environment variable to look up the path for the config Config \u00b6 Main configuration object Google : Google class-attribute \u00b6 HelpDesk : HelpDesk class-attribute \u00b6 Pretalx : Pretalx class-attribute \u00b6 cfg_path : FilePath class-attribute \u00b6 convert_json_path ( v , values ) classmethod \u00b6 Source code in pytanis/config.py @validator ( \"Google\" ) @classmethod def convert_json_path ( cls , v , values ): def make_rel_path_abs ( entry ): if entry is not None and not entry . is_absolute (): entry = values [ \"cfg_path\" ] . parent / entry return entry v . client_secret_json = make_rel_path_abs ( v . client_secret_json ) v . token_json = make_rel_path_abs ( v . token_json ) return v Google \u00b6 Configuration related to the Google API client_secret_json : Optional [ Path ] class-attribute \u00b6 token_json : Optional [ Path ] class-attribute \u00b6 HelpDesk \u00b6 Configuration related to the HelpDesk API account : Optional [ str ] class-attribute \u00b6 entity_id : Optional [ str ] class-attribute \u00b6 token : Optional [ str ] class-attribute \u00b6 Pretalx \u00b6 Configuration related to the Pretalx API api_token : Optional [ str ] class-attribute \u00b6 get_cfg () -> Config \u00b6 Returns the configuration as an object Source code in pytanis/config.py def get_cfg () -> Config : \"\"\"Returns the configuration as an object\"\"\" cfg_path = get_cfg_file () with open ( cfg_path , \"rb\" ) as fh : cfg_dict = tomli . load ( fh ) # add config path to later resolve relative paths of config values cfg_dict [ \"cfg_path\" ] = cfg_path return Config . parse_obj ( cfg_dict ) get_cfg_file () -> Path \u00b6 Determines the path of the config file Source code in pytanis/config.py def get_cfg_file () -> Path : \"\"\"Determines the path of the config file\"\"\" path_str = os . environ . get ( PYTANIS_ENV , None ) if path_str is None : path = Path . home () / Path ( PYTANIS_CFG_PATH ) else : path = Path ( path_str ) return path","title":"config"},{"location":"reference/pytanis/config/#pytanis.config","text":"Handling the configuration","title":"config"},{"location":"reference/pytanis/config/#pytanis.config.PYTANIS_CFG_PATH","text":"Path within $HOME to the configuration file of Pytanis","title":"PYTANIS_CFG_PATH"},{"location":"reference/pytanis/config/#pytanis.config.PYTANIS_ENV","text":"Name of the environment variable to look up the path for the config","title":"PYTANIS_ENV"},{"location":"reference/pytanis/config/#pytanis.config.Config","text":"Main configuration object","title":"Config"},{"location":"reference/pytanis/config/#pytanis.config.Config.Google","text":"","title":"Google"},{"location":"reference/pytanis/config/#pytanis.config.Config.HelpDesk","text":"","title":"HelpDesk"},{"location":"reference/pytanis/config/#pytanis.config.Config.Pretalx","text":"","title":"Pretalx"},{"location":"reference/pytanis/config/#pytanis.config.Config.cfg_path","text":"","title":"cfg_path"},{"location":"reference/pytanis/config/#pytanis.config.Config.convert_json_path","text":"Source code in pytanis/config.py @validator ( \"Google\" ) @classmethod def convert_json_path ( cls , v , values ): def make_rel_path_abs ( entry ): if entry is not None and not entry . is_absolute (): entry = values [ \"cfg_path\" ] . parent / entry return entry v . client_secret_json = make_rel_path_abs ( v . client_secret_json ) v . token_json = make_rel_path_abs ( v . token_json ) return v","title":"convert_json_path()"},{"location":"reference/pytanis/config/#pytanis.config.Google","text":"Configuration related to the Google API","title":"Google"},{"location":"reference/pytanis/config/#pytanis.config.Google.client_secret_json","text":"","title":"client_secret_json"},{"location":"reference/pytanis/config/#pytanis.config.Google.token_json","text":"","title":"token_json"},{"location":"reference/pytanis/config/#pytanis.config.HelpDesk","text":"Configuration related to the HelpDesk API","title":"HelpDesk"},{"location":"reference/pytanis/config/#pytanis.config.HelpDesk.account","text":"","title":"account"},{"location":"reference/pytanis/config/#pytanis.config.HelpDesk.entity_id","text":"","title":"entity_id"},{"location":"reference/pytanis/config/#pytanis.config.HelpDesk.token","text":"","title":"token"},{"location":"reference/pytanis/config/#pytanis.config.Pretalx","text":"Configuration related to the Pretalx API","title":"Pretalx"},{"location":"reference/pytanis/config/#pytanis.config.Pretalx.api_token","text":"","title":"api_token"},{"location":"reference/pytanis/config/#pytanis.config.get_cfg","text":"Returns the configuration as an object Source code in pytanis/config.py def get_cfg () -> Config : \"\"\"Returns the configuration as an object\"\"\" cfg_path = get_cfg_file () with open ( cfg_path , \"rb\" ) as fh : cfg_dict = tomli . load ( fh ) # add config path to later resolve relative paths of config values cfg_dict [ \"cfg_path\" ] = cfg_path return Config . parse_obj ( cfg_dict )","title":"get_cfg()"},{"location":"reference/pytanis/config/#pytanis.config.get_cfg_file","text":"Determines the path of the config file Source code in pytanis/config.py def get_cfg_file () -> Path : \"\"\"Determines the path of the config file\"\"\" path_str = os . environ . get ( PYTANIS_ENV , None ) if path_str is None : path = Path . home () / Path ( PYTANIS_CFG_PATH ) else : path = Path ( path_str ) return path","title":"get_cfg_file()"},{"location":"reference/pytanis/google/","text":"google \u00b6 Functionality around the Google's Spreadsheet API Additional Documentation Google GSheet API GSpread GSpread-Dataframe GSpread-Formatting ColorType = Union [ str , Tuple [ float , float , float ], Tuple [ float , float , float , float ]] module-attribute \u00b6 __all__ = [ 'GSheetClient' , 'gsheet_rows_for_fmt' , 'PermissionDeniedException' ] module-attribute \u00b6 GSheetClient ( config : Optional [ Config ] = None , read_only : bool = True ) \u00b6 Google API to easily handle GSheets and other files on GDrive By default, only the least permissive scope GSHEET_RO in case of read_only = True is used. Source code in pytanis/google.py def __init__ ( self , config : Optional [ Config ] = None , read_only : bool = True ): self . _read_only = read_only if read_only : self . _scopes = [ Scope . GSHEET_RO ] else : self . _scopes = [ Scope . GSHEET_RW ] if config is None : config = get_cfg () self . _config = config self . gc = gspread_client ( self . _scopes , config ) # gspread client for more functionality gc = gspread_client ( self . _scopes , config ) instance-attribute \u00b6 clear_gsheet ( spreadsheet_id : str , worksheet_name : str ) \u00b6 Clear the worksheet including values, formatting, filtering, etc. Source code in pytanis/google.py def clear_gsheet ( self , spreadsheet_id : str , worksheet_name : str ): \"\"\"Clear the worksheet including values, formatting, filtering, etc.\"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name , create_ws = False ) default_fmt = get_default_format ( worksheet . spreadsheet ) range = worksheet_range ( worksheet ) try : worksheet . clear () worksheet . clear_basic_filter () format_cell_range ( worksheet , range , default_fmt ) rules = get_conditional_format_rules ( worksheet ) rules . clear () rules . save () set_data_validation_for_cell_range ( worksheet , range , None ) except APIError as error : self . _exception_feedback ( error ) gsheet ( spreadsheet_id : str , worksheet_name : Optional [ str ] = None , create_ws : bool = False ) -> Union [ Worksheet , Spreadsheet ] \u00b6 Retrieve a Google sheet by its id and the name Open a Google sheet in your browser and check the URL to retrieve the id, e.g.: https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit ... If the spreadsheet as several worksheets (check the lower bar) then worksheet_name can be used to specify a specific one. Source code in pytanis/google.py def gsheet ( self , spreadsheet_id : str , worksheet_name : Optional [ str ] = None , create_ws : bool = False ) -> Union [ Worksheet , Spreadsheet ]: \"\"\"Retrieve a Google sheet by its id and the name Open a Google sheet in your browser and check the URL to retrieve the id, e.g.: https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit... If the spreadsheet as several worksheets (check the lower bar) then `worksheet_name` can be used to specify a specific one. \"\"\" spreadsheet = self . gc . open_by_key ( spreadsheet_id ) if worksheet_name is None : return spreadsheet else : if worksheet_name in [ ws . title for ws in spreadsheet . worksheets ()]: return spreadsheet . worksheet ( worksheet_name ) elif create_ws : worksheet = spreadsheet . add_worksheet ( title = worksheet_name , rows = 100 , cols = 20 ) self . _wait_for_worksheet ( spreadsheet_id , worksheet_name ) return worksheet else : return spreadsheet . worksheet ( worksheet_name ) # raises exception gsheet_as_df ( spreadsheet_id : str , worksheet_name : str , kwargs : Union [ str , bool , int ]) -> pd . DataFrame \u00b6 Returns a worksheet as dataframe Source code in pytanis/google.py def gsheet_as_df ( self , spreadsheet_id : str , worksheet_name : str , ** kwargs : Union [ str , bool , int ]) -> pd . DataFrame : \"\"\"Returns a worksheet as dataframe\"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name ) df = get_as_dataframe ( worksheet , ** kwargs ) # remove Nan rows & columns as they are exported by default df . dropna ( how = 'all' , inplace = True , axis = 0 ) df . dropna ( how = 'all' , inplace = True , axis = 1 ) return df recreate_token () \u00b6 Recreate the current token using the scopes given at initialization Source code in pytanis/google.py def recreate_token ( self ): \"\"\"Recreate the current token using the scopes given at initialization\"\"\" self . _config . Google . token_json . unlink ( missing_ok = True ) self . gc = gspread_client ( self . _scopes , self . _config ) save_df_as_gsheet ( df : pd . DataFrame , spreadsheet_id : str , worksheet_name : str , create_ws : bool = False , default_fmt : bool = True , kwargs : Union [ str , bool , int ]) \u00b6 Save the given dataframe as worksheet in a spreadsheet Make sure that the scope passed gives you write permissions Parameters: Name Type Description Default df pd . DataFrame dataframe to save required spreadsheet_id str id of the Google spreadsheet required worksheet_name str name of the worksheet within the spreadsheet required create_ws bool create the worksheet if non-existent False default_fmt bool apply default formatter BasicFormatter True **kwargs Union [ str , bool , int ] extra keyword arguments passed to set_with_dataframe {} Source code in pytanis/google.py def save_df_as_gsheet ( self , df : pd . DataFrame , spreadsheet_id : str , worksheet_name : str , create_ws : bool = False , default_fmt : bool = True , ** kwargs : Union [ str , bool , int ], ): \"\"\"Save the given dataframe as worksheet in a spreadsheet Make sure that the scope passed gives you write permissions Args: df: dataframe to save spreadsheet_id: id of the Google spreadsheet worksheet_name: name of the worksheet within the spreadsheet create_ws: create the worksheet if non-existent default_fmt: apply default formatter `BasicFormatter` **kwargs: extra keyword arguments passed to `set_with_dataframe` \"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name , create_ws = create_ws ) # make sure it's really only the dataframe, not some residue self . clear_gsheet ( spreadsheet_id , worksheet_name ) # ToDo: Starting from Python 3.9 on just use the | operator params = { ** dict ( resize = True ), ** dict ( ** kwargs )} # set sane defaults try : set_with_dataframe ( worksheet , df , ** params ) if default_fmt : format_with_dataframe ( worksheet , df ) except APIError as error : self . _exception_feedback ( error ) PermissionDeniedException \u00b6 Exception for APIError with status PERMISSION_DENIED Most likely thrown in cases when the scope is not GSHEET_RW or the token needs to be updated accordingly. Scope \u00b6 GDRIVE_FILE = 'https://www.googleapis.com/auth/drive.file' class-attribute \u00b6 GDRIVE_RO = 'https://www.googleapis.com/auth/drive.readonly' class-attribute \u00b6 GDRIVE_RW = 'https://www.googleapis.com/auth/drive' class-attribute \u00b6 GSHEET_RO = 'https://www.googleapis.com/auth/spreadsheets.readonly' class-attribute \u00b6 GSHEET_RW = 'https://www.googleapis.com/auth/spreadsheets' class-attribute \u00b6 gsheet_col ( idx : int ) -> str \u00b6 Convert a column index to Google Sheet range notation, e.g. A, BE, etc. Source code in pytanis/google.py def gsheet_col ( idx : int ) -> str : \"\"\"Convert a column index to Google Sheet range notation, e.g. A, BE, etc.\"\"\" idx += 1 chars = [] while idx : chars . append ( string . ascii_uppercase [( idx % 26 ) - 1 ]) idx //= 27 return \"\" . join ( chars [:: - 1 ]) gsheet_rows_for_fmt ( mask : pd . Series , n_cols : int ) -> List [ str ] \u00b6 Get the Google Sheet row range specifications for formatting Source code in pytanis/google.py def gsheet_rows_for_fmt ( mask : pd . Series , n_cols : int ) -> List [ str ]: \"\"\"Get the Google Sheet row range specifications for formatting\"\"\" rows = pd . Series ( np . argwhere ( mask . to_numpy ()) . reshape ( - 1 ) + 2 ) # +2 since 1-index and header last_col = gsheet_col ( n_cols - 1 ) # last index rows = rows . map ( lambda x : f \"A { x } : { last_col }{ x } \" ) return rows . to_list () gspread_client ( scopes : List [ Scope ], config : Config ) -> gspread . client . Client \u00b6 Creates the GSheet client using our configuration Read GSpread for usage details Source code in pytanis/google.py def gspread_client ( scopes : List [ Scope ], config : Config ) -> gspread . client . Client : \"\"\"Creates the GSheet client using our configuration Read [GSpread](https://docs.gspread.org/) for usage details \"\"\" if ( secret_path := config . Google . client_secret_json ) is None : raise RuntimeError ( \"You have to set Google.client_secret_json in your config.toml!\" ) if ( token_path := config . Google . token_json ) is None : raise RuntimeError ( \"You have to set Google.token_json in your config.toml!\" ) gc = gspread . oauth ( scopes = [ scope . value for scope in scopes ], credentials_filename = str ( secret_path ), authorized_user_filename = str ( token_path ), ) return gc mark_rows ( worksheet , mask : pd . Series , color : ColorType ) \u00b6 Mark rows specified by a mask (condition) with a given color Color can be a tuple of RGB values or a Matplotlib string specification: https://matplotlib.org/stable/gallery/color/named_colors.html#css-colors Source code in pytanis/google.py def mark_rows ( worksheet , mask : pd . Series , color : ColorType ): \"\"\"Mark rows specified by a mask (condition) with a given color Color can be a tuple of RGB values or a Matplotlib string specification: https://matplotlib.org/stable/gallery/color/named_colors.html#css-colors \"\"\" rows = gsheet_rows_for_fmt ( mask , worksheet . col_count ) fmt = cellFormat ( backgroundColor = Color ( * to_rgb ( color ))) if rows : format_cell_ranges ( worksheet , [( rng , fmt ) for rng in rows ]) worksheet_range ( worksheet : Worksheet ) -> str \u00b6 Returns a range encompassing the whole worksheet Source code in pytanis/google.py def worksheet_range ( worksheet : Worksheet ) -> str : \"\"\"Returns a range encompassing the whole worksheet\"\"\" last_row = worksheet . row_count last_col = gsheet_col ( worksheet . col_count ) return f \"A1: { last_col }{ last_row } \"","title":"google"},{"location":"reference/pytanis/google/#pytanis.google","text":"Functionality around the Google's Spreadsheet API Additional Documentation Google GSheet API GSpread GSpread-Dataframe GSpread-Formatting","title":"google"},{"location":"reference/pytanis/google/#pytanis.google.ColorType","text":"","title":"ColorType"},{"location":"reference/pytanis/google/#pytanis.google.__all__","text":"","title":"__all__"},{"location":"reference/pytanis/google/#pytanis.google.GSheetClient","text":"Google API to easily handle GSheets and other files on GDrive By default, only the least permissive scope GSHEET_RO in case of read_only = True is used. Source code in pytanis/google.py def __init__ ( self , config : Optional [ Config ] = None , read_only : bool = True ): self . _read_only = read_only if read_only : self . _scopes = [ Scope . GSHEET_RO ] else : self . _scopes = [ Scope . GSHEET_RW ] if config is None : config = get_cfg () self . _config = config self . gc = gspread_client ( self . _scopes , config ) # gspread client for more functionality","title":"GSheetClient"},{"location":"reference/pytanis/google/#pytanis.google.GSheetClient.gc","text":"","title":"gc"},{"location":"reference/pytanis/google/#pytanis.google.GSheetClient.clear_gsheet","text":"Clear the worksheet including values, formatting, filtering, etc. Source code in pytanis/google.py def clear_gsheet ( self , spreadsheet_id : str , worksheet_name : str ): \"\"\"Clear the worksheet including values, formatting, filtering, etc.\"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name , create_ws = False ) default_fmt = get_default_format ( worksheet . spreadsheet ) range = worksheet_range ( worksheet ) try : worksheet . clear () worksheet . clear_basic_filter () format_cell_range ( worksheet , range , default_fmt ) rules = get_conditional_format_rules ( worksheet ) rules . clear () rules . save () set_data_validation_for_cell_range ( worksheet , range , None ) except APIError as error : self . _exception_feedback ( error )","title":"clear_gsheet()"},{"location":"reference/pytanis/google/#pytanis.google.GSheetClient.gsheet","text":"Retrieve a Google sheet by its id and the name Open a Google sheet in your browser and check the URL to retrieve the id, e.g.: https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit ... If the spreadsheet as several worksheets (check the lower bar) then worksheet_name can be used to specify a specific one. Source code in pytanis/google.py def gsheet ( self , spreadsheet_id : str , worksheet_name : Optional [ str ] = None , create_ws : bool = False ) -> Union [ Worksheet , Spreadsheet ]: \"\"\"Retrieve a Google sheet by its id and the name Open a Google sheet in your browser and check the URL to retrieve the id, e.g.: https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit... If the spreadsheet as several worksheets (check the lower bar) then `worksheet_name` can be used to specify a specific one. \"\"\" spreadsheet = self . gc . open_by_key ( spreadsheet_id ) if worksheet_name is None : return spreadsheet else : if worksheet_name in [ ws . title for ws in spreadsheet . worksheets ()]: return spreadsheet . worksheet ( worksheet_name ) elif create_ws : worksheet = spreadsheet . add_worksheet ( title = worksheet_name , rows = 100 , cols = 20 ) self . _wait_for_worksheet ( spreadsheet_id , worksheet_name ) return worksheet else : return spreadsheet . worksheet ( worksheet_name ) # raises exception","title":"gsheet()"},{"location":"reference/pytanis/google/#pytanis.google.GSheetClient.gsheet_as_df","text":"Returns a worksheet as dataframe Source code in pytanis/google.py def gsheet_as_df ( self , spreadsheet_id : str , worksheet_name : str , ** kwargs : Union [ str , bool , int ]) -> pd . DataFrame : \"\"\"Returns a worksheet as dataframe\"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name ) df = get_as_dataframe ( worksheet , ** kwargs ) # remove Nan rows & columns as they are exported by default df . dropna ( how = 'all' , inplace = True , axis = 0 ) df . dropna ( how = 'all' , inplace = True , axis = 1 ) return df","title":"gsheet_as_df()"},{"location":"reference/pytanis/google/#pytanis.google.GSheetClient.recreate_token","text":"Recreate the current token using the scopes given at initialization Source code in pytanis/google.py def recreate_token ( self ): \"\"\"Recreate the current token using the scopes given at initialization\"\"\" self . _config . Google . token_json . unlink ( missing_ok = True ) self . gc = gspread_client ( self . _scopes , self . _config )","title":"recreate_token()"},{"location":"reference/pytanis/google/#pytanis.google.GSheetClient.save_df_as_gsheet","text":"Save the given dataframe as worksheet in a spreadsheet Make sure that the scope passed gives you write permissions Parameters: Name Type Description Default df pd . DataFrame dataframe to save required spreadsheet_id str id of the Google spreadsheet required worksheet_name str name of the worksheet within the spreadsheet required create_ws bool create the worksheet if non-existent False default_fmt bool apply default formatter BasicFormatter True **kwargs Union [ str , bool , int ] extra keyword arguments passed to set_with_dataframe {} Source code in pytanis/google.py def save_df_as_gsheet ( self , df : pd . DataFrame , spreadsheet_id : str , worksheet_name : str , create_ws : bool = False , default_fmt : bool = True , ** kwargs : Union [ str , bool , int ], ): \"\"\"Save the given dataframe as worksheet in a spreadsheet Make sure that the scope passed gives you write permissions Args: df: dataframe to save spreadsheet_id: id of the Google spreadsheet worksheet_name: name of the worksheet within the spreadsheet create_ws: create the worksheet if non-existent default_fmt: apply default formatter `BasicFormatter` **kwargs: extra keyword arguments passed to `set_with_dataframe` \"\"\" worksheet = self . gsheet ( spreadsheet_id , worksheet_name , create_ws = create_ws ) # make sure it's really only the dataframe, not some residue self . clear_gsheet ( spreadsheet_id , worksheet_name ) # ToDo: Starting from Python 3.9 on just use the | operator params = { ** dict ( resize = True ), ** dict ( ** kwargs )} # set sane defaults try : set_with_dataframe ( worksheet , df , ** params ) if default_fmt : format_with_dataframe ( worksheet , df ) except APIError as error : self . _exception_feedback ( error )","title":"save_df_as_gsheet()"},{"location":"reference/pytanis/google/#pytanis.google.PermissionDeniedException","text":"Exception for APIError with status PERMISSION_DENIED Most likely thrown in cases when the scope is not GSHEET_RW or the token needs to be updated accordingly.","title":"PermissionDeniedException"},{"location":"reference/pytanis/google/#pytanis.google.Scope","text":"","title":"Scope"},{"location":"reference/pytanis/google/#pytanis.google.Scope.GDRIVE_FILE","text":"","title":"GDRIVE_FILE"},{"location":"reference/pytanis/google/#pytanis.google.Scope.GDRIVE_RO","text":"","title":"GDRIVE_RO"},{"location":"reference/pytanis/google/#pytanis.google.Scope.GDRIVE_RW","text":"","title":"GDRIVE_RW"},{"location":"reference/pytanis/google/#pytanis.google.Scope.GSHEET_RO","text":"","title":"GSHEET_RO"},{"location":"reference/pytanis/google/#pytanis.google.Scope.GSHEET_RW","text":"","title":"GSHEET_RW"},{"location":"reference/pytanis/google/#pytanis.google.gsheet_col","text":"Convert a column index to Google Sheet range notation, e.g. A, BE, etc. Source code in pytanis/google.py def gsheet_col ( idx : int ) -> str : \"\"\"Convert a column index to Google Sheet range notation, e.g. A, BE, etc.\"\"\" idx += 1 chars = [] while idx : chars . append ( string . ascii_uppercase [( idx % 26 ) - 1 ]) idx //= 27 return \"\" . join ( chars [:: - 1 ])","title":"gsheet_col()"},{"location":"reference/pytanis/google/#pytanis.google.gsheet_rows_for_fmt","text":"Get the Google Sheet row range specifications for formatting Source code in pytanis/google.py def gsheet_rows_for_fmt ( mask : pd . Series , n_cols : int ) -> List [ str ]: \"\"\"Get the Google Sheet row range specifications for formatting\"\"\" rows = pd . Series ( np . argwhere ( mask . to_numpy ()) . reshape ( - 1 ) + 2 ) # +2 since 1-index and header last_col = gsheet_col ( n_cols - 1 ) # last index rows = rows . map ( lambda x : f \"A { x } : { last_col }{ x } \" ) return rows . to_list ()","title":"gsheet_rows_for_fmt()"},{"location":"reference/pytanis/google/#pytanis.google.gspread_client","text":"Creates the GSheet client using our configuration Read GSpread for usage details Source code in pytanis/google.py def gspread_client ( scopes : List [ Scope ], config : Config ) -> gspread . client . Client : \"\"\"Creates the GSheet client using our configuration Read [GSpread](https://docs.gspread.org/) for usage details \"\"\" if ( secret_path := config . Google . client_secret_json ) is None : raise RuntimeError ( \"You have to set Google.client_secret_json in your config.toml!\" ) if ( token_path := config . Google . token_json ) is None : raise RuntimeError ( \"You have to set Google.token_json in your config.toml!\" ) gc = gspread . oauth ( scopes = [ scope . value for scope in scopes ], credentials_filename = str ( secret_path ), authorized_user_filename = str ( token_path ), ) return gc","title":"gspread_client()"},{"location":"reference/pytanis/google/#pytanis.google.mark_rows","text":"Mark rows specified by a mask (condition) with a given color Color can be a tuple of RGB values or a Matplotlib string specification: https://matplotlib.org/stable/gallery/color/named_colors.html#css-colors Source code in pytanis/google.py def mark_rows ( worksheet , mask : pd . Series , color : ColorType ): \"\"\"Mark rows specified by a mask (condition) with a given color Color can be a tuple of RGB values or a Matplotlib string specification: https://matplotlib.org/stable/gallery/color/named_colors.html#css-colors \"\"\" rows = gsheet_rows_for_fmt ( mask , worksheet . col_count ) fmt = cellFormat ( backgroundColor = Color ( * to_rgb ( color ))) if rows : format_cell_ranges ( worksheet , [( rng , fmt ) for rng in rows ])","title":"mark_rows()"},{"location":"reference/pytanis/google/#pytanis.google.worksheet_range","text":"Returns a range encompassing the whole worksheet Source code in pytanis/google.py def worksheet_range ( worksheet : Worksheet ) -> str : \"\"\"Returns a range encompassing the whole worksheet\"\"\" last_row = worksheet . row_count last_col = gsheet_col ( worksheet . col_count ) return f \"A1: { last_col }{ last_row } \"","title":"worksheet_range()"},{"location":"reference/pytanis/highs/","text":"highs \u00b6 Some helper functions for HiGHS ( https://highs.dev/ ) pyomo and highspy need to be installed, consider pip install 'pytanis[all]' . ToDo Introduce a function check_model_vars that checks the names of variables and sets to be alphanumeric before reading in a solution in set_solution_from_file . read_sol_file ( file_name : str ) -> Iterator [ Tuple [ str , float ]] \u00b6 Read a solution file from HiGHS solver with default output style We assume here that your variable names are alphanumeric! No underscores, no dashes, etc.! Source code in pytanis/highs.py def read_sol_file ( file_name : str ) -> Iterator [ Tuple [ str , float ]]: \"\"\"Read a solution file from HiGHS solver with default output style Attention: We assume here that your variable names are alphanumeric! No underscores, no dashes, etc.! \"\"\" line_re = re . compile ( r \"(\\w+)(?:\\((\\w+)\\))?(_binary_indicator_var)? ([.\\w-]+)\" ) with open ( file_name ) as fh : while True : line = fh . readline () if line . startswith ( \"# Columns\" ): break for line in fh . readlines (): if line . startswith ( \"#\" ): break if ( match_obj := line_re . match ( line . strip ())) is None : raise RuntimeError ( f \"Could not interpret line: { line } \" ) else : var_name , idx , binary , val = match_obj . groups () val = float ( val ) binary = binary . replace ( '_' , '.' , 1 ) if binary else \"\" if idx is None : yield f \" { var_name }{ binary } \" , val else : idx = idx . replace ( '_' , ',' ) yield f \" { var_name } [ { idx } ] { binary } \" , val set_solution_from_file ( model : ConcreteModel , file_name : str ) \u00b6 Given a HiGHS solution file set the variables of a Pyomo model accordingly. This is a workaround to set a Pyomo model's variables to the solution from a HiGHS solution file. Source code in pytanis/highs.py def set_solution_from_file ( model : ConcreteModel , file_name : str ): \"\"\"Given a HiGHS solution file set the variables of a Pyomo model accordingly. This is a workaround to set a Pyomo model's variables to the solution from a HiGHS solution file. \"\"\" # just to initialize we read it in using HiGHS. The result is incorrect though, # as the order of variables is mixed up quite often. We fix this below! opt = Highs () opt . set_instance ( model ) opt . _solver_model . readSolution ( file_name , 0 ) opt . _sol = opt . _solver_model . getSolution () opt . load_vars () # read the actual mapping of the variable names to the values file_sol = { name : val for name , val in read_sol_file ( file_name )} # overwrite the values of the variables again using the symbolic names from the file for v , ref_info in opt . _referenced_variables . items (): using_cons , using_sos , using_obj = ref_info if using_cons or using_sos or ( using_obj is not None ): var = opt . _vars [ v ][ 0 ] var . set_value ( file_sol [ var . name ], skip_validation = True )","title":"highs"},{"location":"reference/pytanis/highs/#pytanis.highs","text":"Some helper functions for HiGHS ( https://highs.dev/ ) pyomo and highspy need to be installed, consider pip install 'pytanis[all]' . ToDo Introduce a function check_model_vars that checks the names of variables and sets to be alphanumeric before reading in a solution in set_solution_from_file .","title":"highs"},{"location":"reference/pytanis/highs/#pytanis.highs.read_sol_file","text":"Read a solution file from HiGHS solver with default output style We assume here that your variable names are alphanumeric! No underscores, no dashes, etc.! Source code in pytanis/highs.py def read_sol_file ( file_name : str ) -> Iterator [ Tuple [ str , float ]]: \"\"\"Read a solution file from HiGHS solver with default output style Attention: We assume here that your variable names are alphanumeric! No underscores, no dashes, etc.! \"\"\" line_re = re . compile ( r \"(\\w+)(?:\\((\\w+)\\))?(_binary_indicator_var)? ([.\\w-]+)\" ) with open ( file_name ) as fh : while True : line = fh . readline () if line . startswith ( \"# Columns\" ): break for line in fh . readlines (): if line . startswith ( \"#\" ): break if ( match_obj := line_re . match ( line . strip ())) is None : raise RuntimeError ( f \"Could not interpret line: { line } \" ) else : var_name , idx , binary , val = match_obj . groups () val = float ( val ) binary = binary . replace ( '_' , '.' , 1 ) if binary else \"\" if idx is None : yield f \" { var_name }{ binary } \" , val else : idx = idx . replace ( '_' , ',' ) yield f \" { var_name } [ { idx } ] { binary } \" , val","title":"read_sol_file()"},{"location":"reference/pytanis/highs/#pytanis.highs.set_solution_from_file","text":"Given a HiGHS solution file set the variables of a Pyomo model accordingly. This is a workaround to set a Pyomo model's variables to the solution from a HiGHS solution file. Source code in pytanis/highs.py def set_solution_from_file ( model : ConcreteModel , file_name : str ): \"\"\"Given a HiGHS solution file set the variables of a Pyomo model accordingly. This is a workaround to set a Pyomo model's variables to the solution from a HiGHS solution file. \"\"\" # just to initialize we read it in using HiGHS. The result is incorrect though, # as the order of variables is mixed up quite often. We fix this below! opt = Highs () opt . set_instance ( model ) opt . _solver_model . readSolution ( file_name , 0 ) opt . _sol = opt . _solver_model . getSolution () opt . load_vars () # read the actual mapping of the variable names to the values file_sol = { name : val for name , val in read_sol_file ( file_name )} # overwrite the values of the variables again using the symbolic names from the file for v , ref_info in opt . _referenced_variables . items (): using_cons , using_sos , using_obj = ref_info if using_cons or using_sos or ( using_obj is not None ): var = opt . _vars [ v ][ 0 ] var . set_value ( file_sol [ var . name ], skip_validation = True )","title":"set_solution_from_file()"},{"location":"reference/pytanis/review/","text":"review \u00b6 Tools related to assigning proposals to reviewers In Pretalx assignments can be done in two directions Assign proposals to reviewers Assign reviewers to proposals We will always assume direction 1. in this file when we talk about an assignment. So in Operation Research-speak, resources get assigned tasks, not the other way around. The time needed for the task of reviewing a proposal is quite homogeneous while the number of reviews a single reviewer may highly vary. Also, we will rather use the name submission instead of proposal as this also reflects the naming of the Pretalx API. We follow the convention over configuration principle here and thus check out the Col class for the naming of columns. Col \u00b6 Additional conventions used for reviews address_as = 'Address as' class-attribute \u00b6 all_proposals = 'All Proposals' class-attribute \u00b6 committee_contact = 'Committee Contact' class-attribute \u00b6 curr_assignments = 'Current Assignments' class-attribute \u00b6 done_nreviews = 'Done #Reviews' class-attribute \u00b6 nassignments = '#Assignments' class-attribute \u00b6 nvotes = '#Votes' class-attribute \u00b6 pretalx_activated = 'Pretalx activated' class-attribute \u00b6 rem_nreviews = 'Remaining #Reviews' class-attribute \u00b6 target_nreviews = 'Target #Reviews' class-attribute \u00b6 track_prefs = 'Track Preferences' class-attribute \u00b6 vote_score = 'Vote Score' class-attribute \u00b6 read_assignment_as_df ( file_path : Path ) -> pd . DataFrame \u00b6 Reads an assignment and returns a dataframe Source code in pytanis/review.py def read_assignment_as_df ( file_path : Path ) -> pd . DataFrame : \"\"\"Reads an assignment and returns a dataframe\"\"\" with open ( file_path ) as fh : curr_assign = json . load ( fh ) df = pd . DataFrame ({ k : [ v ] for k , v in curr_assign . items ()}) df = df . T . rename_axis ( index = Col . email ) . rename ( columns = { 0 : Col . curr_assignments }) . reset_index () return df save_assignments_as_json ( df : pd . DataFrame , file_path : Union [ Path , str ]) \u00b6 Save the dataframe as proposal assignment JSON file Source code in pytanis/review.py def save_assignments_as_json ( df : pd . DataFrame , file_path : Union [ Path , str ]): \"\"\"Save the dataframe as proposal assignment JSON file\"\"\" file_path = Path ( file_path ) df = df . loc [:, [ Col . email , Col . curr_assignments ]] json_dct = json . loads ( df . set_index ( Col . email ) . to_json ())[ Col . curr_assignments ] # prettify the json string for human-edit-ability if reviewers need to be dropped later json_str = json . dumps ( json_dct ) . replace ( \"{\" , \"{ \\n \" ) . replace ( \"], \" , \"], \\n \" ) . replace ( \"]}\" , \"] \\n }\" ) with open ( file_path , \"w\" ) as fh : fh . write ( json_str )","title":"review"},{"location":"reference/pytanis/review/#pytanis.review","text":"Tools related to assigning proposals to reviewers In Pretalx assignments can be done in two directions Assign proposals to reviewers Assign reviewers to proposals We will always assume direction 1. in this file when we talk about an assignment. So in Operation Research-speak, resources get assigned tasks, not the other way around. The time needed for the task of reviewing a proposal is quite homogeneous while the number of reviews a single reviewer may highly vary. Also, we will rather use the name submission instead of proposal as this also reflects the naming of the Pretalx API. We follow the convention over configuration principle here and thus check out the Col class for the naming of columns.","title":"review"},{"location":"reference/pytanis/review/#pytanis.review.Col","text":"Additional conventions used for reviews","title":"Col"},{"location":"reference/pytanis/review/#pytanis.review.Col.address_as","text":"","title":"address_as"},{"location":"reference/pytanis/review/#pytanis.review.Col.all_proposals","text":"","title":"all_proposals"},{"location":"reference/pytanis/review/#pytanis.review.Col.committee_contact","text":"","title":"committee_contact"},{"location":"reference/pytanis/review/#pytanis.review.Col.curr_assignments","text":"","title":"curr_assignments"},{"location":"reference/pytanis/review/#pytanis.review.Col.done_nreviews","text":"","title":"done_nreviews"},{"location":"reference/pytanis/review/#pytanis.review.Col.nassignments","text":"","title":"nassignments"},{"location":"reference/pytanis/review/#pytanis.review.Col.nvotes","text":"","title":"nvotes"},{"location":"reference/pytanis/review/#pytanis.review.Col.pretalx_activated","text":"","title":"pretalx_activated"},{"location":"reference/pytanis/review/#pytanis.review.Col.rem_nreviews","text":"","title":"rem_nreviews"},{"location":"reference/pytanis/review/#pytanis.review.Col.target_nreviews","text":"","title":"target_nreviews"},{"location":"reference/pytanis/review/#pytanis.review.Col.track_prefs","text":"","title":"track_prefs"},{"location":"reference/pytanis/review/#pytanis.review.Col.vote_score","text":"","title":"vote_score"},{"location":"reference/pytanis/review/#pytanis.review.read_assignment_as_df","text":"Reads an assignment and returns a dataframe Source code in pytanis/review.py def read_assignment_as_df ( file_path : Path ) -> pd . DataFrame : \"\"\"Reads an assignment and returns a dataframe\"\"\" with open ( file_path ) as fh : curr_assign = json . load ( fh ) df = pd . DataFrame ({ k : [ v ] for k , v in curr_assign . items ()}) df = df . T . rename_axis ( index = Col . email ) . rename ( columns = { 0 : Col . curr_assignments }) . reset_index () return df","title":"read_assignment_as_df()"},{"location":"reference/pytanis/review/#pytanis.review.save_assignments_as_json","text":"Save the dataframe as proposal assignment JSON file Source code in pytanis/review.py def save_assignments_as_json ( df : pd . DataFrame , file_path : Union [ Path , str ]): \"\"\"Save the dataframe as proposal assignment JSON file\"\"\" file_path = Path ( file_path ) df = df . loc [:, [ Col . email , Col . curr_assignments ]] json_dct = json . loads ( df . set_index ( Col . email ) . to_json ())[ Col . curr_assignments ] # prettify the json string for human-edit-ability if reviewers need to be dropped later json_str = json . dumps ( json_dct ) . replace ( \"{\" , \"{ \\n \" ) . replace ( \"], \" , \"], \\n \" ) . replace ( \"]}\" , \"] \\n }\" ) with open ( file_path , \"w\" ) as fh : fh . write ( json_str )","title":"save_assignments_as_json()"},{"location":"reference/pytanis/utils/","text":"utils \u00b6 Additional utilities RT = TypeVar ( 'RT' ) module-attribute \u00b6 implode ( df : pd . DataFrame , cols : Union [ str , List [ str ]]) -> pd . DataFrame \u00b6 The inverse of Pandas' explode Source code in pytanis/utils.py def implode ( df : pd . DataFrame , cols : Union [ str , List [ str ]]) -> pd . DataFrame : \"\"\"The inverse of Pandas' explode\"\"\" if not isinstance ( cols , list ): cols = [ cols ] orig_cols = df . columns grp_cols = [ col for col in df . columns if col not in cols ] df = df . groupby ( grp_cols , group_keys = True , dropna = False ) . aggregate ({ col : lambda x : x . tolist () for col in cols }) df . reset_index ( inplace = True ) df = df . loc [:, orig_cols ] return df pretty_timedelta ( seconds : int ) -> str \u00b6 Converts timedelta in seconds to human-readable string Parameters: Name Type Description Default seconds int time delta in seconds required Returns: Type Description str timedelta as pretty string Source code in pytanis/utils.py def pretty_timedelta ( seconds : int ) -> str : \"\"\"Converts timedelta in seconds to human-readable string Args: seconds: time delta in seconds Returns: timedelta as pretty string \"\"\" sign = '-' if seconds < 0 else '' seconds = abs ( int ( seconds )) days , seconds = divmod ( seconds , 86400 ) hours , seconds = divmod ( seconds , 3600 ) minutes , seconds = divmod ( seconds , 60 ) if days > 0 : return ' {}{} d {} h {} m {} s' . format ( sign , days , hours , minutes , seconds ) elif hours > 0 : return ' {}{} h {} m {} s' . format ( sign , hours , minutes , seconds ) elif minutes > 0 : return ' {}{} m {} s' . format ( sign , minutes , seconds ) else : return ' {}{} s' . format ( sign , seconds ) rm_keys ( keys : Union [ Any , List [ Any ]], dct : Dict [ Any , Any ]) -> Dict [ Any , Any ] \u00b6 Return a copy with keys removed from dictionary Source code in pytanis/utils.py def rm_keys ( keys : Union [ Any , List [ Any ]], dct : Dict [ Any , Any ], ) -> Dict [ Any , Any ]: \"\"\"Return a copy with keys removed from dictionary\"\"\" if not isinstance ( keys , list ): keys = [ keys ] return { k : v for k , v in dct . items () if k not in keys } throttle ( calls : int , seconds : int = 1 ) -> Callable [[ Callable [ ... , RT ]], Callable [ ... , RT ]] \u00b6 Decorator for throttling a function to number of calls per seconds Parameters: Name Type Description Default calls int number of calls per interval required seconds int number of seconds in interval 1 Returns: Type Description Callable [[ Callable [..., RT ]], Callable [..., RT ]] wrapped function Source code in pytanis/utils.py def throttle ( calls : int , seconds : int = 1 ) -> Callable [[ Callable [ ... , RT ]], Callable [ ... , RT ]]: \"\"\"Decorator for throttling a function to number of calls per seconds Args: calls: number of calls per interval seconds: number of seconds in interval Returns: wrapped function \"\"\" assert isinstance ( calls , int ), 'number of calls must be integer' assert isinstance ( seconds , int ), 'number of seconds must be integer' def decorator ( func : Callable [ ... , RT ]) -> Callable [ ... , RT ]: # keeps track of the last calls last_calls : List [ float ] = list () @functools . wraps ( func ) def wrapper ( * args , ** kwargs ) -> RT : curr_time = time . time () if last_calls : # remove calls from last_calls list older than interval in seconds idx_old_calls = [ i for i , t in enumerate ( last_calls ) if t < curr_time - seconds ] if idx_old_calls : del last_calls [: idx_old_calls [ - 1 ]] if len ( last_calls ) >= calls : idx = len ( last_calls ) - calls delta = fabs ( 1 - curr_time + last_calls [ idx ]) logger = get_logger () logger . debug ( \"stalling call\" , func = func . __name__ , secs = delta ) time . sleep ( delta ) resp = func ( * args , ** kwargs ) last_calls . append ( time . time ()) return resp return wrapper return decorator","title":"utils"},{"location":"reference/pytanis/utils/#pytanis.utils","text":"Additional utilities","title":"utils"},{"location":"reference/pytanis/utils/#pytanis.utils.RT","text":"","title":"RT"},{"location":"reference/pytanis/utils/#pytanis.utils.implode","text":"The inverse of Pandas' explode Source code in pytanis/utils.py def implode ( df : pd . DataFrame , cols : Union [ str , List [ str ]]) -> pd . DataFrame : \"\"\"The inverse of Pandas' explode\"\"\" if not isinstance ( cols , list ): cols = [ cols ] orig_cols = df . columns grp_cols = [ col for col in df . columns if col not in cols ] df = df . groupby ( grp_cols , group_keys = True , dropna = False ) . aggregate ({ col : lambda x : x . tolist () for col in cols }) df . reset_index ( inplace = True ) df = df . loc [:, orig_cols ] return df","title":"implode()"},{"location":"reference/pytanis/utils/#pytanis.utils.pretty_timedelta","text":"Converts timedelta in seconds to human-readable string Parameters: Name Type Description Default seconds int time delta in seconds required Returns: Type Description str timedelta as pretty string Source code in pytanis/utils.py def pretty_timedelta ( seconds : int ) -> str : \"\"\"Converts timedelta in seconds to human-readable string Args: seconds: time delta in seconds Returns: timedelta as pretty string \"\"\" sign = '-' if seconds < 0 else '' seconds = abs ( int ( seconds )) days , seconds = divmod ( seconds , 86400 ) hours , seconds = divmod ( seconds , 3600 ) minutes , seconds = divmod ( seconds , 60 ) if days > 0 : return ' {}{} d {} h {} m {} s' . format ( sign , days , hours , minutes , seconds ) elif hours > 0 : return ' {}{} h {} m {} s' . format ( sign , hours , minutes , seconds ) elif minutes > 0 : return ' {}{} m {} s' . format ( sign , minutes , seconds ) else : return ' {}{} s' . format ( sign , seconds )","title":"pretty_timedelta()"},{"location":"reference/pytanis/utils/#pytanis.utils.rm_keys","text":"Return a copy with keys removed from dictionary Source code in pytanis/utils.py def rm_keys ( keys : Union [ Any , List [ Any ]], dct : Dict [ Any , Any ], ) -> Dict [ Any , Any ]: \"\"\"Return a copy with keys removed from dictionary\"\"\" if not isinstance ( keys , list ): keys = [ keys ] return { k : v for k , v in dct . items () if k not in keys }","title":"rm_keys()"},{"location":"reference/pytanis/utils/#pytanis.utils.throttle","text":"Decorator for throttling a function to number of calls per seconds Parameters: Name Type Description Default calls int number of calls per interval required seconds int number of seconds in interval 1 Returns: Type Description Callable [[ Callable [..., RT ]], Callable [..., RT ]] wrapped function Source code in pytanis/utils.py def throttle ( calls : int , seconds : int = 1 ) -> Callable [[ Callable [ ... , RT ]], Callable [ ... , RT ]]: \"\"\"Decorator for throttling a function to number of calls per seconds Args: calls: number of calls per interval seconds: number of seconds in interval Returns: wrapped function \"\"\" assert isinstance ( calls , int ), 'number of calls must be integer' assert isinstance ( seconds , int ), 'number of seconds must be integer' def decorator ( func : Callable [ ... , RT ]) -> Callable [ ... , RT ]: # keeps track of the last calls last_calls : List [ float ] = list () @functools . wraps ( func ) def wrapper ( * args , ** kwargs ) -> RT : curr_time = time . time () if last_calls : # remove calls from last_calls list older than interval in seconds idx_old_calls = [ i for i , t in enumerate ( last_calls ) if t < curr_time - seconds ] if idx_old_calls : del last_calls [: idx_old_calls [ - 1 ]] if len ( last_calls ) >= calls : idx = len ( last_calls ) - calls delta = fabs ( 1 - curr_time + last_calls [ idx ]) logger = get_logger () logger . debug ( \"stalling call\" , func = func . __name__ , secs = delta ) time . sleep ( delta ) resp = func ( * args , ** kwargs ) last_calls . append ( time . time ()) return resp return wrapper return decorator","title":"throttle()"},{"location":"reference/pytanis/helpdesk/","text":"helpdesk \u00b6 Functionality around the HelpDesk / LiveChat API __all__ = [ 'HelpDeskClient' , 'Mail' , 'MailClient' , 'Recipient' ] module-attribute \u00b6 HelpDeskClient ( config : Optional [ Config ] = None ) \u00b6 Source code in pytanis/helpdesk/client.py def __init__ ( self , config : Optional [ Config ] = None ): if config is None : config = get_cfg () self . _config = config # Important: Always use a custom User-Agent, never a generic one. # Generic User-Agents are filtered by helpdesk to reduce spam. self . _headers = { \"User-Agent\" : \"Pytanis\" } self . _get_throttled = self . _get self . _post_throttled = self . _post self . set_throttling ( 2 , 1 ) # we are nice by default create_ticket ( ticket : NewTicket ) \u00b6 Source code in pytanis/helpdesk/client.py def create_ticket ( self , ticket : NewTicket ): return self . post ( \"tickets\" , data = ticket . dict ()) get ( endpoint : str , params : Optional [ Dict [ str , str ]] = None ) -> JSON \u00b6 Retrieve data via throttled GET request and return the JSON Source code in pytanis/helpdesk/client.py def get ( self , endpoint : str , params : Optional [ Dict [ str , str ]] = None ) -> JSON : \"\"\"Retrieve data via throttled GET request and return the JSON\"\"\" resp = self . _get_throttled ( endpoint , params ) resp . raise_for_status () return resp . json () list_agents () -> List [ Agent ] \u00b6 Source code in pytanis/helpdesk/client.py def list_agents ( self ) -> List [ Agent ]: agents = self . get ( \"agents\" ) assert isinstance ( agents , List ) return [ Agent . parse_obj ( dct ) for dct in agents ] list_teams () -> List [ Team ] \u00b6 Source code in pytanis/helpdesk/client.py def list_teams ( self ) -> List [ Team ]: teams = self . get ( \"teams\" ) assert isinstance ( teams , List ) return [ Team . parse_obj ( dct ) for dct in teams ] post ( endpoint : str , data : Dict [ str , Any ], params : Optional [ Dict [ str , str ]] = None ) -> JSON \u00b6 Source code in pytanis/helpdesk/client.py def post ( self , endpoint : str , data : Dict [ str , Any ], params : Optional [ Dict [ str , str ]] = None ) -> JSON : resp = self . _post_throttled ( endpoint , data , params ) resp . raise_for_status () return resp . json () set_throttling ( calls : int , seconds : int ) \u00b6 Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/helpdesk/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . debug ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get ) self . _post_throttled = throttle ( calls , seconds )( self . _post ) Mail \u00b6 Mail template Use the data field to store additional information You can use the typical Format String Syntax and the objects recipient and mail to access metadata to complement the template, e.g.: Hello {recipient.address_as}, We hope it's ok to address you your first name rather than using your full name being {recipient.name}. Have you read the email's subject '{mail.subject}'? How is your work right now at {recipient.data.company}? Cheers! agent_id : str class-attribute \u00b6 data : Optional [ MetaData ] class-attribute \u00b6 recipients : List [ Recipient ] class-attribute \u00b6 status : str = 'solved' class-attribute \u00b6 subject : str class-attribute \u00b6 team_id : str class-attribute \u00b6 text : str class-attribute \u00b6 MailClient ( helpdesk_client : Optional [ HelpDeskClient ] = None ) \u00b6 Mail client for mass mails over HelpDesk Source code in pytanis/helpdesk/mail.py def __init__ ( self , helpdesk_client : Optional [ HelpDeskClient ] = None ): if helpdesk_client is None : helpdesk_client = HelpDeskClient () self . _helpdesk_client = helpdesk_client self . dry_run : Callable [[ NewTicket ], None ] = self . print_new_ticket dry_run : Callable [[ NewTicket ], None ] = self . print_new_ticket instance-attribute \u00b6 print_new_ticket ( ticket : NewTicket ) staticmethod \u00b6 Default action in a dry-run. Mainly for making sure you sent what you mean! Overwrite it by assigning to self.dry_run another function ToDo: Make this function nice, maybe use the rich library even Source code in pytanis/helpdesk/mail.py @staticmethod def print_new_ticket ( ticket : NewTicket ): \"\"\"Default action in a dry-run. Mainly for making sure you sent what you mean! Overwrite it by assigning to self.dry_run another function ToDo: Make this function nice, maybe use the `rich` library even \"\"\" print ( \"#\" * 40 ) print ( f \"Recipient: { ticket . requester . name } < { ticket . requester . email } >\" ) print ( f \"Subject: { ticket . subject } \" ) print ( f \" { ticket . message . text } \" ) send ( mail : Mail , dry_run : bool = True ) -> Tuple [ List [ Tuple [ Recipient , Optional [ Ticket ]]], List [ Tuple [ Recipient , Exception ]]] \u00b6 Send a mail to all recipients using HelpDesk Source code in pytanis/helpdesk/mail.py def send ( self , mail : Mail , dry_run : bool = True ) -> Tuple [ List [ Tuple [ Recipient , Optional [ Ticket ]]], List [ Tuple [ Recipient , Exception ]]]: \"\"\"Send a mail to all recipients using HelpDesk\"\"\" errors = [] tickets = [] for recipient in tqdm ( mail . recipients ): recip_mail = mail . copy () try : recip_mail . subject = mail . subject . format ( recipient = recipient , mail = mail ) # be aware here that the body might reference to subject line, so it must be filled already recip_mail . text = recip_mail . text . format ( recipient = recipient , mail = recip_mail ) ticket = self . _create_ticket ( recip_mail , recipient ) if dry_run : self . print_new_ticket ( ticket ) resp_ticket = None else : resp = self . _helpdesk_client . create_ticket ( ticket ) resp_ticket = Ticket . parse_obj ( resp ) except Exception as e : errors . append (( recipient , e )) else : tickets . append (( recipient , resp_ticket )) return tickets , errors Recipient \u00b6 Details about the recipient Use the data field to store additional information address_as : Optional [ str ] class-attribute \u00b6 data : Optional [ MetaData ] class-attribute \u00b6 email : str class-attribute \u00b6 name : str class-attribute \u00b6 fill_with_name ( v , values ) classmethod \u00b6 Source code in pytanis/helpdesk/mail.py @validator ( \"address_as\" ) @classmethod def fill_with_name ( cls , v , values ): if v is None : v = values [ \"name\" ] return v","title":"helpdesk"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk","text":"Functionality around the HelpDesk / LiveChat API","title":"helpdesk"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.__all__","text":"","title":"__all__"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.HelpDeskClient","text":"Source code in pytanis/helpdesk/client.py def __init__ ( self , config : Optional [ Config ] = None ): if config is None : config = get_cfg () self . _config = config # Important: Always use a custom User-Agent, never a generic one. # Generic User-Agents are filtered by helpdesk to reduce spam. self . _headers = { \"User-Agent\" : \"Pytanis\" } self . _get_throttled = self . _get self . _post_throttled = self . _post self . set_throttling ( 2 , 1 ) # we are nice by default","title":"HelpDeskClient"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.client.HelpDeskClient.create_ticket","text":"Source code in pytanis/helpdesk/client.py def create_ticket ( self , ticket : NewTicket ): return self . post ( \"tickets\" , data = ticket . dict ())","title":"create_ticket()"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.client.HelpDeskClient.get","text":"Retrieve data via throttled GET request and return the JSON Source code in pytanis/helpdesk/client.py def get ( self , endpoint : str , params : Optional [ Dict [ str , str ]] = None ) -> JSON : \"\"\"Retrieve data via throttled GET request and return the JSON\"\"\" resp = self . _get_throttled ( endpoint , params ) resp . raise_for_status () return resp . json ()","title":"get()"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.client.HelpDeskClient.list_agents","text":"Source code in pytanis/helpdesk/client.py def list_agents ( self ) -> List [ Agent ]: agents = self . get ( \"agents\" ) assert isinstance ( agents , List ) return [ Agent . parse_obj ( dct ) for dct in agents ]","title":"list_agents()"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.client.HelpDeskClient.list_teams","text":"Source code in pytanis/helpdesk/client.py def list_teams ( self ) -> List [ Team ]: teams = self . get ( \"teams\" ) assert isinstance ( teams , List ) return [ Team . parse_obj ( dct ) for dct in teams ]","title":"list_teams()"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.client.HelpDeskClient.post","text":"Source code in pytanis/helpdesk/client.py def post ( self , endpoint : str , data : Dict [ str , Any ], params : Optional [ Dict [ str , str ]] = None ) -> JSON : resp = self . _post_throttled ( endpoint , data , params ) resp . raise_for_status () return resp . json ()","title":"post()"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.client.HelpDeskClient.set_throttling","text":"Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/helpdesk/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . debug ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get ) self . _post_throttled = throttle ( calls , seconds )( self . _post )","title":"set_throttling()"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Mail","text":"Mail template Use the data field to store additional information You can use the typical Format String Syntax and the objects recipient and mail to access metadata to complement the template, e.g.: Hello {recipient.address_as}, We hope it's ok to address you your first name rather than using your full name being {recipient.name}. Have you read the email's subject '{mail.subject}'? How is your work right now at {recipient.data.company}? Cheers!","title":"Mail"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Mail.agent_id","text":"","title":"agent_id"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Mail.data","text":"","title":"data"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Mail.recipients","text":"","title":"recipients"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Mail.status","text":"","title":"status"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Mail.subject","text":"","title":"subject"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Mail.team_id","text":"","title":"team_id"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Mail.text","text":"","title":"text"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.MailClient","text":"Mail client for mass mails over HelpDesk Source code in pytanis/helpdesk/mail.py def __init__ ( self , helpdesk_client : Optional [ HelpDeskClient ] = None ): if helpdesk_client is None : helpdesk_client = HelpDeskClient () self . _helpdesk_client = helpdesk_client self . dry_run : Callable [[ NewTicket ], None ] = self . print_new_ticket","title":"MailClient"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.MailClient.dry_run","text":"","title":"dry_run"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.MailClient.print_new_ticket","text":"Default action in a dry-run. Mainly for making sure you sent what you mean! Overwrite it by assigning to self.dry_run another function ToDo: Make this function nice, maybe use the rich library even Source code in pytanis/helpdesk/mail.py @staticmethod def print_new_ticket ( ticket : NewTicket ): \"\"\"Default action in a dry-run. Mainly for making sure you sent what you mean! Overwrite it by assigning to self.dry_run another function ToDo: Make this function nice, maybe use the `rich` library even \"\"\" print ( \"#\" * 40 ) print ( f \"Recipient: { ticket . requester . name } < { ticket . requester . email } >\" ) print ( f \"Subject: { ticket . subject } \" ) print ( f \" { ticket . message . text } \" )","title":"print_new_ticket()"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.MailClient.send","text":"Send a mail to all recipients using HelpDesk Source code in pytanis/helpdesk/mail.py def send ( self , mail : Mail , dry_run : bool = True ) -> Tuple [ List [ Tuple [ Recipient , Optional [ Ticket ]]], List [ Tuple [ Recipient , Exception ]]]: \"\"\"Send a mail to all recipients using HelpDesk\"\"\" errors = [] tickets = [] for recipient in tqdm ( mail . recipients ): recip_mail = mail . copy () try : recip_mail . subject = mail . subject . format ( recipient = recipient , mail = mail ) # be aware here that the body might reference to subject line, so it must be filled already recip_mail . text = recip_mail . text . format ( recipient = recipient , mail = recip_mail ) ticket = self . _create_ticket ( recip_mail , recipient ) if dry_run : self . print_new_ticket ( ticket ) resp_ticket = None else : resp = self . _helpdesk_client . create_ticket ( ticket ) resp_ticket = Ticket . parse_obj ( resp ) except Exception as e : errors . append (( recipient , e )) else : tickets . append (( recipient , resp_ticket )) return tickets , errors","title":"send()"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Recipient","text":"Details about the recipient Use the data field to store additional information","title":"Recipient"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Recipient.address_as","text":"","title":"address_as"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Recipient.data","text":"","title":"data"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Recipient.email","text":"","title":"email"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Recipient.name","text":"","title":"name"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.mail.Recipient.fill_with_name","text":"Source code in pytanis/helpdesk/mail.py @validator ( \"address_as\" ) @classmethod def fill_with_name ( cls , v , values ): if v is None : v = values [ \"name\" ] return v","title":"fill_with_name()"},{"location":"reference/pytanis/helpdesk/client/","text":"client \u00b6 Client for the HelpDesk / LiveChat API Documentation: https://api.helpdesk.com/docs ToDo Transfer more functionality from PYCONDE/py_helpdesk_com JSON = Union [ JSONObj , JSONLst ] module-attribute \u00b6 Type of the JSON response as returned by the HelpDesk / LiveChat API JSONLst = List [ JSONObj ] module-attribute \u00b6 Type of a JSON list of JSON objects JSONObj = Dict [ str , Any ] module-attribute \u00b6 Type of a JSON object (without recursion) HelpDeskClient ( config : Optional [ Config ] = None ) \u00b6 Source code in pytanis/helpdesk/client.py def __init__ ( self , config : Optional [ Config ] = None ): if config is None : config = get_cfg () self . _config = config # Important: Always use a custom User-Agent, never a generic one. # Generic User-Agents are filtered by helpdesk to reduce spam. self . _headers = { \"User-Agent\" : \"Pytanis\" } self . _get_throttled = self . _get self . _post_throttled = self . _post self . set_throttling ( 2 , 1 ) # we are nice by default create_ticket ( ticket : NewTicket ) \u00b6 Source code in pytanis/helpdesk/client.py def create_ticket ( self , ticket : NewTicket ): return self . post ( \"tickets\" , data = ticket . dict ()) get ( endpoint : str , params : Optional [ Dict [ str , str ]] = None ) -> JSON \u00b6 Retrieve data via throttled GET request and return the JSON Source code in pytanis/helpdesk/client.py def get ( self , endpoint : str , params : Optional [ Dict [ str , str ]] = None ) -> JSON : \"\"\"Retrieve data via throttled GET request and return the JSON\"\"\" resp = self . _get_throttled ( endpoint , params ) resp . raise_for_status () return resp . json () list_agents () -> List [ Agent ] \u00b6 Source code in pytanis/helpdesk/client.py def list_agents ( self ) -> List [ Agent ]: agents = self . get ( \"agents\" ) assert isinstance ( agents , List ) return [ Agent . parse_obj ( dct ) for dct in agents ] list_teams () -> List [ Team ] \u00b6 Source code in pytanis/helpdesk/client.py def list_teams ( self ) -> List [ Team ]: teams = self . get ( \"teams\" ) assert isinstance ( teams , List ) return [ Team . parse_obj ( dct ) for dct in teams ] post ( endpoint : str , data : Dict [ str , Any ], params : Optional [ Dict [ str , str ]] = None ) -> JSON \u00b6 Source code in pytanis/helpdesk/client.py def post ( self , endpoint : str , data : Dict [ str , Any ], params : Optional [ Dict [ str , str ]] = None ) -> JSON : resp = self . _post_throttled ( endpoint , data , params ) resp . raise_for_status () return resp . json () set_throttling ( calls : int , seconds : int ) \u00b6 Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/helpdesk/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . debug ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get ) self . _post_throttled = throttle ( calls , seconds )( self . _post )","title":"client"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client","text":"Client for the HelpDesk / LiveChat API Documentation: https://api.helpdesk.com/docs ToDo Transfer more functionality from PYCONDE/py_helpdesk_com","title":"client"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.JSON","text":"Type of the JSON response as returned by the HelpDesk / LiveChat API","title":"JSON"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.JSONLst","text":"Type of a JSON list of JSON objects","title":"JSONLst"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.JSONObj","text":"Type of a JSON object (without recursion)","title":"JSONObj"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient","text":"Source code in pytanis/helpdesk/client.py def __init__ ( self , config : Optional [ Config ] = None ): if config is None : config = get_cfg () self . _config = config # Important: Always use a custom User-Agent, never a generic one. # Generic User-Agents are filtered by helpdesk to reduce spam. self . _headers = { \"User-Agent\" : \"Pytanis\" } self . _get_throttled = self . _get self . _post_throttled = self . _post self . set_throttling ( 2 , 1 ) # we are nice by default","title":"HelpDeskClient"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.create_ticket","text":"Source code in pytanis/helpdesk/client.py def create_ticket ( self , ticket : NewTicket ): return self . post ( \"tickets\" , data = ticket . dict ())","title":"create_ticket()"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.get","text":"Retrieve data via throttled GET request and return the JSON Source code in pytanis/helpdesk/client.py def get ( self , endpoint : str , params : Optional [ Dict [ str , str ]] = None ) -> JSON : \"\"\"Retrieve data via throttled GET request and return the JSON\"\"\" resp = self . _get_throttled ( endpoint , params ) resp . raise_for_status () return resp . json ()","title":"get()"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.list_agents","text":"Source code in pytanis/helpdesk/client.py def list_agents ( self ) -> List [ Agent ]: agents = self . get ( \"agents\" ) assert isinstance ( agents , List ) return [ Agent . parse_obj ( dct ) for dct in agents ]","title":"list_agents()"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.list_teams","text":"Source code in pytanis/helpdesk/client.py def list_teams ( self ) -> List [ Team ]: teams = self . get ( \"teams\" ) assert isinstance ( teams , List ) return [ Team . parse_obj ( dct ) for dct in teams ]","title":"list_teams()"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.post","text":"Source code in pytanis/helpdesk/client.py def post ( self , endpoint : str , data : Dict [ str , Any ], params : Optional [ Dict [ str , str ]] = None ) -> JSON : resp = self . _post_throttled ( endpoint , data , params ) resp . raise_for_status () return resp . json ()","title":"post()"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.set_throttling","text":"Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/helpdesk/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . debug ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get ) self . _post_throttled = throttle ( calls , seconds )( self . _post )","title":"set_throttling()"},{"location":"reference/pytanis/helpdesk/mail/","text":"mail \u00b6 Functionality around mailing ToDo add logging where appropriate Find out why extra=Extra.allow causes mypy to fail. Seems like a bug in pydantic. Sending mails is quite slow, so using tqdm to show feedback to the current progress would be nice Mail \u00b6 Mail template Use the data field to store additional information You can use the typical Format String Syntax and the objects recipient and mail to access metadata to complement the template, e.g.: Hello {recipient.address_as}, We hope it's ok to address you your first name rather than using your full name being {recipient.name}. Have you read the email's subject '{mail.subject}'? How is your work right now at {recipient.data.company}? Cheers! agent_id : str class-attribute \u00b6 data : Optional [ MetaData ] class-attribute \u00b6 recipients : List [ Recipient ] class-attribute \u00b6 status : str = 'solved' class-attribute \u00b6 subject : str class-attribute \u00b6 team_id : str class-attribute \u00b6 text : str class-attribute \u00b6 MailClient ( helpdesk_client : Optional [ HelpDeskClient ] = None ) \u00b6 Mail client for mass mails over HelpDesk Source code in pytanis/helpdesk/mail.py def __init__ ( self , helpdesk_client : Optional [ HelpDeskClient ] = None ): if helpdesk_client is None : helpdesk_client = HelpDeskClient () self . _helpdesk_client = helpdesk_client self . dry_run : Callable [[ NewTicket ], None ] = self . print_new_ticket dry_run : Callable [[ NewTicket ], None ] = self . print_new_ticket instance-attribute \u00b6 print_new_ticket ( ticket : NewTicket ) staticmethod \u00b6 Default action in a dry-run. Mainly for making sure you sent what you mean! Overwrite it by assigning to self.dry_run another function ToDo: Make this function nice, maybe use the rich library even Source code in pytanis/helpdesk/mail.py @staticmethod def print_new_ticket ( ticket : NewTicket ): \"\"\"Default action in a dry-run. Mainly for making sure you sent what you mean! Overwrite it by assigning to self.dry_run another function ToDo: Make this function nice, maybe use the `rich` library even \"\"\" print ( \"#\" * 40 ) print ( f \"Recipient: { ticket . requester . name } < { ticket . requester . email } >\" ) print ( f \"Subject: { ticket . subject } \" ) print ( f \" { ticket . message . text } \" ) send ( mail : Mail , dry_run : bool = True ) -> Tuple [ List [ Tuple [ Recipient , Optional [ Ticket ]]], List [ Tuple [ Recipient , Exception ]]] \u00b6 Send a mail to all recipients using HelpDesk Source code in pytanis/helpdesk/mail.py def send ( self , mail : Mail , dry_run : bool = True ) -> Tuple [ List [ Tuple [ Recipient , Optional [ Ticket ]]], List [ Tuple [ Recipient , Exception ]]]: \"\"\"Send a mail to all recipients using HelpDesk\"\"\" errors = [] tickets = [] for recipient in tqdm ( mail . recipients ): recip_mail = mail . copy () try : recip_mail . subject = mail . subject . format ( recipient = recipient , mail = mail ) # be aware here that the body might reference to subject line, so it must be filled already recip_mail . text = recip_mail . text . format ( recipient = recipient , mail = recip_mail ) ticket = self . _create_ticket ( recip_mail , recipient ) if dry_run : self . print_new_ticket ( ticket ) resp_ticket = None else : resp = self . _helpdesk_client . create_ticket ( ticket ) resp_ticket = Ticket . parse_obj ( resp ) except Exception as e : errors . append (( recipient , e )) else : tickets . append (( recipient , resp_ticket )) return tickets , errors MetaData \u00b6 Additional, arbitrary metadata provided by the user like for template filling Recipient \u00b6 Details about the recipient Use the data field to store additional information address_as : Optional [ str ] class-attribute \u00b6 data : Optional [ MetaData ] class-attribute \u00b6 email : str class-attribute \u00b6 name : str class-attribute \u00b6 fill_with_name ( v , values ) classmethod \u00b6 Source code in pytanis/helpdesk/mail.py @validator ( \"address_as\" ) @classmethod def fill_with_name ( cls , v , values ): if v is None : v = values [ \"name\" ] return v","title":"mail"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail","text":"Functionality around mailing ToDo add logging where appropriate Find out why extra=Extra.allow causes mypy to fail. Seems like a bug in pydantic. Sending mails is quite slow, so using tqdm to show feedback to the current progress would be nice","title":"mail"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail","text":"Mail template Use the data field to store additional information You can use the typical Format String Syntax and the objects recipient and mail to access metadata to complement the template, e.g.: Hello {recipient.address_as}, We hope it's ok to address you your first name rather than using your full name being {recipient.name}. Have you read the email's subject '{mail.subject}'? How is your work right now at {recipient.data.company}? Cheers!","title":"Mail"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.agent_id","text":"","title":"agent_id"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.data","text":"","title":"data"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.recipients","text":"","title":"recipients"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.status","text":"","title":"status"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.subject","text":"","title":"subject"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.team_id","text":"","title":"team_id"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.text","text":"","title":"text"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MailClient","text":"Mail client for mass mails over HelpDesk Source code in pytanis/helpdesk/mail.py def __init__ ( self , helpdesk_client : Optional [ HelpDeskClient ] = None ): if helpdesk_client is None : helpdesk_client = HelpDeskClient () self . _helpdesk_client = helpdesk_client self . dry_run : Callable [[ NewTicket ], None ] = self . print_new_ticket","title":"MailClient"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MailClient.dry_run","text":"","title":"dry_run"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MailClient.print_new_ticket","text":"Default action in a dry-run. Mainly for making sure you sent what you mean! Overwrite it by assigning to self.dry_run another function ToDo: Make this function nice, maybe use the rich library even Source code in pytanis/helpdesk/mail.py @staticmethod def print_new_ticket ( ticket : NewTicket ): \"\"\"Default action in a dry-run. Mainly for making sure you sent what you mean! Overwrite it by assigning to self.dry_run another function ToDo: Make this function nice, maybe use the `rich` library even \"\"\" print ( \"#\" * 40 ) print ( f \"Recipient: { ticket . requester . name } < { ticket . requester . email } >\" ) print ( f \"Subject: { ticket . subject } \" ) print ( f \" { ticket . message . text } \" )","title":"print_new_ticket()"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MailClient.send","text":"Send a mail to all recipients using HelpDesk Source code in pytanis/helpdesk/mail.py def send ( self , mail : Mail , dry_run : bool = True ) -> Tuple [ List [ Tuple [ Recipient , Optional [ Ticket ]]], List [ Tuple [ Recipient , Exception ]]]: \"\"\"Send a mail to all recipients using HelpDesk\"\"\" errors = [] tickets = [] for recipient in tqdm ( mail . recipients ): recip_mail = mail . copy () try : recip_mail . subject = mail . subject . format ( recipient = recipient , mail = mail ) # be aware here that the body might reference to subject line, so it must be filled already recip_mail . text = recip_mail . text . format ( recipient = recipient , mail = recip_mail ) ticket = self . _create_ticket ( recip_mail , recipient ) if dry_run : self . print_new_ticket ( ticket ) resp_ticket = None else : resp = self . _helpdesk_client . create_ticket ( ticket ) resp_ticket = Ticket . parse_obj ( resp ) except Exception as e : errors . append (( recipient , e )) else : tickets . append (( recipient , resp_ticket )) return tickets , errors","title":"send()"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MetaData","text":"Additional, arbitrary metadata provided by the user like for template filling","title":"MetaData"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient","text":"Details about the recipient Use the data field to store additional information","title":"Recipient"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient.address_as","text":"","title":"address_as"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient.data","text":"","title":"data"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient.email","text":"","title":"email"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient.name","text":"","title":"name"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient.fill_with_name","text":"Source code in pytanis/helpdesk/mail.py @validator ( \"address_as\" ) @classmethod def fill_with_name ( cls , v , values ): if v is None : v = values [ \"name\" ] return v","title":"fill_with_name()"},{"location":"reference/pytanis/helpdesk/types/","text":"types \u00b6 Return types of the HelpDesk / LiveChat API Documentation: https://api.helpdesk.com/docs ToDo Implement the types below correctly instead of using Extra.Allow Find out why extra=Extra.allow causes mypy to fail. Seems like a bug in pydantic. Agent \u00b6 Assignment \u00b6 agent : Id class-attribute \u00b6 team : Id class-attribute \u00b6 Id \u00b6 ID : str class-attribute \u00b6 Message \u00b6 text : str class-attribute \u00b6 NewTicket \u00b6 Object that needs to be sent when creating a NEW ticket assignment : Optional [ Assignment ] class-attribute \u00b6 message : Message class-attribute \u00b6 requester : Requester class-attribute \u00b6 status : Optional [ str ] class-attribute \u00b6 subject : Optional [ str ] class-attribute \u00b6 teamIDs : Optional [ List [ str ]] class-attribute \u00b6 Requester \u00b6 email : str class-attribute \u00b6 name : str class-attribute \u00b6 Team \u00b6 Ticket \u00b6 Actual ticket as returned by the API","title":"types"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types","text":"Return types of the HelpDesk / LiveChat API Documentation: https://api.helpdesk.com/docs ToDo Implement the types below correctly instead of using Extra.Allow Find out why extra=Extra.allow causes mypy to fail. Seems like a bug in pydantic.","title":"types"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Agent","text":"","title":"Agent"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Assignment","text":"","title":"Assignment"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Assignment.agent","text":"","title":"agent"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Assignment.team","text":"","title":"team"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Id","text":"","title":"Id"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Id.ID","text":"","title":"ID"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Message","text":"","title":"Message"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Message.text","text":"","title":"text"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.NewTicket","text":"Object that needs to be sent when creating a NEW ticket","title":"NewTicket"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.NewTicket.assignment","text":"","title":"assignment"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.NewTicket.message","text":"","title":"message"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.NewTicket.requester","text":"","title":"requester"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.NewTicket.status","text":"","title":"status"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.NewTicket.subject","text":"","title":"subject"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.NewTicket.teamIDs","text":"","title":"teamIDs"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Requester","text":"","title":"Requester"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Requester.email","text":"","title":"email"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Requester.name","text":"","title":"name"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Team","text":"","title":"Team"},{"location":"reference/pytanis/helpdesk/types/#pytanis.helpdesk.types.Ticket","text":"Actual ticket as returned by the API","title":"Ticket"},{"location":"reference/pytanis/pretalx/","text":"pretalx \u00b6 Functionality around the Pretalx API __all__ = [ 'PretalxClient' , 'subs_as_df' , 'speakers_as_df' , 'reviews_as_df' ] module-attribute \u00b6 PretalxClient ( config : Optional [ Config ] = None , blocking : bool = False ) \u00b6 Client for the Pretalx API Source code in pytanis/pretalx/client.py def __init__ ( self , config : Optional [ Config ] = None , blocking : bool = False ): if config is None : config = get_cfg () self . _config = config self . _get_throttled = self . _get self . blocking = blocking self . set_throttling ( 1 , 2 ) # we are nice by default blocking = blocking instance-attribute \u00b6 answer ( event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Answer \u00b6 Returns a specific answer Source code in pytanis/pretalx/client.py def answer ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Answer : \"\"\"Returns a specific answer\"\"\" return self . _endpoint_id ( Answer , event_slug , \"answers\" , id , params = params ) answers ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Answer ]] \u00b6 Lists all answers and their details Source code in pytanis/pretalx/client.py def answers ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Answer ]]: \"\"\"Lists all answers and their details\"\"\" return self . _endpoint_lst ( Answer , event_slug , \"answers\" , params = params ) event ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Event \u00b6 Returns detailed information about a specific event Source code in pytanis/pretalx/client.py def event ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Event : \"\"\"Returns detailed information about a specific event\"\"\" endpoint = f \"/api/events/ { event_slug } /\" result = self . _get_one ( endpoint , params ) _logger . debug ( \"result\" , resp = result ) return Event . parse_obj ( result ) events ( * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Event ]] \u00b6 Lists all events and their details Source code in pytanis/pretalx/client.py def events ( self , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Event ]]: \"\"\"Lists all events and their details\"\"\" count , results = self . _get_many ( \"/api/events/\" , params ) events = iter ( _logger . debug ( \"result\" , resp = r ) or Event . parse_obj ( r ) for r in results ) return count , events me () -> Me \u00b6 Returns what Pretalx knows about myself Source code in pytanis/pretalx/client.py def me ( self ) -> Me : \"\"\"Returns what Pretalx knows about myself\"\"\" result = self . _get_one ( \"/api/me\" ) return Me . parse_obj ( result ) question ( event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Question \u00b6 Returns a specific question Source code in pytanis/pretalx/client.py def question ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Question : \"\"\"Returns a specific question\"\"\" return self . _endpoint_id ( Question , event_slug , \"questions\" , id , params = params ) questions ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Question ]] \u00b6 Lists all questions and their details Source code in pytanis/pretalx/client.py def questions ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Question ]]: \"\"\"Lists all questions and their details\"\"\" return self . _endpoint_lst ( Question , event_slug , \"questions\" , params = params ) review ( event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Review \u00b6 Returns a specific review Source code in pytanis/pretalx/client.py def review ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Review : \"\"\"Returns a specific review\"\"\" return self . _endpoint_id ( Review , event_slug , \"reviews\" , id , params = params ) reviews ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Review ]] \u00b6 Lists all reviews and their details Source code in pytanis/pretalx/client.py def reviews ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Review ]]: \"\"\"Lists all reviews and their details\"\"\" return self . _endpoint_lst ( Review , event_slug , \"reviews\" , params = params ) room ( event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Room \u00b6 Returns a specific room Source code in pytanis/pretalx/client.py def room ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Room : \"\"\"Returns a specific room\"\"\" return self . _endpoint_id ( Room , event_slug , \"rooms\" , id , params = params ) rooms ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Room ]] \u00b6 Lists all rooms and their details Source code in pytanis/pretalx/client.py def rooms ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Room ]]: \"\"\"Lists all rooms and their details\"\"\" return self . _endpoint_lst ( Room , event_slug , \"rooms\" , params = params ) set_throttling ( calls : int , seconds : int ) \u00b6 Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/pretalx/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . info ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get ) speaker ( event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Speaker \u00b6 Returns a specific speaker Source code in pytanis/pretalx/client.py def speaker ( self , event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Speaker : \"\"\"Returns a specific speaker\"\"\" return self . _endpoint_id ( Speaker , event_slug , \"speakers\" , code , params = params ) speakers ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Speaker ]] \u00b6 Lists all speakers and their details Source code in pytanis/pretalx/client.py def speakers ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Speaker ]]: \"\"\"Lists all speakers and their details\"\"\" return self . _endpoint_lst ( Speaker , event_slug , \"speakers\" , params = params ) submission ( event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Submission \u00b6 Returns a specific submission Source code in pytanis/pretalx/client.py def submission ( self , event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Submission : \"\"\"Returns a specific submission\"\"\" return self . _endpoint_id ( Submission , event_slug , \"submissions\" , code , params = params ) submissions ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Submission ]] \u00b6 Lists all submissions and their details Source code in pytanis/pretalx/client.py def submissions ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Submission ]]: \"\"\"Lists all submissions and their details\"\"\" return self . _endpoint_lst ( Submission , event_slug , \"submissions\" , params = params ) tag ( event_slug : str , tag : str , * , params : Optional [ QueryParamType ] = None ) -> Tag \u00b6 Returns a specific tag Source code in pytanis/pretalx/client.py def tag ( self , event_slug : str , tag : str , * , params : Optional [ QueryParamType ] = None ) -> Tag : \"\"\"Returns a specific tag\"\"\" return self . _endpoint_id ( Tag , event_slug , \"tags\" , tag , params = params ) tags ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Tag ]] \u00b6 Lists all tags and their details Source code in pytanis/pretalx/client.py def tags ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Tag ]]: \"\"\"Lists all tags and their details\"\"\" return self . _endpoint_lst ( Tag , event_slug , \"tags\" , params = params ) talk ( event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Talk \u00b6 Returns a specific talk Source code in pytanis/pretalx/client.py def talk ( self , event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Talk : \"\"\"Returns a specific talk\"\"\" return self . _endpoint_id ( Talk , event_slug , \"talks\" , code , params = params ) talks ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Talk ]] \u00b6 Lists all talks and their details Source code in pytanis/pretalx/client.py def talks ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Talk ]]: \"\"\"Lists all talks and their details\"\"\" return self . _endpoint_lst ( Talk , event_slug , \"talks\" , params = params ) reviews_as_df ( reviews : Iterable [ Review ]) -> pd . DataFrame \u00b6 Convert the reviews to a dataframe Source code in pytanis/pretalx/utils.py def reviews_as_df ( reviews : Iterable [ Review ]) -> pd . DataFrame : \"\"\"Convert the reviews to a dataframe\"\"\" df = pd . DataFrame ([ review . dict () for review in reviews ]) # make first letter of column upper-case in accordance with our convention df . rename ( columns = { col : col . title () for col in df . columns }, inplace = True ) # user is the speaker name to use for joining df . rename ( columns = { \"User\" : Col . pretalx_user , \"Score\" : Col . review_score }, inplace = True ) return df speakers_as_df ( speakers : Iterable [ Speaker ], with_questions : bool = False , question_prefix : str = 'Q: ' ) -> pd . DataFrame \u00b6 Convert speakers into a dataframe Make sure to have params={\"questions\": \"all\"} for the PretalxAPI if with_questions is True. Source code in pytanis/pretalx/utils.py def speakers_as_df ( speakers : Iterable [ Speaker ], with_questions : bool = False , question_prefix : str = \"Q: \" ) -> pd . DataFrame : \"\"\"Convert speakers into a dataframe Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True. \"\"\" rows = [] for speaker in speakers : row = { Col . speaker_code : speaker . code , Col . speaker_name : speaker . name , Col . email : speaker . email , Col . biography : speaker . biography , Col . submission : speaker . submissions , } if with_questions and speaker . answers is not None : for answer in speaker . answers : # The API returns also questions that are 'per proposal/submission', we get these using the # submission endpoint and don't want them here due to ambiguity if several submission were made. if answer . person is not None : row [ f \" { question_prefix }{ answer . question . question . en } \" ] = answer . answer rows . append ( row ) return pd . DataFrame ( rows ) subs_as_df ( subs : Iterable [ Submission ], with_questions : bool = False , question_prefix : str = 'Q: ' ) -> pd . DataFrame \u00b6 Convert submissions into a dataframe Make sure to have params={\"questions\": \"all\"} for the PretalxAPI if with_questions is True. Source code in pytanis/pretalx/utils.py def subs_as_df ( subs : Iterable [ Submission ], with_questions : bool = False , question_prefix : str = \"Q: \" ) -> pd . DataFrame : \"\"\"Convert submissions into a dataframe Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True. \"\"\" rows = [] for sub in subs : row = { Col . submission : sub . code , Col . title : sub . title , Col . track : sub . track . en if sub . track else None , Col . speaker_code : [ speaker . code for speaker in sub . speakers ], Col . speaker_name : [ speaker . name for speaker in sub . speakers ], Col . duration : sub . duration , Col . submission_type : sub . submission_type . en , Col . submission_type_id : sub . submission_type_id , Col . state : sub . state . value , Col . pending_state : None if sub . pending_state is None else sub . pending_state . value , Col . created : sub . created , } if with_questions and sub . answers is not None : for answer in sub . answers : row [ f \" { question_prefix }{ answer . question . question . en } \" ] = answer . answer rows . append ( row ) return pd . DataFrame ( rows )","title":"pretalx"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx","text":"Functionality around the Pretalx API","title":"pretalx"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.__all__","text":"","title":"__all__"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient","text":"Client for the Pretalx API Source code in pytanis/pretalx/client.py def __init__ ( self , config : Optional [ Config ] = None , blocking : bool = False ): if config is None : config = get_cfg () self . _config = config self . _get_throttled = self . _get self . blocking = blocking self . set_throttling ( 1 , 2 ) # we are nice by default","title":"PretalxClient"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.blocking","text":"","title":"blocking"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.answer","text":"Returns a specific answer Source code in pytanis/pretalx/client.py def answer ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Answer : \"\"\"Returns a specific answer\"\"\" return self . _endpoint_id ( Answer , event_slug , \"answers\" , id , params = params )","title":"answer()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.answers","text":"Lists all answers and their details Source code in pytanis/pretalx/client.py def answers ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Answer ]]: \"\"\"Lists all answers and their details\"\"\" return self . _endpoint_lst ( Answer , event_slug , \"answers\" , params = params )","title":"answers()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.event","text":"Returns detailed information about a specific event Source code in pytanis/pretalx/client.py def event ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Event : \"\"\"Returns detailed information about a specific event\"\"\" endpoint = f \"/api/events/ { event_slug } /\" result = self . _get_one ( endpoint , params ) _logger . debug ( \"result\" , resp = result ) return Event . parse_obj ( result )","title":"event()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.events","text":"Lists all events and their details Source code in pytanis/pretalx/client.py def events ( self , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Event ]]: \"\"\"Lists all events and their details\"\"\" count , results = self . _get_many ( \"/api/events/\" , params ) events = iter ( _logger . debug ( \"result\" , resp = r ) or Event . parse_obj ( r ) for r in results ) return count , events","title":"events()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.me","text":"Returns what Pretalx knows about myself Source code in pytanis/pretalx/client.py def me ( self ) -> Me : \"\"\"Returns what Pretalx knows about myself\"\"\" result = self . _get_one ( \"/api/me\" ) return Me . parse_obj ( result )","title":"me()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.question","text":"Returns a specific question Source code in pytanis/pretalx/client.py def question ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Question : \"\"\"Returns a specific question\"\"\" return self . _endpoint_id ( Question , event_slug , \"questions\" , id , params = params )","title":"question()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.questions","text":"Lists all questions and their details Source code in pytanis/pretalx/client.py def questions ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Question ]]: \"\"\"Lists all questions and their details\"\"\" return self . _endpoint_lst ( Question , event_slug , \"questions\" , params = params )","title":"questions()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.review","text":"Returns a specific review Source code in pytanis/pretalx/client.py def review ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Review : \"\"\"Returns a specific review\"\"\" return self . _endpoint_id ( Review , event_slug , \"reviews\" , id , params = params )","title":"review()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.reviews","text":"Lists all reviews and their details Source code in pytanis/pretalx/client.py def reviews ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Review ]]: \"\"\"Lists all reviews and their details\"\"\" return self . _endpoint_lst ( Review , event_slug , \"reviews\" , params = params )","title":"reviews()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.room","text":"Returns a specific room Source code in pytanis/pretalx/client.py def room ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Room : \"\"\"Returns a specific room\"\"\" return self . _endpoint_id ( Room , event_slug , \"rooms\" , id , params = params )","title":"room()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.rooms","text":"Lists all rooms and their details Source code in pytanis/pretalx/client.py def rooms ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Room ]]: \"\"\"Lists all rooms and their details\"\"\" return self . _endpoint_lst ( Room , event_slug , \"rooms\" , params = params )","title":"rooms()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.set_throttling","text":"Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/pretalx/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . info ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get )","title":"set_throttling()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.speaker","text":"Returns a specific speaker Source code in pytanis/pretalx/client.py def speaker ( self , event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Speaker : \"\"\"Returns a specific speaker\"\"\" return self . _endpoint_id ( Speaker , event_slug , \"speakers\" , code , params = params )","title":"speaker()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.speakers","text":"Lists all speakers and their details Source code in pytanis/pretalx/client.py def speakers ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Speaker ]]: \"\"\"Lists all speakers and their details\"\"\" return self . _endpoint_lst ( Speaker , event_slug , \"speakers\" , params = params )","title":"speakers()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.submission","text":"Returns a specific submission Source code in pytanis/pretalx/client.py def submission ( self , event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Submission : \"\"\"Returns a specific submission\"\"\" return self . _endpoint_id ( Submission , event_slug , \"submissions\" , code , params = params )","title":"submission()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.submissions","text":"Lists all submissions and their details Source code in pytanis/pretalx/client.py def submissions ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Submission ]]: \"\"\"Lists all submissions and their details\"\"\" return self . _endpoint_lst ( Submission , event_slug , \"submissions\" , params = params )","title":"submissions()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.tag","text":"Returns a specific tag Source code in pytanis/pretalx/client.py def tag ( self , event_slug : str , tag : str , * , params : Optional [ QueryParamType ] = None ) -> Tag : \"\"\"Returns a specific tag\"\"\" return self . _endpoint_id ( Tag , event_slug , \"tags\" , tag , params = params )","title":"tag()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.tags","text":"Lists all tags and their details Source code in pytanis/pretalx/client.py def tags ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Tag ]]: \"\"\"Lists all tags and their details\"\"\" return self . _endpoint_lst ( Tag , event_slug , \"tags\" , params = params )","title":"tags()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.talk","text":"Returns a specific talk Source code in pytanis/pretalx/client.py def talk ( self , event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Talk : \"\"\"Returns a specific talk\"\"\" return self . _endpoint_id ( Talk , event_slug , \"talks\" , code , params = params )","title":"talk()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.client.PretalxClient.talks","text":"Lists all talks and their details Source code in pytanis/pretalx/client.py def talks ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Talk ]]: \"\"\"Lists all talks and their details\"\"\" return self . _endpoint_lst ( Talk , event_slug , \"talks\" , params = params )","title":"talks()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.reviews_as_df","text":"Convert the reviews to a dataframe Source code in pytanis/pretalx/utils.py def reviews_as_df ( reviews : Iterable [ Review ]) -> pd . DataFrame : \"\"\"Convert the reviews to a dataframe\"\"\" df = pd . DataFrame ([ review . dict () for review in reviews ]) # make first letter of column upper-case in accordance with our convention df . rename ( columns = { col : col . title () for col in df . columns }, inplace = True ) # user is the speaker name to use for joining df . rename ( columns = { \"User\" : Col . pretalx_user , \"Score\" : Col . review_score }, inplace = True ) return df","title":"reviews_as_df()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.speakers_as_df","text":"Convert speakers into a dataframe Make sure to have params={\"questions\": \"all\"} for the PretalxAPI if with_questions is True. Source code in pytanis/pretalx/utils.py def speakers_as_df ( speakers : Iterable [ Speaker ], with_questions : bool = False , question_prefix : str = \"Q: \" ) -> pd . DataFrame : \"\"\"Convert speakers into a dataframe Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True. \"\"\" rows = [] for speaker in speakers : row = { Col . speaker_code : speaker . code , Col . speaker_name : speaker . name , Col . email : speaker . email , Col . biography : speaker . biography , Col . submission : speaker . submissions , } if with_questions and speaker . answers is not None : for answer in speaker . answers : # The API returns also questions that are 'per proposal/submission', we get these using the # submission endpoint and don't want them here due to ambiguity if several submission were made. if answer . person is not None : row [ f \" { question_prefix }{ answer . question . question . en } \" ] = answer . answer rows . append ( row ) return pd . DataFrame ( rows )","title":"speakers_as_df()"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.subs_as_df","text":"Convert submissions into a dataframe Make sure to have params={\"questions\": \"all\"} for the PretalxAPI if with_questions is True. Source code in pytanis/pretalx/utils.py def subs_as_df ( subs : Iterable [ Submission ], with_questions : bool = False , question_prefix : str = \"Q: \" ) -> pd . DataFrame : \"\"\"Convert submissions into a dataframe Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True. \"\"\" rows = [] for sub in subs : row = { Col . submission : sub . code , Col . title : sub . title , Col . track : sub . track . en if sub . track else None , Col . speaker_code : [ speaker . code for speaker in sub . speakers ], Col . speaker_name : [ speaker . name for speaker in sub . speakers ], Col . duration : sub . duration , Col . submission_type : sub . submission_type . en , Col . submission_type_id : sub . submission_type_id , Col . state : sub . state . value , Col . pending_state : None if sub . pending_state is None else sub . pending_state . value , Col . created : sub . created , } if with_questions and sub . answers is not None : for answer in sub . answers : row [ f \" { question_prefix }{ answer . question . question . en } \" ] = answer . answer rows . append ( row ) return pd . DataFrame ( rows )","title":"subs_as_df()"},{"location":"reference/pytanis/pretalx/client/","text":"client \u00b6 Client for the Pretalx API Documentation: https://docs.pretalx.org/api/resources/index.html ToDo add additional parameters explicitly like querying according to the API JSON = Union [ JSONObj , JSONLst ] module-attribute \u00b6 Type of the JSON response as returned by the Pretalx API JSONLst = List [ JSONObj ] module-attribute \u00b6 Type of a JSON list of JSON objects JSONObj = Dict [ str , Any ] module-attribute \u00b6 Type of a JSON object (without recursion) QueryParamType = Union [ Dict [ Any , Union [ Any , List [ Any ]]], QueryParams ] module-attribute \u00b6 Type for the optional parameters to the Pretalx API T = TypeVar ( 'T' , bound = BaseModel ) module-attribute \u00b6 PretalxClient ( config : Optional [ Config ] = None , blocking : bool = False ) \u00b6 Client for the Pretalx API Source code in pytanis/pretalx/client.py def __init__ ( self , config : Optional [ Config ] = None , blocking : bool = False ): if config is None : config = get_cfg () self . _config = config self . _get_throttled = self . _get self . blocking = blocking self . set_throttling ( 1 , 2 ) # we are nice by default blocking = blocking instance-attribute \u00b6 answer ( event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Answer \u00b6 Returns a specific answer Source code in pytanis/pretalx/client.py def answer ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Answer : \"\"\"Returns a specific answer\"\"\" return self . _endpoint_id ( Answer , event_slug , \"answers\" , id , params = params ) answers ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Answer ]] \u00b6 Lists all answers and their details Source code in pytanis/pretalx/client.py def answers ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Answer ]]: \"\"\"Lists all answers and their details\"\"\" return self . _endpoint_lst ( Answer , event_slug , \"answers\" , params = params ) event ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Event \u00b6 Returns detailed information about a specific event Source code in pytanis/pretalx/client.py def event ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Event : \"\"\"Returns detailed information about a specific event\"\"\" endpoint = f \"/api/events/ { event_slug } /\" result = self . _get_one ( endpoint , params ) _logger . debug ( \"result\" , resp = result ) return Event . parse_obj ( result ) events ( * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Event ]] \u00b6 Lists all events and their details Source code in pytanis/pretalx/client.py def events ( self , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Event ]]: \"\"\"Lists all events and their details\"\"\" count , results = self . _get_many ( \"/api/events/\" , params ) events = iter ( _logger . debug ( \"result\" , resp = r ) or Event . parse_obj ( r ) for r in results ) return count , events me () -> Me \u00b6 Returns what Pretalx knows about myself Source code in pytanis/pretalx/client.py def me ( self ) -> Me : \"\"\"Returns what Pretalx knows about myself\"\"\" result = self . _get_one ( \"/api/me\" ) return Me . parse_obj ( result ) question ( event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Question \u00b6 Returns a specific question Source code in pytanis/pretalx/client.py def question ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Question : \"\"\"Returns a specific question\"\"\" return self . _endpoint_id ( Question , event_slug , \"questions\" , id , params = params ) questions ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Question ]] \u00b6 Lists all questions and their details Source code in pytanis/pretalx/client.py def questions ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Question ]]: \"\"\"Lists all questions and their details\"\"\" return self . _endpoint_lst ( Question , event_slug , \"questions\" , params = params ) review ( event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Review \u00b6 Returns a specific review Source code in pytanis/pretalx/client.py def review ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Review : \"\"\"Returns a specific review\"\"\" return self . _endpoint_id ( Review , event_slug , \"reviews\" , id , params = params ) reviews ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Review ]] \u00b6 Lists all reviews and their details Source code in pytanis/pretalx/client.py def reviews ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Review ]]: \"\"\"Lists all reviews and their details\"\"\" return self . _endpoint_lst ( Review , event_slug , \"reviews\" , params = params ) room ( event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Room \u00b6 Returns a specific room Source code in pytanis/pretalx/client.py def room ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Room : \"\"\"Returns a specific room\"\"\" return self . _endpoint_id ( Room , event_slug , \"rooms\" , id , params = params ) rooms ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Room ]] \u00b6 Lists all rooms and their details Source code in pytanis/pretalx/client.py def rooms ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Room ]]: \"\"\"Lists all rooms and their details\"\"\" return self . _endpoint_lst ( Room , event_slug , \"rooms\" , params = params ) set_throttling ( calls : int , seconds : int ) \u00b6 Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/pretalx/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . info ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get ) speaker ( event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Speaker \u00b6 Returns a specific speaker Source code in pytanis/pretalx/client.py def speaker ( self , event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Speaker : \"\"\"Returns a specific speaker\"\"\" return self . _endpoint_id ( Speaker , event_slug , \"speakers\" , code , params = params ) speakers ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Speaker ]] \u00b6 Lists all speakers and their details Source code in pytanis/pretalx/client.py def speakers ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Speaker ]]: \"\"\"Lists all speakers and their details\"\"\" return self . _endpoint_lst ( Speaker , event_slug , \"speakers\" , params = params ) submission ( event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Submission \u00b6 Returns a specific submission Source code in pytanis/pretalx/client.py def submission ( self , event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Submission : \"\"\"Returns a specific submission\"\"\" return self . _endpoint_id ( Submission , event_slug , \"submissions\" , code , params = params ) submissions ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Submission ]] \u00b6 Lists all submissions and their details Source code in pytanis/pretalx/client.py def submissions ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Submission ]]: \"\"\"Lists all submissions and their details\"\"\" return self . _endpoint_lst ( Submission , event_slug , \"submissions\" , params = params ) tag ( event_slug : str , tag : str , * , params : Optional [ QueryParamType ] = None ) -> Tag \u00b6 Returns a specific tag Source code in pytanis/pretalx/client.py def tag ( self , event_slug : str , tag : str , * , params : Optional [ QueryParamType ] = None ) -> Tag : \"\"\"Returns a specific tag\"\"\" return self . _endpoint_id ( Tag , event_slug , \"tags\" , tag , params = params ) tags ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Tag ]] \u00b6 Lists all tags and their details Source code in pytanis/pretalx/client.py def tags ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Tag ]]: \"\"\"Lists all tags and their details\"\"\" return self . _endpoint_lst ( Tag , event_slug , \"tags\" , params = params ) talk ( event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Talk \u00b6 Returns a specific talk Source code in pytanis/pretalx/client.py def talk ( self , event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Talk : \"\"\"Returns a specific talk\"\"\" return self . _endpoint_id ( Talk , event_slug , \"talks\" , code , params = params ) talks ( event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Talk ]] \u00b6 Lists all talks and their details Source code in pytanis/pretalx/client.py def talks ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Talk ]]: \"\"\"Lists all talks and their details\"\"\" return self . _endpoint_lst ( Talk , event_slug , \"talks\" , params = params )","title":"client"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client","text":"Client for the Pretalx API Documentation: https://docs.pretalx.org/api/resources/index.html ToDo add additional parameters explicitly like querying according to the API","title":"client"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.JSON","text":"Type of the JSON response as returned by the Pretalx API","title":"JSON"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.JSONLst","text":"Type of a JSON list of JSON objects","title":"JSONLst"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.JSONObj","text":"Type of a JSON object (without recursion)","title":"JSONObj"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.QueryParamType","text":"Type for the optional parameters to the Pretalx API","title":"QueryParamType"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.T","text":"","title":"T"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient","text":"Client for the Pretalx API Source code in pytanis/pretalx/client.py def __init__ ( self , config : Optional [ Config ] = None , blocking : bool = False ): if config is None : config = get_cfg () self . _config = config self . _get_throttled = self . _get self . blocking = blocking self . set_throttling ( 1 , 2 ) # we are nice by default","title":"PretalxClient"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.blocking","text":"","title":"blocking"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.answer","text":"Returns a specific answer Source code in pytanis/pretalx/client.py def answer ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Answer : \"\"\"Returns a specific answer\"\"\" return self . _endpoint_id ( Answer , event_slug , \"answers\" , id , params = params )","title":"answer()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.answers","text":"Lists all answers and their details Source code in pytanis/pretalx/client.py def answers ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Answer ]]: \"\"\"Lists all answers and their details\"\"\" return self . _endpoint_lst ( Answer , event_slug , \"answers\" , params = params )","title":"answers()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.event","text":"Returns detailed information about a specific event Source code in pytanis/pretalx/client.py def event ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Event : \"\"\"Returns detailed information about a specific event\"\"\" endpoint = f \"/api/events/ { event_slug } /\" result = self . _get_one ( endpoint , params ) _logger . debug ( \"result\" , resp = result ) return Event . parse_obj ( result )","title":"event()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.events","text":"Lists all events and their details Source code in pytanis/pretalx/client.py def events ( self , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Event ]]: \"\"\"Lists all events and their details\"\"\" count , results = self . _get_many ( \"/api/events/\" , params ) events = iter ( _logger . debug ( \"result\" , resp = r ) or Event . parse_obj ( r ) for r in results ) return count , events","title":"events()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.me","text":"Returns what Pretalx knows about myself Source code in pytanis/pretalx/client.py def me ( self ) -> Me : \"\"\"Returns what Pretalx knows about myself\"\"\" result = self . _get_one ( \"/api/me\" ) return Me . parse_obj ( result )","title":"me()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.question","text":"Returns a specific question Source code in pytanis/pretalx/client.py def question ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Question : \"\"\"Returns a specific question\"\"\" return self . _endpoint_id ( Question , event_slug , \"questions\" , id , params = params )","title":"question()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.questions","text":"Lists all questions and their details Source code in pytanis/pretalx/client.py def questions ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Question ]]: \"\"\"Lists all questions and their details\"\"\" return self . _endpoint_lst ( Question , event_slug , \"questions\" , params = params )","title":"questions()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.review","text":"Returns a specific review Source code in pytanis/pretalx/client.py def review ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Review : \"\"\"Returns a specific review\"\"\" return self . _endpoint_id ( Review , event_slug , \"reviews\" , id , params = params )","title":"review()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.reviews","text":"Lists all reviews and their details Source code in pytanis/pretalx/client.py def reviews ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Review ]]: \"\"\"Lists all reviews and their details\"\"\" return self . _endpoint_lst ( Review , event_slug , \"reviews\" , params = params )","title":"reviews()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.room","text":"Returns a specific room Source code in pytanis/pretalx/client.py def room ( self , event_slug : str , id : int , * , params : Optional [ QueryParamType ] = None ) -> Room : \"\"\"Returns a specific room\"\"\" return self . _endpoint_id ( Room , event_slug , \"rooms\" , id , params = params )","title":"room()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.rooms","text":"Lists all rooms and their details Source code in pytanis/pretalx/client.py def rooms ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Room ]]: \"\"\"Lists all rooms and their details\"\"\" return self . _endpoint_lst ( Room , event_slug , \"rooms\" , params = params )","title":"rooms()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.set_throttling","text":"Throttle the number of calls per seconds to the Pretalx API Source code in pytanis/pretalx/client.py def set_throttling ( self , calls : int , seconds : int ): \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\" _logger . info ( \"throttling\" , calls = calls , seconds = seconds ) self . _get_throttled = throttle ( calls , seconds )( self . _get )","title":"set_throttling()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.speaker","text":"Returns a specific speaker Source code in pytanis/pretalx/client.py def speaker ( self , event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Speaker : \"\"\"Returns a specific speaker\"\"\" return self . _endpoint_id ( Speaker , event_slug , \"speakers\" , code , params = params )","title":"speaker()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.speakers","text":"Lists all speakers and their details Source code in pytanis/pretalx/client.py def speakers ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Speaker ]]: \"\"\"Lists all speakers and their details\"\"\" return self . _endpoint_lst ( Speaker , event_slug , \"speakers\" , params = params )","title":"speakers()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.submission","text":"Returns a specific submission Source code in pytanis/pretalx/client.py def submission ( self , event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Submission : \"\"\"Returns a specific submission\"\"\" return self . _endpoint_id ( Submission , event_slug , \"submissions\" , code , params = params )","title":"submission()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.submissions","text":"Lists all submissions and their details Source code in pytanis/pretalx/client.py def submissions ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Submission ]]: \"\"\"Lists all submissions and their details\"\"\" return self . _endpoint_lst ( Submission , event_slug , \"submissions\" , params = params )","title":"submissions()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.tag","text":"Returns a specific tag Source code in pytanis/pretalx/client.py def tag ( self , event_slug : str , tag : str , * , params : Optional [ QueryParamType ] = None ) -> Tag : \"\"\"Returns a specific tag\"\"\" return self . _endpoint_id ( Tag , event_slug , \"tags\" , tag , params = params )","title":"tag()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.tags","text":"Lists all tags and their details Source code in pytanis/pretalx/client.py def tags ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Tag ]]: \"\"\"Lists all tags and their details\"\"\" return self . _endpoint_lst ( Tag , event_slug , \"tags\" , params = params )","title":"tags()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.talk","text":"Returns a specific talk Source code in pytanis/pretalx/client.py def talk ( self , event_slug : str , code : str , * , params : Optional [ QueryParamType ] = None ) -> Talk : \"\"\"Returns a specific talk\"\"\" return self . _endpoint_id ( Talk , event_slug , \"talks\" , code , params = params )","title":"talk()"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.talks","text":"Lists all talks and their details Source code in pytanis/pretalx/client.py def talks ( self , event_slug : str , * , params : Optional [ QueryParamType ] = None ) -> Tuple [ int , Iterator [ Talk ]]: \"\"\"Lists all talks and their details\"\"\" return self . _endpoint_lst ( Talk , event_slug , \"talks\" , params = params )","title":"talks()"},{"location":"reference/pytanis/pretalx/types/","text":"types \u00b6 Return types of the Pretalx API Documentation: https://docs.pretalx.org/api/resources/index.html Attention: Quite often the API docs and the actual results of the API differ! ToDo Find out why extra=Extra.allow causes mypy to fail. Seems like a bug in pydantic. Answer \u00b6 answer : str class-attribute \u00b6 answer_file : Optional [ str ] class-attribute \u00b6 id : int class-attribute \u00b6 options : List [ Option ] class-attribute \u00b6 person : Optional [ str ] class-attribute \u00b6 question : AnswerQuestionRef class-attribute \u00b6 review : Optional [ int ] class-attribute \u00b6 submission : Optional [ str ] class-attribute \u00b6 AnswerQuestionRef \u00b6 id : int class-attribute \u00b6 question : MultiLingualStr class-attribute \u00b6 Event \u00b6 date_from : date class-attribute \u00b6 date_to : Optional [ date ] class-attribute \u00b6 is_public : bool class-attribute \u00b6 name : MultiLingualStr class-attribute \u00b6 slug : str class-attribute \u00b6 timezone : str class-attribute \u00b6 urls : URLs class-attribute \u00b6 Me \u00b6 email : str class-attribute \u00b6 local : Optional [ str ] class-attribute \u00b6 name : str class-attribute \u00b6 timezone : str class-attribute \u00b6 MultiLingualStr \u00b6 de : Optional [ str ] class-attribute \u00b6 en : Optional [ str ] class-attribute \u00b6 Option \u00b6 answer : MultiLingualStr class-attribute \u00b6 id : int class-attribute \u00b6 Question \u00b6 contains_personal_data : bool class-attribute \u00b6 deadline : Optional [ datetime ] class-attribute \u00b6 default_answer : Optional [ str ] class-attribute \u00b6 freeze_after : Optional [ datetime ] class-attribute \u00b6 help_text : MultiLingualStr class-attribute \u00b6 id : int class-attribute \u00b6 is_public : bool class-attribute \u00b6 is_visible_to_reviewers : bool class-attribute \u00b6 max_length : Optional [ int ] class-attribute \u00b6 min_length : Optional [ int ] class-attribute \u00b6 options : List [ Option ] class-attribute \u00b6 question : MultiLingualStr class-attribute \u00b6 question_required : QuestionRequirement class-attribute \u00b6 read_only : Optional [ bool ] class-attribute \u00b6 required : bool class-attribute \u00b6 target : str class-attribute \u00b6 variant : str class-attribute \u00b6 QuestionRequirement \u00b6 after_deadline = 'after deadline' class-attribute \u00b6 optional = 'optional' class-attribute \u00b6 required = 'required' class-attribute \u00b6 Resource \u00b6 description : str class-attribute \u00b6 resource : str class-attribute \u00b6 Review \u00b6 answers : List [ str ] class-attribute \u00b6 created : datetime class-attribute \u00b6 id : int class-attribute \u00b6 score : Optional [ float ] class-attribute \u00b6 submission : str class-attribute \u00b6 text : Optional [ str ] class-attribute \u00b6 updated : datetime class-attribute \u00b6 user : str class-attribute \u00b6 Room \u00b6 availabilities : Optional [ List [ RoomAvailability ]] class-attribute \u00b6 capacity : Optional [ int ] class-attribute \u00b6 description : MultiLingualStr class-attribute \u00b6 id : int class-attribute \u00b6 name : MultiLingualStr class-attribute \u00b6 position : Optional [ int ] class-attribute \u00b6 speaker_info : Optional [ MultiLingualStr ] class-attribute \u00b6 RoomAvailability \u00b6 end : datetime class-attribute \u00b6 start : datetime class-attribute \u00b6 Slot \u00b6 end : str class-attribute \u00b6 room : MultiLingualStr class-attribute \u00b6 room_id : int class-attribute \u00b6 start : str class-attribute \u00b6 Speaker \u00b6 answers : Optional [ List [ Answer ]] class-attribute \u00b6 availabilities : Optional [ List [ SpeakerAvailability ]] class-attribute \u00b6 submissions : List [ str ] class-attribute \u00b6 SpeakerAvailability \u00b6 allDay : str = Field ( Ellipsis , alias = 'all_day' ) class-attribute \u00b6 end : str class-attribute \u00b6 id : int class-attribute \u00b6 start : str class-attribute \u00b6 State \u00b6 accepted = 'accepted' class-attribute \u00b6 canceled = 'canceled' class-attribute \u00b6 confirmed = 'confirmed' class-attribute \u00b6 deleted = 'deleted' class-attribute \u00b6 rejected = 'rejected' class-attribute \u00b6 submitted = 'submitted' class-attribute \u00b6 withdrawn = 'withdrawn' class-attribute \u00b6 Submission \u00b6 abstract : str class-attribute \u00b6 answers : Optional [ List [ Answer ]] class-attribute \u00b6 code : str class-attribute \u00b6 content_locale : str class-attribute \u00b6 created : Optional [ datetime ] class-attribute \u00b6 description : str class-attribute \u00b6 do_not_record : bool class-attribute \u00b6 duration : Optional [ int ] class-attribute \u00b6 image : Optional [ str ] class-attribute \u00b6 internal_notes : Optional [ str ] class-attribute \u00b6 is_featured : bool class-attribute \u00b6 notes : Optional [ str ] class-attribute \u00b6 pending_state : Optional [ State ] class-attribute \u00b6 resources : List [ Resource ] class-attribute \u00b6 slot : Optional [ Slot ] class-attribute \u00b6 slot_count : int class-attribute \u00b6 speakers : List [ SubmissionSpeaker ] class-attribute \u00b6 state : State class-attribute \u00b6 submission_type : MultiLingualStr class-attribute \u00b6 submission_type_id : int class-attribute \u00b6 tag_ids : Optional [ List [ int ]] class-attribute \u00b6 tags : Optional [ List [ str ]] class-attribute \u00b6 title : str class-attribute \u00b6 track : Optional [ MultiLingualStr ] class-attribute \u00b6 track_id : Optional [ int ] class-attribute \u00b6 SubmissionSpeaker \u00b6 avatar : Optional [ str ] class-attribute \u00b6 biography : Optional [ str ] class-attribute \u00b6 code : str class-attribute \u00b6 email : Optional [ str ] class-attribute \u00b6 name : str class-attribute \u00b6 Tag \u00b6 color : str class-attribute \u00b6 description : MultiLingualStr class-attribute \u00b6 tag : str class-attribute \u00b6 Talk \u00b6 URLs \u00b6 base : str class-attribute \u00b6 feed : str class-attribute \u00b6 login : str class-attribute \u00b6 schedule : str class-attribute \u00b6 User \u00b6 email : str class-attribute \u00b6 name : str class-attribute \u00b6","title":"types"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types","text":"Return types of the Pretalx API Documentation: https://docs.pretalx.org/api/resources/index.html Attention: Quite often the API docs and the actual results of the API differ! ToDo Find out why extra=Extra.allow causes mypy to fail. Seems like a bug in pydantic.","title":"types"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Answer","text":"","title":"Answer"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Answer.answer","text":"","title":"answer"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Answer.answer_file","text":"","title":"answer_file"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Answer.id","text":"","title":"id"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Answer.options","text":"","title":"options"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Answer.person","text":"","title":"person"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Answer.question","text":"","title":"question"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Answer.review","text":"","title":"review"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Answer.submission","text":"","title":"submission"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.AnswerQuestionRef","text":"","title":"AnswerQuestionRef"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.AnswerQuestionRef.id","text":"","title":"id"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.AnswerQuestionRef.question","text":"","title":"question"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Event","text":"","title":"Event"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Event.date_from","text":"","title":"date_from"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Event.date_to","text":"","title":"date_to"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Event.is_public","text":"","title":"is_public"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Event.name","text":"","title":"name"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Event.slug","text":"","title":"slug"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Event.timezone","text":"","title":"timezone"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Event.urls","text":"","title":"urls"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Me","text":"","title":"Me"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Me.email","text":"","title":"email"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Me.local","text":"","title":"local"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Me.name","text":"","title":"name"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Me.timezone","text":"","title":"timezone"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.MultiLingualStr","text":"","title":"MultiLingualStr"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.MultiLingualStr.de","text":"","title":"de"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.MultiLingualStr.en","text":"","title":"en"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Option","text":"","title":"Option"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Option.answer","text":"","title":"answer"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Option.id","text":"","title":"id"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question","text":"","title":"Question"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.contains_personal_data","text":"","title":"contains_personal_data"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.deadline","text":"","title":"deadline"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.default_answer","text":"","title":"default_answer"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.freeze_after","text":"","title":"freeze_after"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.help_text","text":"","title":"help_text"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.id","text":"","title":"id"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.is_public","text":"","title":"is_public"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.is_visible_to_reviewers","text":"","title":"is_visible_to_reviewers"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.max_length","text":"","title":"max_length"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.min_length","text":"","title":"min_length"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.options","text":"","title":"options"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.question","text":"","title":"question"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.question_required","text":"","title":"question_required"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.read_only","text":"","title":"read_only"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.required","text":"","title":"required"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.target","text":"","title":"target"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Question.variant","text":"","title":"variant"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.QuestionRequirement","text":"","title":"QuestionRequirement"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.QuestionRequirement.after_deadline","text":"","title":"after_deadline"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.QuestionRequirement.optional","text":"","title":"optional"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.QuestionRequirement.required","text":"","title":"required"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Resource","text":"","title":"Resource"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Resource.description","text":"","title":"description"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Resource.resource","text":"","title":"resource"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Review","text":"","title":"Review"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Review.answers","text":"","title":"answers"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Review.created","text":"","title":"created"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Review.id","text":"","title":"id"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Review.score","text":"","title":"score"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Review.submission","text":"","title":"submission"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Review.text","text":"","title":"text"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Review.updated","text":"","title":"updated"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Review.user","text":"","title":"user"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Room","text":"","title":"Room"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Room.availabilities","text":"","title":"availabilities"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Room.capacity","text":"","title":"capacity"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Room.description","text":"","title":"description"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Room.id","text":"","title":"id"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Room.name","text":"","title":"name"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Room.position","text":"","title":"position"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Room.speaker_info","text":"","title":"speaker_info"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.RoomAvailability","text":"","title":"RoomAvailability"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.RoomAvailability.end","text":"","title":"end"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.RoomAvailability.start","text":"","title":"start"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Slot","text":"","title":"Slot"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Slot.end","text":"","title":"end"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Slot.room","text":"","title":"room"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Slot.room_id","text":"","title":"room_id"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Slot.start","text":"","title":"start"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Speaker","text":"","title":"Speaker"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Speaker.answers","text":"","title":"answers"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Speaker.availabilities","text":"","title":"availabilities"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Speaker.submissions","text":"","title":"submissions"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.SpeakerAvailability","text":"","title":"SpeakerAvailability"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.SpeakerAvailability.allDay","text":"","title":"allDay"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.SpeakerAvailability.end","text":"","title":"end"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.SpeakerAvailability.id","text":"","title":"id"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.SpeakerAvailability.start","text":"","title":"start"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.State","text":"","title":"State"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.State.accepted","text":"","title":"accepted"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.State.canceled","text":"","title":"canceled"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.State.confirmed","text":"","title":"confirmed"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.State.deleted","text":"","title":"deleted"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.State.rejected","text":"","title":"rejected"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.State.submitted","text":"","title":"submitted"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.State.withdrawn","text":"","title":"withdrawn"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission","text":"","title":"Submission"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.abstract","text":"","title":"abstract"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.answers","text":"","title":"answers"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.code","text":"","title":"code"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.content_locale","text":"","title":"content_locale"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.created","text":"","title":"created"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.description","text":"","title":"description"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.do_not_record","text":"","title":"do_not_record"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.duration","text":"","title":"duration"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.image","text":"","title":"image"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.internal_notes","text":"","title":"internal_notes"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.is_featured","text":"","title":"is_featured"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.notes","text":"","title":"notes"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.pending_state","text":"","title":"pending_state"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.resources","text":"","title":"resources"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.slot","text":"","title":"slot"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.slot_count","text":"","title":"slot_count"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.speakers","text":"","title":"speakers"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.state","text":"","title":"state"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.submission_type","text":"","title":"submission_type"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.submission_type_id","text":"","title":"submission_type_id"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.tag_ids","text":"","title":"tag_ids"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.tags","text":"","title":"tags"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.title","text":"","title":"title"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.track","text":"","title":"track"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Submission.track_id","text":"","title":"track_id"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.SubmissionSpeaker","text":"","title":"SubmissionSpeaker"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.SubmissionSpeaker.avatar","text":"","title":"avatar"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.SubmissionSpeaker.biography","text":"","title":"biography"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.SubmissionSpeaker.code","text":"","title":"code"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.SubmissionSpeaker.email","text":"","title":"email"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.SubmissionSpeaker.name","text":"","title":"name"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Tag","text":"","title":"Tag"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Tag.color","text":"","title":"color"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Tag.description","text":"","title":"description"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Tag.tag","text":"","title":"tag"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.Talk","text":"","title":"Talk"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.URLs","text":"","title":"URLs"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.URLs.base","text":"","title":"base"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.URLs.feed","text":"","title":"feed"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.URLs.login","text":"","title":"login"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.URLs.schedule","text":"","title":"schedule"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.User","text":"","title":"User"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.User.email","text":"","title":"email"},{"location":"reference/pytanis/pretalx/types/#pytanis.pretalx.types.User.name","text":"","title":"name"},{"location":"reference/pytanis/pretalx/utils/","text":"utils \u00b6 Utilities related to Pretalx Col \u00b6 Convention of Pretalx column names for the functions below. affiliation = 'Affiliation' class-attribute \u00b6 availability = 'Availability' class-attribute \u00b6 availability_comment = 'Availability Comment' class-attribute \u00b6 biography = 'Biography' class-attribute \u00b6 comment = 'Comment' class-attribute \u00b6 created = 'Created' class-attribute \u00b6 duration = 'Duration' class-attribute \u00b6 email = 'Email' class-attribute \u00b6 nreviews = '#Reviews' class-attribute \u00b6 pending_state = 'Pending state' class-attribute \u00b6 pretalx_user = 'Pretalx user' class-attribute \u00b6 public = 'Public' class-attribute \u00b6 review_score = 'Review Score' class-attribute \u00b6 speaker_code = 'Speaker code' class-attribute \u00b6 speaker_name = 'Speaker name' class-attribute \u00b6 state = 'State' class-attribute \u00b6 submission = 'Submission' class-attribute \u00b6 submission_type = 'Submission type' class-attribute \u00b6 submission_type_id = 'Submission type id' class-attribute \u00b6 title = 'Title' class-attribute \u00b6 track = 'Track' class-attribute \u00b6 reviews_as_df ( reviews : Iterable [ Review ]) -> pd . DataFrame \u00b6 Convert the reviews to a dataframe Source code in pytanis/pretalx/utils.py def reviews_as_df ( reviews : Iterable [ Review ]) -> pd . DataFrame : \"\"\"Convert the reviews to a dataframe\"\"\" df = pd . DataFrame ([ review . dict () for review in reviews ]) # make first letter of column upper-case in accordance with our convention df . rename ( columns = { col : col . title () for col in df . columns }, inplace = True ) # user is the speaker name to use for joining df . rename ( columns = { \"User\" : Col . pretalx_user , \"Score\" : Col . review_score }, inplace = True ) return df speakers_as_df ( speakers : Iterable [ Speaker ], with_questions : bool = False , question_prefix : str = 'Q: ' ) -> pd . DataFrame \u00b6 Convert speakers into a dataframe Make sure to have params={\"questions\": \"all\"} for the PretalxAPI if with_questions is True. Source code in pytanis/pretalx/utils.py def speakers_as_df ( speakers : Iterable [ Speaker ], with_questions : bool = False , question_prefix : str = \"Q: \" ) -> pd . DataFrame : \"\"\"Convert speakers into a dataframe Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True. \"\"\" rows = [] for speaker in speakers : row = { Col . speaker_code : speaker . code , Col . speaker_name : speaker . name , Col . email : speaker . email , Col . biography : speaker . biography , Col . submission : speaker . submissions , } if with_questions and speaker . answers is not None : for answer in speaker . answers : # The API returns also questions that are 'per proposal/submission', we get these using the # submission endpoint and don't want them here due to ambiguity if several submission were made. if answer . person is not None : row [ f \" { question_prefix }{ answer . question . question . en } \" ] = answer . answer rows . append ( row ) return pd . DataFrame ( rows ) subs_as_df ( subs : Iterable [ Submission ], with_questions : bool = False , question_prefix : str = 'Q: ' ) -> pd . DataFrame \u00b6 Convert submissions into a dataframe Make sure to have params={\"questions\": \"all\"} for the PretalxAPI if with_questions is True. Source code in pytanis/pretalx/utils.py def subs_as_df ( subs : Iterable [ Submission ], with_questions : bool = False , question_prefix : str = \"Q: \" ) -> pd . DataFrame : \"\"\"Convert submissions into a dataframe Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True. \"\"\" rows = [] for sub in subs : row = { Col . submission : sub . code , Col . title : sub . title , Col . track : sub . track . en if sub . track else None , Col . speaker_code : [ speaker . code for speaker in sub . speakers ], Col . speaker_name : [ speaker . name for speaker in sub . speakers ], Col . duration : sub . duration , Col . submission_type : sub . submission_type . en , Col . submission_type_id : sub . submission_type_id , Col . state : sub . state . value , Col . pending_state : None if sub . pending_state is None else sub . pending_state . value , Col . created : sub . created , } if with_questions and sub . answers is not None : for answer in sub . answers : row [ f \" { question_prefix }{ answer . question . question . en } \" ] = answer . answer rows . append ( row ) return pd . DataFrame ( rows )","title":"utils"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils","text":"Utilities related to Pretalx","title":"utils"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col","text":"Convention of Pretalx column names for the functions below.","title":"Col"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.affiliation","text":"","title":"affiliation"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.availability","text":"","title":"availability"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.availability_comment","text":"","title":"availability_comment"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.biography","text":"","title":"biography"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.comment","text":"","title":"comment"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.created","text":"","title":"created"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.duration","text":"","title":"duration"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.email","text":"","title":"email"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.nreviews","text":"","title":"nreviews"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.pending_state","text":"","title":"pending_state"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.pretalx_user","text":"","title":"pretalx_user"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.public","text":"","title":"public"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.review_score","text":"","title":"review_score"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.speaker_code","text":"","title":"speaker_code"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.speaker_name","text":"","title":"speaker_name"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.state","text":"","title":"state"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.submission","text":"","title":"submission"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.submission_type","text":"","title":"submission_type"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.submission_type_id","text":"","title":"submission_type_id"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.title","text":"","title":"title"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.track","text":"","title":"track"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.reviews_as_df","text":"Convert the reviews to a dataframe Source code in pytanis/pretalx/utils.py def reviews_as_df ( reviews : Iterable [ Review ]) -> pd . DataFrame : \"\"\"Convert the reviews to a dataframe\"\"\" df = pd . DataFrame ([ review . dict () for review in reviews ]) # make first letter of column upper-case in accordance with our convention df . rename ( columns = { col : col . title () for col in df . columns }, inplace = True ) # user is the speaker name to use for joining df . rename ( columns = { \"User\" : Col . pretalx_user , \"Score\" : Col . review_score }, inplace = True ) return df","title":"reviews_as_df()"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.speakers_as_df","text":"Convert speakers into a dataframe Make sure to have params={\"questions\": \"all\"} for the PretalxAPI if with_questions is True. Source code in pytanis/pretalx/utils.py def speakers_as_df ( speakers : Iterable [ Speaker ], with_questions : bool = False , question_prefix : str = \"Q: \" ) -> pd . DataFrame : \"\"\"Convert speakers into a dataframe Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True. \"\"\" rows = [] for speaker in speakers : row = { Col . speaker_code : speaker . code , Col . speaker_name : speaker . name , Col . email : speaker . email , Col . biography : speaker . biography , Col . submission : speaker . submissions , } if with_questions and speaker . answers is not None : for answer in speaker . answers : # The API returns also questions that are 'per proposal/submission', we get these using the # submission endpoint and don't want them here due to ambiguity if several submission were made. if answer . person is not None : row [ f \" { question_prefix }{ answer . question . question . en } \" ] = answer . answer rows . append ( row ) return pd . DataFrame ( rows )","title":"speakers_as_df()"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.subs_as_df","text":"Convert submissions into a dataframe Make sure to have params={\"questions\": \"all\"} for the PretalxAPI if with_questions is True. Source code in pytanis/pretalx/utils.py def subs_as_df ( subs : Iterable [ Submission ], with_questions : bool = False , question_prefix : str = \"Q: \" ) -> pd . DataFrame : \"\"\"Convert submissions into a dataframe Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True. \"\"\" rows = [] for sub in subs : row = { Col . submission : sub . code , Col . title : sub . title , Col . track : sub . track . en if sub . track else None , Col . speaker_code : [ speaker . code for speaker in sub . speakers ], Col . speaker_name : [ speaker . name for speaker in sub . speakers ], Col . duration : sub . duration , Col . submission_type : sub . submission_type . en , Col . submission_type_id : sub . submission_type_id , Col . state : sub . state . value , Col . pending_state : None if sub . pending_state is None else sub . pending_state . value , Col . created : sub . created , } if with_questions and sub . answers is not None : for answer in sub . answers : row [ f \" { question_prefix }{ answer . question . question . en } \" ] = answer . answer rows . append ( row ) return pd . DataFrame ( rows )","title":"subs_as_df()"},{"location":"tasks/review/","text":"The Review Process \u00b6 Overview \u00b6 On a high-level, the review process of the proposals for a conference works as follows: find external reviewers and learn about their preferences, onboard reviewers in Pretalx , assign proposals to reviewers according to their preferences, communicate with the reviewers occasionally for updates, track the whole process. 1. Find External Reviewers and Learn about their Preferences \u00b6 For the PyConDE / PyData Berlin 2023, we were looking for about 50 external reviewers since we expected about 400 proposals, and we wanted to have 3 reviews per proposal. This would amount to about 25 proposals to review per person, which is manageable within a few weeks if you schedule 5-15 minutes per proposal. To get external reviewers, we decided that would only ask within our (Program Committee members') circle of trust and refer them to Google Forms . The form basically consisted of following questions with descriptions: Name [short answer]: Please write your name starting with your first name, e.g. Albert Einstein. Affiliation [short answer]: Please state the name or organisation you are affiliated with. Who do you know from the Committee? [short answer]: We believe in the ring of trust model. With this question, we really only want to make sure that random people are not signing up with no connection to any member of the Program Committee. Availability during the Review Period [checkboxes]: The bulk of the review work will take place from January 5 th to February 13 th , 2023, so it is important that you are broadly available during this period. That being said, you will be quite flexible in managing your time but being on vacation with no internet for 3 weeks might be suboptimal here ;-) There was only one mandatory checkbox: Yes, I am broadly available during this period. Additional comments regarding your availability during the review period. [long answer] Topics you want to review : These are the topics you are interested in reviewing. The more you select the better. Don't be shy, you don't have to be an expert in a topic to review a proposal. If you are interested in a topic and have some knowledge about it, you are totally up for the job :-) Each track in Pretalx corresponded to one checkbox in this form. At least 5 preferences needed to be chosen. Do you want your name to be listed as a reviewer on the conference website? [checkbox] Mandatory yes/no checkboxes Any additional comments for the Program Committee [long answer] Tip Google Form will use the separator , (comma, whitespace) for the selected checkboxes. Having the same separator in your track name, e.g. \"General: Community, Diversity, Career, Life and everything else\", will make it a bit harder to parse the resulting Google Sheet . So it's better to avoid them in track names. Depending on how you want to assign proposals to reviewers later, it might also make sense to ask the reviewers if they only want to be assigned a single batch, or if they are also interested in getting more proposals to review after their batch is done. Every submission of the Google Form is then automatically added to a Google Sheet, let's call it the volunteer sheet , which can be easily read with the help of Pytanis. Check out our Google Sheet docs and Pytanis' google module to learn about more functionality. 2. Onboard Reviewers in Pretalx \u00b6 In Pretalx select Organisers in the left menu bar (you need Admin-rights for that) and click the teams under your event name. You should see a list of all teams and it's a good idea to have one for all reviewers, e.g. 2023-Reviewers-ALL . By clicking on the team name you get to a page that lists the names and corresponding e-mails of team members as well as an option to add new members at the bottom. You can now start typing in the e-mail addresses from the volunteer sheet to send out invitations to them. After volunteers accept the invitation they will show up with a user-name and e-mail in the team table. Now, here comes the tricky part that can cause a lot of confusion. If person A entered in the Google Form the e-mail address work@mail.com , and you added this in Pretalx, it might happen that person A accepts the team invitation with a different Pretalx account that is linked to the e-mail address private@mail.com . In this case, Pretalx will automatically replace work@mail.com , which was used for the invitation, with private@mail.com in the Pretalx table of team members. Unfortunately, Pretalx has no way of automatically tracking this change of mail addresses and this issue, as filed in #1417 , is still unresolved. To work around this email issue and to be able to later join your volunteer sheet for instance with reviews, it makes sense to introduce a new column, e.g. \"Pretalx mail\", where you add the actual Pretalx account e-mail that was used by the invited user. Additionally, you should have a column for the Pretalx user-name, e.g. \"Pretalx user\", where you state the user-name by copying it over from the Pretalx team member table. This user-name column will be useful later to join our volunteer reviewers with the reviews they did, because the review-endpoint of Pretalx only returns the user-name, not the e-mail of a reviewer. This problem was also discussed in #1416 and is an intended behaviour. 3. Assign Proposals to Reviewers according to their Preferences \u00b6 Pretalx already provides a basic assignment feature so that proposals with the least number of reviews will show up earlier in the review queue so that they get more reviews. Additionally, Pretalx allows uploading a mapping JSON file so that you can assign certain proposals to a reviewer matching their preferences with the tracks of the proposals. Also, Pretalx is working on more elaborate automatic assignment features and some discussion about it can be found in issue #1331 . [Pytanis] allows you to create JSON mapping files that can be uploaded in Pretalx under Review \u00bb Assign reviews . Then click Actions (upper right) \u00bb Import assignments and select the option Assign proposals to reviewers , choose the JSON file and make sure to always set Replace current assignments to Yes . Overwriting the current assignments makes sure that the assignment state in Pretalx is always consistent with what you expect. Also, be sure to always back up your assignment files somewhere in case you need to roll back later on. To make this easy, just name your files assignments-YYYYMMDD_I.json , where YYYY is the current year, MM the month, DD the day in the month and I the version increment, e.g. 1 or 2 , in case you need several assignments throughout the same day. So how do you create an assignment file using Pytanis? Currently, we have implemented in a notebook an initial simple algorithm that can be easily run. Fancier algorithms will come in the future and don't hesitate to contribute . The main idea of the algorithm is to set a goal of number of reviews for each proposal, e.g. 3 reviews, and a certain buffer, e.g. 1. This means every proposal is assigned to goal number of reviews + buffer - current review number in case the current review number is not already equal or greater than the goal number of reviews. Rerunning this assignment frequently helps to avoid overshooting as the buffer mainly addresses the fact that you will also have inactive reviewers or some that start on the last day before your review deadline. For each proposal and remaining review, the algorithm assigns the proposals to: not a person having already assigned the review for a proposal (no duplicates), to a person having a preference for the track with the least amount of current work, if no person has a preference for the track of the proposal, assign to someone with not much work. Be aware that some of your reviewers might have also make proposal submissions. Thus, it might happen by chance that someone gets assigned his/her own proposal using this approach but luckily Pretalx takes care of that--if the same Pretalx account was used. This quite simple algorithm can be found in the notebook 10_reviewer-assignment_v1 . It uses Pytanis to pull the submission/proposals as well as the current reviews from Pretalx and joins them to get an overview of the current state of reviews. Then Pytanis is used to get the Google sheet of reviewers and their preferences, which is also joined with the data from Pretalx. Then the aforementioned algorithm is run and the assignment JSON file written. 4. Communicate with the Reviewers occasionally for Updates \u00b6 From time to time, you want to get in contact with your reviewers to remind them of some deadline or just to say thank you for their work. Pytanis has an easy interface to HelpDesk that can be used as an e-mail client. For some practical examples, just check out the notebook 20_mail_to_reviewers_v1 , the docs about mailing , as well as the Pytanis' mail references . 5. Track the whole process \u00b6 During the review process it very important to keep track of review activity to make sure your internal deadlines for the review process are met. For instance, there might be reviewers that are having difficulties but have not reached out yet. So finding inactivate reviewers after a certain period of time and sending a nice supportive e-mail helps a lot. Also, some reviewers might have finished their batch of work early but might be up for more, thus identifying and getting in contact with them, is always a good idea. Many of those analyses are really individual, and you can check our examples in the notebook 10_reviewer-assignment_v1 .","title":"Proposal Review"},{"location":"tasks/review/#the-review-process","text":"","title":"The Review Process"},{"location":"tasks/review/#overview","text":"On a high-level, the review process of the proposals for a conference works as follows: find external reviewers and learn about their preferences, onboard reviewers in Pretalx , assign proposals to reviewers according to their preferences, communicate with the reviewers occasionally for updates, track the whole process.","title":"Overview"},{"location":"tasks/review/#1-find-external-reviewers-and-learn-about-their-preferences","text":"For the PyConDE / PyData Berlin 2023, we were looking for about 50 external reviewers since we expected about 400 proposals, and we wanted to have 3 reviews per proposal. This would amount to about 25 proposals to review per person, which is manageable within a few weeks if you schedule 5-15 minutes per proposal. To get external reviewers, we decided that would only ask within our (Program Committee members') circle of trust and refer them to Google Forms . The form basically consisted of following questions with descriptions: Name [short answer]: Please write your name starting with your first name, e.g. Albert Einstein. Affiliation [short answer]: Please state the name or organisation you are affiliated with. Who do you know from the Committee? [short answer]: We believe in the ring of trust model. With this question, we really only want to make sure that random people are not signing up with no connection to any member of the Program Committee. Availability during the Review Period [checkboxes]: The bulk of the review work will take place from January 5 th to February 13 th , 2023, so it is important that you are broadly available during this period. That being said, you will be quite flexible in managing your time but being on vacation with no internet for 3 weeks might be suboptimal here ;-) There was only one mandatory checkbox: Yes, I am broadly available during this period. Additional comments regarding your availability during the review period. [long answer] Topics you want to review : These are the topics you are interested in reviewing. The more you select the better. Don't be shy, you don't have to be an expert in a topic to review a proposal. If you are interested in a topic and have some knowledge about it, you are totally up for the job :-) Each track in Pretalx corresponded to one checkbox in this form. At least 5 preferences needed to be chosen. Do you want your name to be listed as a reviewer on the conference website? [checkbox] Mandatory yes/no checkboxes Any additional comments for the Program Committee [long answer] Tip Google Form will use the separator , (comma, whitespace) for the selected checkboxes. Having the same separator in your track name, e.g. \"General: Community, Diversity, Career, Life and everything else\", will make it a bit harder to parse the resulting Google Sheet . So it's better to avoid them in track names. Depending on how you want to assign proposals to reviewers later, it might also make sense to ask the reviewers if they only want to be assigned a single batch, or if they are also interested in getting more proposals to review after their batch is done. Every submission of the Google Form is then automatically added to a Google Sheet, let's call it the volunteer sheet , which can be easily read with the help of Pytanis. Check out our Google Sheet docs and Pytanis' google module to learn about more functionality.","title":"1. Find External Reviewers and Learn about their Preferences"},{"location":"tasks/review/#2-onboard-reviewers-in-pretalx","text":"In Pretalx select Organisers in the left menu bar (you need Admin-rights for that) and click the teams under your event name. You should see a list of all teams and it's a good idea to have one for all reviewers, e.g. 2023-Reviewers-ALL . By clicking on the team name you get to a page that lists the names and corresponding e-mails of team members as well as an option to add new members at the bottom. You can now start typing in the e-mail addresses from the volunteer sheet to send out invitations to them. After volunteers accept the invitation they will show up with a user-name and e-mail in the team table. Now, here comes the tricky part that can cause a lot of confusion. If person A entered in the Google Form the e-mail address work@mail.com , and you added this in Pretalx, it might happen that person A accepts the team invitation with a different Pretalx account that is linked to the e-mail address private@mail.com . In this case, Pretalx will automatically replace work@mail.com , which was used for the invitation, with private@mail.com in the Pretalx table of team members. Unfortunately, Pretalx has no way of automatically tracking this change of mail addresses and this issue, as filed in #1417 , is still unresolved. To work around this email issue and to be able to later join your volunteer sheet for instance with reviews, it makes sense to introduce a new column, e.g. \"Pretalx mail\", where you add the actual Pretalx account e-mail that was used by the invited user. Additionally, you should have a column for the Pretalx user-name, e.g. \"Pretalx user\", where you state the user-name by copying it over from the Pretalx team member table. This user-name column will be useful later to join our volunteer reviewers with the reviews they did, because the review-endpoint of Pretalx only returns the user-name, not the e-mail of a reviewer. This problem was also discussed in #1416 and is an intended behaviour.","title":"2. Onboard Reviewers in Pretalx"},{"location":"tasks/review/#3-assign-proposals-to-reviewers-according-to-their-preferences","text":"Pretalx already provides a basic assignment feature so that proposals with the least number of reviews will show up earlier in the review queue so that they get more reviews. Additionally, Pretalx allows uploading a mapping JSON file so that you can assign certain proposals to a reviewer matching their preferences with the tracks of the proposals. Also, Pretalx is working on more elaborate automatic assignment features and some discussion about it can be found in issue #1331 . [Pytanis] allows you to create JSON mapping files that can be uploaded in Pretalx under Review \u00bb Assign reviews . Then click Actions (upper right) \u00bb Import assignments and select the option Assign proposals to reviewers , choose the JSON file and make sure to always set Replace current assignments to Yes . Overwriting the current assignments makes sure that the assignment state in Pretalx is always consistent with what you expect. Also, be sure to always back up your assignment files somewhere in case you need to roll back later on. To make this easy, just name your files assignments-YYYYMMDD_I.json , where YYYY is the current year, MM the month, DD the day in the month and I the version increment, e.g. 1 or 2 , in case you need several assignments throughout the same day. So how do you create an assignment file using Pytanis? Currently, we have implemented in a notebook an initial simple algorithm that can be easily run. Fancier algorithms will come in the future and don't hesitate to contribute . The main idea of the algorithm is to set a goal of number of reviews for each proposal, e.g. 3 reviews, and a certain buffer, e.g. 1. This means every proposal is assigned to goal number of reviews + buffer - current review number in case the current review number is not already equal or greater than the goal number of reviews. Rerunning this assignment frequently helps to avoid overshooting as the buffer mainly addresses the fact that you will also have inactive reviewers or some that start on the last day before your review deadline. For each proposal and remaining review, the algorithm assigns the proposals to: not a person having already assigned the review for a proposal (no duplicates), to a person having a preference for the track with the least amount of current work, if no person has a preference for the track of the proposal, assign to someone with not much work. Be aware that some of your reviewers might have also make proposal submissions. Thus, it might happen by chance that someone gets assigned his/her own proposal using this approach but luckily Pretalx takes care of that--if the same Pretalx account was used. This quite simple algorithm can be found in the notebook 10_reviewer-assignment_v1 . It uses Pytanis to pull the submission/proposals as well as the current reviews from Pretalx and joins them to get an overview of the current state of reviews. Then Pytanis is used to get the Google sheet of reviewers and their preferences, which is also joined with the data from Pretalx. Then the aforementioned algorithm is run and the assignment JSON file written.","title":"3. Assign Proposals to Reviewers according to their Preferences"},{"location":"tasks/review/#4-communicate-with-the-reviewers-occasionally-for-updates","text":"From time to time, you want to get in contact with your reviewers to remind them of some deadline or just to say thank you for their work. Pytanis has an easy interface to HelpDesk that can be used as an e-mail client. For some practical examples, just check out the notebook 20_mail_to_reviewers_v1 , the docs about mailing , as well as the Pytanis' mail references .","title":"4. Communicate with the Reviewers occasionally for Updates"},{"location":"tasks/review/#5-track-the-whole-process","text":"During the review process it very important to keep track of review activity to make sure your internal deadlines for the review process are met. For instance, there might be reviewers that are having difficulties but have not reached out yet. So finding inactivate reviewers after a certain period of time and sending a nice supportive e-mail helps a lot. Also, some reviewers might have finished their batch of work early but might be up for more, thus identifying and getting in contact with them, is always a good idea. Many of those analyses are really individual, and you can check our examples in the notebook 10_reviewer-assignment_v1 .","title":"5. Track the whole process"},{"location":"tasks/schedule/","text":"Creating the Schedule \u00b6 After all you talks and tutorials are confirmed, the next major milestone is to create a schedule so that each talk gets a time and place to be presented. Pretalx allows you to create a schedule by dragging & dropping the talk blocks onto a schedule, where you can define the number of days and rooms. You can also specify breaks like lunch or coffee breaks and later on publish the schedule for everyone. So this feature is pretty need but for larger conferences with a lot of parallel sessions, i.e. many rooms, some help might be needed. Assuming that you had some blank schedule before that already defines the time slots with their lengths and when the breaks are, then surely following constraints must be satisfied: each talk must be assigned to a time slot, each room/time slot combination can only be occupied by one talk at most, the length of the time slot must match the length of the talk, if some talks/tutorials have several parts, e.g. part 1 & 2, they must be consecutive. Besides those constraints you might want to optimize for several objectives: the preferences for day and time of the speakers are considered (if they provided some), the more popular a talk is (from the public voting data), the more capacity the assigned room should have, if many people are highly interested in seeing two talks (voting data), these talks should rather not be scheduled in parallel. Also, sponsored talks should never be in parallel to avoid cannibalization, talks should have same main track, e.g. PyData, if they are in the same session (block of talks in one room), talks should have same sub track, e.g. PyData: Data Handling, if they are in the same session. The easiest way of dealing with multi-objective optimization is to create one new main objective by weighting and summing all objectives. For the objectives outlined above, it surely makes sense to choose the weights so that the importance is 1 > 2 > 3 > 4 > 5. In the notebook 50_scheduling_v1 , you can find an example that uses Mixed-Integer-Programming (MIP) to generate a preliminary schedule that can be used as a starting point before creating the schedule in Pretalx. Although the constraints and objective from above may look quite simple, MIPs are not only hard, they are even NP-hard ;-) The example in the notebook uses Pyomo to formulate the problem and transform it into a standardized form, so that the solver HiGHS can do its job. In the concrete example, even after 24h no perfect solution was found, but the good thing is that the gap between best found feasible solution and the maximum possible objective value, i.e. the gap, was relatively small. Again, to visualize a solution like this, you can push it easily with the help of Pytanis to Google Sheets , which is illustrated in the figure below. Tip If you want to also specify link previews , sometimes also called a social banners, then check out the notebook 40_talk_image_v1 on how Pytanis can help you to create them.","title":"Scheduling"},{"location":"tasks/schedule/#creating-the-schedule","text":"After all you talks and tutorials are confirmed, the next major milestone is to create a schedule so that each talk gets a time and place to be presented. Pretalx allows you to create a schedule by dragging & dropping the talk blocks onto a schedule, where you can define the number of days and rooms. You can also specify breaks like lunch or coffee breaks and later on publish the schedule for everyone. So this feature is pretty need but for larger conferences with a lot of parallel sessions, i.e. many rooms, some help might be needed. Assuming that you had some blank schedule before that already defines the time slots with their lengths and when the breaks are, then surely following constraints must be satisfied: each talk must be assigned to a time slot, each room/time slot combination can only be occupied by one talk at most, the length of the time slot must match the length of the talk, if some talks/tutorials have several parts, e.g. part 1 & 2, they must be consecutive. Besides those constraints you might want to optimize for several objectives: the preferences for day and time of the speakers are considered (if they provided some), the more popular a talk is (from the public voting data), the more capacity the assigned room should have, if many people are highly interested in seeing two talks (voting data), these talks should rather not be scheduled in parallel. Also, sponsored talks should never be in parallel to avoid cannibalization, talks should have same main track, e.g. PyData, if they are in the same session (block of talks in one room), talks should have same sub track, e.g. PyData: Data Handling, if they are in the same session. The easiest way of dealing with multi-objective optimization is to create one new main objective by weighting and summing all objectives. For the objectives outlined above, it surely makes sense to choose the weights so that the importance is 1 > 2 > 3 > 4 > 5. In the notebook 50_scheduling_v1 , you can find an example that uses Mixed-Integer-Programming (MIP) to generate a preliminary schedule that can be used as a starting point before creating the schedule in Pretalx. Although the constraints and objective from above may look quite simple, MIPs are not only hard, they are even NP-hard ;-) The example in the notebook uses Pyomo to formulate the problem and transform it into a standardized form, so that the solver HiGHS can do its job. In the concrete example, even after 24h no perfect solution was found, but the good thing is that the gap between best found feasible solution and the maximum possible objective value, i.e. the gap, was relatively small. Again, to visualize a solution like this, you can push it easily with the help of Pytanis to Google Sheets , which is illustrated in the figure below. Tip If you want to also specify link previews , sometimes also called a social banners, then check out the notebook 40_talk_image_v1 on how Pytanis can help you to create them.","title":"Creating the Schedule"},{"location":"tasks/selection/","text":"The Selection Process \u00b6 Overview \u00b6 On a high-level, the selection process involves the following have an optional public voting for the proposals, decide on how many talks, tutorials in which length, track or skill level you want to have, get an overview of the proposals, the speakers, the reviewer scores, and optionally the vote scores, select in Pretalx which talks are accepted and which ones are not. 1. Optional Public Voting \u00b6 The pretalx-public-voting plugin allows to vote for the proposals which is a nice signal if a talk is generally interesting to the audience or not, solely based on the title and abstract. If it is installed activate it in Pretalx under Settings \u00bb Public voting . After the end date of the voting has passed this is also the place where you can download the results as a csv file. Unfortunately, there is currently no API provided by Pretalx for this feature. 2. Decision on Number of Talks and Rules for Acceptance \u00b6 Deciding on the rules of acceptance might be one of the hardest parts and no Software can support you with it. It is really important to do this early on since it will help with the actual selection process. In order to decide for instance for the number of talks/tutorials in various lengths, it's important to already have a blank schedule, i.e. just the time slots, at hand. Diversity is also an important topic, so one rule might be to over-represent the under-represented but by how much? And do you expect your audience to be rather advanced, even senior, and what does that mean for ratio of the various required skill levels of the talks? How about the tracks you defined? Are speakers allowed to give more than one talk? How to deal with talks that have been given before? It's best to decide on a few guidelines before you proceed with the next steps. 3. Overview of the proposals \u00b6 Getting an overview of all proposals, their features, their review score and optionally their public score, is crucial when it comes to make a selection. Luckily with the help of Pytanis this is really easy. You can pull all the data from Pretalx, join it with additional data like the voting scores and push it to a Google Sheet , where everyone can easily view it and add comments. Find a practical example on how Pytanis was used for the PyConDE / PyData 2023 in this notebook 30_selection_v1 . 4. Final Selection in Pretalx \u00b6 Selecting the talks/tutorials for your conference is an iterative process. Maybe there are some talks you definitely want to select and others so bad you surely want to reject. Then there might be some you want to preliminarily accept or reject. Fortunately, Pretalx allows all that and Pytanis can pull that information to mark the rows in your GSheet with a certain colour. Here is an example on how this might look like. This example is also part of the notebook 30_selection_v1 . Also be aware that after you accepted a talk or tutorial the author(s) must confirm. In practice, it happens also that accepted talks are withdrawn, so make sure you always keep a buffer of talks that haven't gotten any feedback yet to be able to accept some more.","title":"Talk Selection"},{"location":"tasks/selection/#the-selection-process","text":"","title":"The Selection Process"},{"location":"tasks/selection/#overview","text":"On a high-level, the selection process involves the following have an optional public voting for the proposals, decide on how many talks, tutorials in which length, track or skill level you want to have, get an overview of the proposals, the speakers, the reviewer scores, and optionally the vote scores, select in Pretalx which talks are accepted and which ones are not.","title":"Overview"},{"location":"tasks/selection/#1-optional-public-voting","text":"The pretalx-public-voting plugin allows to vote for the proposals which is a nice signal if a talk is generally interesting to the audience or not, solely based on the title and abstract. If it is installed activate it in Pretalx under Settings \u00bb Public voting . After the end date of the voting has passed this is also the place where you can download the results as a csv file. Unfortunately, there is currently no API provided by Pretalx for this feature.","title":"1. Optional Public Voting"},{"location":"tasks/selection/#2-decision-on-number-of-talks-and-rules-for-acceptance","text":"Deciding on the rules of acceptance might be one of the hardest parts and no Software can support you with it. It is really important to do this early on since it will help with the actual selection process. In order to decide for instance for the number of talks/tutorials in various lengths, it's important to already have a blank schedule, i.e. just the time slots, at hand. Diversity is also an important topic, so one rule might be to over-represent the under-represented but by how much? And do you expect your audience to be rather advanced, even senior, and what does that mean for ratio of the various required skill levels of the talks? How about the tracks you defined? Are speakers allowed to give more than one talk? How to deal with talks that have been given before? It's best to decide on a few guidelines before you proceed with the next steps.","title":"2. Decision on Number of Talks and Rules for Acceptance"},{"location":"tasks/selection/#3-overview-of-the-proposals","text":"Getting an overview of all proposals, their features, their review score and optionally their public score, is crucial when it comes to make a selection. Luckily with the help of Pytanis this is really easy. You can pull all the data from Pretalx, join it with additional data like the voting scores and push it to a Google Sheet , where everyone can easily view it and add comments. Find a practical example on how Pytanis was used for the PyConDE / PyData 2023 in this notebook 30_selection_v1 .","title":"3. Overview of the proposals"},{"location":"tasks/selection/#4-final-selection-in-pretalx","text":"Selecting the talks/tutorials for your conference is an iterative process. Maybe there are some talks you definitely want to select and others so bad you surely want to reject. Then there might be some you want to preliminarily accept or reject. Fortunately, Pretalx allows all that and Pytanis can pull that information to mark the rows in your GSheet with a certain colour. Here is an example on how this might look like. This example is also part of the notebook 30_selection_v1 . Also be aware that after you accepted a talk or tutorial the author(s) must confirm. In practice, it happens also that accepted talks are withdrawn, so make sure you always keep a buffer of talks that haven't gotten any feedback yet to be able to accept some more.","title":"4. Final Selection in Pretalx"},{"location":"usage/gsheet/","text":"Basic Usage \u00b6 Pytanis' Google Sheet client is really made for simplicity. Retrieving a worksheet of a Google sheet is as simple as: from pytanis import GSheetClient gsheet_client = GSheetClient () gsheet_df = gsheet_client . gsheet_as_df ( SPREADSHEET_ID , WORKSHEET_NAME ) where SPREADSHEET_ID is the ID taken from the spreadsheet's url, e.g. the ID is 17juVXM7V3p7Fgfi-9WkwPlMAYJB-DuxRhYCi_hastbB if your spreadsheet's url is https://docs.google.com/spreadsheets/d/17juVXM7V3p7Fgfi-9WkwPlMAYJB-DuxRhYCi_hastbB/edit#gid=1289752230 , and WORKSHEET_NAME is the name of the actual sheet, e.g. Form responses 1 , that you find in the lower bar of your spreadsheet. The function gsheet_as_df returns a simple Pandas dataframe, which most users are surely familiar with. If you run the above script the first time, you will get a link to a Google consent page, or it will directly open up if you run this in a Jupter notebook. Read it carefully and accept the access to your Google Sheet. This step is only necessary and everytime you change the access scope. For instance if you also want to have write-access to a worksheet, run: gsheet_client = GSheetClient ( read_only = False ) gsheet_client . recreate_token () and you will see the consent screen again, asking this time for write-access. Having accepted, you can now use gsheet_client . save_df_as_gsheet ( subs_df , SPREADSHEET_ID , WORKSHEET_NAME ) to upload a dataframe as Google sheet, overriding what's currently in there. Tip Google Sheet has a real useful version history that can be found under File \u00bb Version history \u00bb See version history . Even if you have accidentally overwritten you Google Sheet you can also restore an old version. Advanced Usage \u00b6 In case you want even more functionality and a dataframe is just not enough, you can use the gsheet method to get a Worksheet object or Spreadsheet object of GSpread . GSpread gives you full access to the API of Google Sheet and all the gsheet_as_df does is to basically use GSpread-Dataframe to convert this into a Pandas dataframe to simplify things for you. Also check out GSpread-Formatting if you want to use features like conditional formatting, colors cells, etc. Pytanis' google module gives you a complete reference of the current functionality within Pytanis but make sure to check out the GSpread ecosystem too as mentioned above.","title":"Google Sheets"},{"location":"usage/gsheet/#basic-usage","text":"Pytanis' Google Sheet client is really made for simplicity. Retrieving a worksheet of a Google sheet is as simple as: from pytanis import GSheetClient gsheet_client = GSheetClient () gsheet_df = gsheet_client . gsheet_as_df ( SPREADSHEET_ID , WORKSHEET_NAME ) where SPREADSHEET_ID is the ID taken from the spreadsheet's url, e.g. the ID is 17juVXM7V3p7Fgfi-9WkwPlMAYJB-DuxRhYCi_hastbB if your spreadsheet's url is https://docs.google.com/spreadsheets/d/17juVXM7V3p7Fgfi-9WkwPlMAYJB-DuxRhYCi_hastbB/edit#gid=1289752230 , and WORKSHEET_NAME is the name of the actual sheet, e.g. Form responses 1 , that you find in the lower bar of your spreadsheet. The function gsheet_as_df returns a simple Pandas dataframe, which most users are surely familiar with. If you run the above script the first time, you will get a link to a Google consent page, or it will directly open up if you run this in a Jupter notebook. Read it carefully and accept the access to your Google Sheet. This step is only necessary and everytime you change the access scope. For instance if you also want to have write-access to a worksheet, run: gsheet_client = GSheetClient ( read_only = False ) gsheet_client . recreate_token () and you will see the consent screen again, asking this time for write-access. Having accepted, you can now use gsheet_client . save_df_as_gsheet ( subs_df , SPREADSHEET_ID , WORKSHEET_NAME ) to upload a dataframe as Google sheet, overriding what's currently in there. Tip Google Sheet has a real useful version history that can be found under File \u00bb Version history \u00bb See version history . Even if you have accidentally overwritten you Google Sheet you can also restore an old version.","title":"Basic Usage"},{"location":"usage/gsheet/#advanced-usage","text":"In case you want even more functionality and a dataframe is just not enough, you can use the gsheet method to get a Worksheet object or Spreadsheet object of GSpread . GSpread gives you full access to the API of Google Sheet and all the gsheet_as_df does is to basically use GSpread-Dataframe to convert this into a Pandas dataframe to simplify things for you. Also check out GSpread-Formatting if you want to use features like conditional formatting, colors cells, etc. Pytanis' google module gives you a complete reference of the current functionality within Pytanis but make sure to check out the GSpread ecosystem too as mentioned above.","title":"Advanced Usage"},{"location":"usage/installation/","text":"Installation \u00b6 To install Pytanis simple run: pip install pytanis or to install all recommended additional dependencies: pip install 'pytanis[all]' Then create a configuration file and directory in your user's home directory. For Linux/MacOS/Unix use ~/.pytanis/config.toml and for Windows $HOME\\.pytanis\\config.toml , where $HOME is e.g. C:\\Users\\yourusername\\ . Use your favourite editor to open config.toml within the .pytanis directory and add the following content: [Pretalx] api_token = \"932ndsf9uk32nf9sdkn3454532nj32jn\" [Google] client_secret_json = \"client_secret.json\" token_json = \"token.json\" [HelpDesk] account = \"934jcjkdf-39df-9df-93kf-934jfhuuij39fd\" entity_id = \"email@host.com\" token = \"dal:Sx4id934C3Y-X934jldjdfjk\" where you need to replace the dummy values in the sections [Pretalx] and [HelpDesk] accordingly. Info You have to configure the credentials and tokens only for the sections you actually want to use. For instance, [Pretalx] and [Google] are the most important sections for users that want to interact with Pretalx and also Google Sheets . If for instance no access to HelpDesk is necessary, e.g. no mails need to be sent, you can just leave out the key/value pairs in the [HelpDesk] section. Retrieving the Credentials and Tokens \u00b6 Google : Follow the Python Quickstart for the Google API to generate and download the file client_secret.json . Move it to the ~/.pytanis folder as client_secret.json . The file token.json will be automatically generated later. Note that config.toml references those two files relative to its own location. Pretalx : The API token for the Pretalx API can be found in your user settings. HelpDesk : Log into the LiveChat Developer Console then go to Tools \u00bb Personal Access Tokens . Hit Create new token + , enter a the name Pytanis , select all scopes and confirm. In the following screen copy the Account ID , Entity ID and Token and paste them into config.toml . In case there is any trouble with livechat, contact a helpdesk admin.","title":"Getting Started"},{"location":"usage/installation/#installation","text":"To install Pytanis simple run: pip install pytanis or to install all recommended additional dependencies: pip install 'pytanis[all]' Then create a configuration file and directory in your user's home directory. For Linux/MacOS/Unix use ~/.pytanis/config.toml and for Windows $HOME\\.pytanis\\config.toml , where $HOME is e.g. C:\\Users\\yourusername\\ . Use your favourite editor to open config.toml within the .pytanis directory and add the following content: [Pretalx] api_token = \"932ndsf9uk32nf9sdkn3454532nj32jn\" [Google] client_secret_json = \"client_secret.json\" token_json = \"token.json\" [HelpDesk] account = \"934jcjkdf-39df-9df-93kf-934jfhuuij39fd\" entity_id = \"email@host.com\" token = \"dal:Sx4id934C3Y-X934jldjdfjk\" where you need to replace the dummy values in the sections [Pretalx] and [HelpDesk] accordingly. Info You have to configure the credentials and tokens only for the sections you actually want to use. For instance, [Pretalx] and [Google] are the most important sections for users that want to interact with Pretalx and also Google Sheets . If for instance no access to HelpDesk is necessary, e.g. no mails need to be sent, you can just leave out the key/value pairs in the [HelpDesk] section.","title":"Installation"},{"location":"usage/installation/#retrieving-the-credentials-and-tokens","text":"Google : Follow the Python Quickstart for the Google API to generate and download the file client_secret.json . Move it to the ~/.pytanis folder as client_secret.json . The file token.json will be automatically generated later. Note that config.toml references those two files relative to its own location. Pretalx : The API token for the Pretalx API can be found in your user settings. HelpDesk : Log into the LiveChat Developer Console then go to Tools \u00bb Personal Access Tokens . Hit Create new token + , enter a the name Pytanis , select all scopes and confirm. In the following screen copy the Account ID , Entity ID and Token and paste them into config.toml . In case there is any trouble with livechat, contact a helpdesk admin.","title":"Retrieving the Credentials and Tokens"},{"location":"usage/mail/","text":"Basic Usage \u00b6 The usage of Pytanis' mail functionality is really simple. There are only three steps, you instantiate the mail client, create a mail object with your content and assemble a list of recipients. Team & Agent ID \u00b6 But before we write an e-mail we have to determine the team and agent id so that the e-mails we send are assigned to the right roles as set up within HelpDesk . In order to do this, we can just do: from pytanis import HelpDeskClient helpdesk = HelpDeskClient () print ([ agent . ID for agent in helpdesk . list_agents () if \"AGENTS EMAIL\" in agent . email ]) print ([ team . ID for team in helpdesk . list_teams () if \"TEAM NAME\" in team . name ]) to find the right IDs with respect to the e-mail address AGENTS EMAIL and the corresponding TEAM NAME . We assume know that you stored those two values in agent_id and team_id , respectively. Defining the Recipients \u00b6 Defining the recipients means that you create a list of Recipient objects like: from pytanis.helpdesk import Recipient recipients = [ Recipient ( name = \"Peter Parker\" , email = \"peter@parker.com\" , address_as = \"Peter\" ), Recipient ( name = \"Mary Watson\" , email = \"marry-jane@watson.com\" , address_as = \"Mary\" ), ] in most cases you will create this using a dataframe of some Google Sheet , and thus it will look more like: recipients = [] recip_df = google_sheet_df [[ \"First name\" , \"Last name\" , \"E-mail\" ]] for _ , row in recip_df . iterrows (): recipient = Recipient ( name = f \" { row [ 'First name' ] } { row [ 'Last name' ] } \" , email = row [ \"E-mail\" ], address_as = row [ \"First name\" ], ) recipients . append ( recipient ) For more advanced usages, e.g. individual mails corresponding to certain individuals, you can use the data parameter of the Recipient that takes a dictionary. Let's say we want to add a special sentence later for Peter to pay his rent, we can define: Recipient ( name = \"Peter Parker\" , email = \"peter@parker.com\" , address_as = \"Peter\" , data = { \"feedback\" : \"Pay your rent, Parker!\" }, ) In the section, we will see how we can access this special attribute again. Writing the E-Mail \u00b6 So now we can write the actual e-mail text, which just uses the basic string substitution functionality of Python: mail_body = \"\"\" Hi {recipient.address_as} ! This is a message from the Program committee with the subject {mail.subject} :-) {recipient.data.feedback} Thank you very much {recipient.address_as} for your support! All the best, Program Committee \"\"\" You see that we can use recipient and mail to access the attributes of the Recipient as well as the Mail object to personalize the e-mail. Now we create the Mail object with: from pytanis.helpdesk import Mail mail = Mail ( subject = \"Deadline is coming soon\" , text = mail_body , team_id = team_id , agent_id = agent_id , status = \"solved\" , recipients = recipients , ) Sending an E-mail \u00b6 Now we have everything assembled to send the e-mail with: from pytanis.helpdesk import MailClient mail_client = MailClient () responses , errors = mail_client . send ( mail , dry_run = True ) assert not errors Having dry_run=True allows you to test you code and just print the resulting e-mails on your console to check if everything is like expected. Later set dry_run=False to actually send the e-mails via HelpDesk . The method send returns a list of successful responses and a hopefully empty list of errors . The responses list is a list of tuples where each tuple holds the Recipient as wells as the returned HelpDesk ticket. The errors list is a list of tuples with the Recipient and the corresponding exception object which occured when sending the mail to the recipient. Advanced Usage \u00b6 For more details, check out Pytanis' mail references and also the notebook 20_mail_to_reviewers_v1 . Tip For contacting your (potential) speakers, Pretalx itself has pretty advanced templating and mailing features so there is no need to use this functionality here. Just make sure that you refer always to HelpDesk in your mails, so that you have a single point of managing mails and tickets.","title":"Sending Mails"},{"location":"usage/mail/#basic-usage","text":"The usage of Pytanis' mail functionality is really simple. There are only three steps, you instantiate the mail client, create a mail object with your content and assemble a list of recipients.","title":"Basic Usage"},{"location":"usage/mail/#team-agent-id","text":"But before we write an e-mail we have to determine the team and agent id so that the e-mails we send are assigned to the right roles as set up within HelpDesk . In order to do this, we can just do: from pytanis import HelpDeskClient helpdesk = HelpDeskClient () print ([ agent . ID for agent in helpdesk . list_agents () if \"AGENTS EMAIL\" in agent . email ]) print ([ team . ID for team in helpdesk . list_teams () if \"TEAM NAME\" in team . name ]) to find the right IDs with respect to the e-mail address AGENTS EMAIL and the corresponding TEAM NAME . We assume know that you stored those two values in agent_id and team_id , respectively.","title":"Team &amp; Agent ID"},{"location":"usage/mail/#defining-the-recipients","text":"Defining the recipients means that you create a list of Recipient objects like: from pytanis.helpdesk import Recipient recipients = [ Recipient ( name = \"Peter Parker\" , email = \"peter@parker.com\" , address_as = \"Peter\" ), Recipient ( name = \"Mary Watson\" , email = \"marry-jane@watson.com\" , address_as = \"Mary\" ), ] in most cases you will create this using a dataframe of some Google Sheet , and thus it will look more like: recipients = [] recip_df = google_sheet_df [[ \"First name\" , \"Last name\" , \"E-mail\" ]] for _ , row in recip_df . iterrows (): recipient = Recipient ( name = f \" { row [ 'First name' ] } { row [ 'Last name' ] } \" , email = row [ \"E-mail\" ], address_as = row [ \"First name\" ], ) recipients . append ( recipient ) For more advanced usages, e.g. individual mails corresponding to certain individuals, you can use the data parameter of the Recipient that takes a dictionary. Let's say we want to add a special sentence later for Peter to pay his rent, we can define: Recipient ( name = \"Peter Parker\" , email = \"peter@parker.com\" , address_as = \"Peter\" , data = { \"feedback\" : \"Pay your rent, Parker!\" }, ) In the section, we will see how we can access this special attribute again.","title":"Defining the Recipients"},{"location":"usage/mail/#writing-the-e-mail","text":"So now we can write the actual e-mail text, which just uses the basic string substitution functionality of Python: mail_body = \"\"\" Hi {recipient.address_as} ! This is a message from the Program committee with the subject {mail.subject} :-) {recipient.data.feedback} Thank you very much {recipient.address_as} for your support! All the best, Program Committee \"\"\" You see that we can use recipient and mail to access the attributes of the Recipient as well as the Mail object to personalize the e-mail. Now we create the Mail object with: from pytanis.helpdesk import Mail mail = Mail ( subject = \"Deadline is coming soon\" , text = mail_body , team_id = team_id , agent_id = agent_id , status = \"solved\" , recipients = recipients , )","title":"Writing the E-Mail"},{"location":"usage/mail/#sending-an-e-mail","text":"Now we have everything assembled to send the e-mail with: from pytanis.helpdesk import MailClient mail_client = MailClient () responses , errors = mail_client . send ( mail , dry_run = True ) assert not errors Having dry_run=True allows you to test you code and just print the resulting e-mails on your console to check if everything is like expected. Later set dry_run=False to actually send the e-mails via HelpDesk . The method send returns a list of successful responses and a hopefully empty list of errors . The responses list is a list of tuples where each tuple holds the Recipient as wells as the returned HelpDesk ticket. The errors list is a list of tuples with the Recipient and the corresponding exception object which occured when sending the mail to the recipient.","title":"Sending an E-mail"},{"location":"usage/mail/#advanced-usage","text":"For more details, check out Pytanis' mail references and also the notebook 20_mail_to_reviewers_v1 . Tip For contacting your (potential) speakers, Pretalx itself has pretty advanced templating and mailing features so there is no need to use this functionality here. Just make sure that you refer always to HelpDesk in your mails, so that you have a single point of managing mails and tickets.","title":"Advanced Usage"},{"location":"usage/pretalx/","text":"Basic Usage \u00b6 Pytanis offers easy access to the Pretalx API and the usage is quite self-explanatory. Let's look at some basic example: from pytanis import PretalxClient event_name = \"pyconde-pydata-berlin-2023\" pretalx_client = PretalxClient () subs_count , subs = pretalx_client . submissions ( event_name ) This simple code will return the total number of submissions as subs_count and an iterator of all submissions subs . When iterating over subs new requests will be made internally to the Pretalx server to retrieve more result pages. This method of retrieving partial results is called pagination . Quite often you will just use subs = list(subs) to retrieve all submissions and get a list instead for easier handling. If you want to retrieve always all results directly, i.e. in a blocking way, you can tell this to the client via PretalxClient(blocking=True) but be aware that you must still call subs = list(subs) . All endpoints of the Pretalx API are implemented in Pytanis and the method name corresponds to the name of the endpoint. Additional parameters can be passed using the params argument like e.g.: subs_count , subs = pretalx_client . submissions ( event_name , params = { \"questions\" : \"all\" , \"state\" : \"submitted\" } ) Check the Pretalx API for a list of options. Advanced Usage \u00b6 Find out more about the client's capabilities, e.g. throttling, by looking at Pytanis' reference of the pretalx client module .","title":"Pretalx Client"},{"location":"usage/pretalx/#basic-usage","text":"Pytanis offers easy access to the Pretalx API and the usage is quite self-explanatory. Let's look at some basic example: from pytanis import PretalxClient event_name = \"pyconde-pydata-berlin-2023\" pretalx_client = PretalxClient () subs_count , subs = pretalx_client . submissions ( event_name ) This simple code will return the total number of submissions as subs_count and an iterator of all submissions subs . When iterating over subs new requests will be made internally to the Pretalx server to retrieve more result pages. This method of retrieving partial results is called pagination . Quite often you will just use subs = list(subs) to retrieve all submissions and get a list instead for easier handling. If you want to retrieve always all results directly, i.e. in a blocking way, you can tell this to the client via PretalxClient(blocking=True) but be aware that you must still call subs = list(subs) . All endpoints of the Pretalx API are implemented in Pytanis and the method name corresponds to the name of the endpoint. Additional parameters can be passed using the params argument like e.g.: subs_count , subs = pretalx_client . submissions ( event_name , params = { \"questions\" : \"all\" , \"state\" : \"submitted\" } ) Check the Pretalx API for a list of options.","title":"Basic Usage"},{"location":"usage/pretalx/#advanced-usage","text":"Find out more about the client's capabilities, e.g. throttling, by looking at Pytanis' reference of the pretalx client module .","title":"Advanced Usage"}]}